<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

        <link rel="stylesheet" type="text/css" href="/css/base.css">
        <link rel="icon" type="image/x-icon" href="/img/favicon.ico">

        <!-- Font Awesome -->
        <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

        <!-- Syntax highlighting -->
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js"></script>
        <link rel="stylesheet" type="text/css" href="/css/highlight_theme.css">
        <script>hljs.highlightAll();</script>

        <!-- Renders LaTeX expression -->
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']], processEscapes: true}});
        </script>
        <script type="text/javascript" async 
                src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML">
        </script>

        <title>RSA</title>

    </head>

    <body>
        <header>
    <nav>
        <ul>
            <li><a href="/">Thibault Allançon</a></li>
            <li><a href="/articles.html">Articles</a></li>
        </ul>
    </nav>

    <h1><a href="">RSA</a></h1>

            <p class="metadata">Publié : 31/05/2014 · Modifié : 02/02/2016</p>
        <hr>
        </header>


        <h2 id="introduction">Introduction</h2>
<p>Tous les algorithmes de chiffrement <strong>symétriques</strong> ont
un problème commun : la transmission de clé. Quel que soit l'algorithme
utilisé, si la clé est interceptée par l'ennemi, alors il peut lire les
communications, mais aussi se faire passer pour le destinataire et
l'expéditeur du message. Ce problème est fondamental car transmettre une
clé de chiffrement est très délicat, et même impossible dans certains
cas (par exemple avec Internet, c'est compliqué d'aller voir
physiquement le responsable de chaque serveur pour qu'il vous transmette
une clé), il était donc nécessaire de trouver une autre solution face à
ce problème : les chiffrements <strong>asymétriques</strong>.</p>
<p>L'idée du chiffrement asymétrique est d'utiliser deux clés au lieu
d'une, que l'on va attribuer à chaque personne :</p>
<ul>
<li>Une clé <strong>publique</strong> qu'on peut diffuser, transmettre
et montrer à absolument tout le monde sans que cela pose un problème de
sécurité (c'est d'ailleurs conseillé de la rendre la plus accessible
possible).</li>
<li>Une clé <strong>privée</strong> qu'il ne faut en aucun cas évoquer,
cette clé doit rester secrète et vous ne devez la communiquer à
personne.</li>
</ul>
<p>Les bases du chiffrement asymétrique furent introduites par
<strong>Whitfield Diffie</strong> et <strong>Martin Hellman</strong> en
1976, lorsqu'ils ont montré comment résoudre le problème d'échange de
clés de manière sécurisée. La particularité de ce système est qu'il est
simple de générer des couples de clés, mais quasiment impossible de
retrouver la clé privée à partir de la clé publique.</p>
<p>En 1977 l'algorithme RSA est présenté, et sera l'un des premiers
systèmes de chiffrement asymétriques utilisant ce concept de paires de
clés et à en faire une implémentation possible pour la communication de
messages grâce à des principes mathématiques. Cet algorithme est encore
très utilisé de nos jours, surtout sur Internet (dans le commerce en
ligne, les transactions sécurisées, etc.) et constitue la base de
quasiment tous les systèmes de chiffrement modernes.</p>
<h2 id="principe-de-lalgorithme">Principe de l'algorithme</h2>
<p>L'algorithme RSA va dans un premier temps générer deux couples de
clés asymétriques, l'un pour l'**émetteur** qu'on appellera
<em>Alice</em>, et l'autre pour le <strong>destinataire</strong> qu'on
appellera <em>Bob</em>. Une fois que chaque personne a ses deux clés, on
peut procéder à une communication sécurisée. Alice va chercher la clé
publique de Bob (en général on pratique à un échange des clés publiques
avant de communiquer, ou alors on les diffuse publiquement), et elle va
chiffrer son message avec. Ensuite le message chiffré est transmis à
Bob, et il va le déchiffrer grâce à sa clé privée (qu'il n'a communiqué
à personne). Aucun échange de clé sensible n'est nécessaire, et seule la
clé privée de Bob peut déchiffrer le message, la communication est alors
sécurisée.</p>
<p>La sécurité de l'algorithme se trouve dans l'utilisation d'une
fonction de chiffrement et de déchiffrement <a
href="https://en.wikipedia.org/wiki/One-way_function">à sens unique</a>.
Cette fonction est, comme pour la génération de clé, très simple à
appliquer dans un sens (avec la clé privée), mais extrêmement complexe
dans l'autre (sans la clé privée).</p>
<p>Tout d'abord, regardons comment générer nos clés :</p>
<ul>
<li>Choisir deux <a
href="https://en.wikipedia.org/wiki/Prime_number">nombres premiers</a>
distincts <span class="math inline">\(p\)</span> et <span
class="math inline">\(q\)</span>.</li>
<li>Calculer le produit <span class="math inline">\(p \times q\)</span>
appelé <strong>module de chiffrement</strong> et abrégé <span
class="math inline">\(n\)</span>.</li>
<li>Calculer l'<a
href="https://en.wikipedia.org/wiki/Euler&#39;s_totient_function">indicatrice
d'Euler</a> de <span class="math inline">\(n\)</span>, qu'on notera
<span class="math inline">\(m = (p - 1) \times (q - 1)\)</span>
(l'indicatrice d'Euler est une fonction permettant de compter les
nombres premiers à <span class="math inline">\(x\)</span> situés entre 1
et <span class="math inline">\(x\)</span> compris).</li>
<li>Choisir un <strong>exposant de chiffrement</strong> noté <span
class="math inline">\(e\)</span>, qui soit premier avec <span
class="math inline">\(m\)</span> et strictement inférieur à ce
dernier.</li>
<li>Calculer l'**exposant de déchiffrement** noté <span
class="math inline">\(d\)</span>, qui est l'<a
href="https://en.wikipedia.org/wiki/Modular_multiplicative_inverse">inverse
modulaire</a> de <span class="math inline">\(e \mod m\)</span> (en
savoir plus sur le <a
href="https://en.wikipedia.org/wiki/Modulo_operation">modulo</a>).</li>
</ul>
<p>La clé publique correspond au couple (<span
class="math inline">\(n\)</span>, <span
class="math inline">\(e\)</span>) et la clé privée au couple (<span
class="math inline">\(n\)</span>, <span
class="math inline">\(d\)</span>).</p>
<p>Pour chiffrer notre message, on utilisera alors cette relation :</p>
<p><span class="math inline">\(f(x) = x^e \mod n\)</span></p>
<p>Avec <span class="math inline">\(x\)</span> le message en clair, et
<span class="math inline">\(f(x)\)</span> le message chiffré.</p>
<p>Et pour le déchiffrement, on utilise la fonction suivante :</p>
<p><span class="math inline">\(f&#39;(x) = x^d \mod n\)</span></p>
<p>Avec cette fois <span class="math inline">\(x\)</span> le message
chiffré et <span class="math inline">\(f&#39;(x)\)</span> le message
déchiffré.</p>
<h2 id="exemple">Exemple</h2>
<p>Choisissons comme message "Bienvenue", et chiffrons-le avec
l'algorithme RSA.</p>
<h3 id="génération-des-clés">Génération des clés</h3>
<p>La première étape est de générer notre clé publique et privée car je
n'en possède pas encore, et comme je n'ai pas d'ami nommé Bob à qui
envoyer des messages secrets, je vais m'envoyer le message chiffré à
moi-même (pour simplifier les explications et ne pas être embrouillé
dans toutes les valeurs numériques). On applique donc notre algorithme
de création de clés :</p>
<p>Soit <span class="math inline">\(p\)</span> et <span
class="math inline">\(q\)</span> deux nombres premiers que je choisis
aléatoirement :</p>
<p><span class="math inline">\(p = 61\)</span> et <span
class="math inline">\(q = 137\)</span></p>
<p>À partir de cela, on peut calculer notre module de chiffrement :</p>
<div class="line-block"><span class="math inline">\(n = p \times
q\)</span><br />
<span class="math inline">\(n = 8357\)</span></div>
<p>Ainsi que l'indicatrice d'Euler de <span
class="math inline">\(n\)</span> :</p>
<div class="line-block"><span class="math inline">\(m = (p - 1) \times
(q - 1)\)</span><br />
<span class="math inline">\(m = 8160\)</span></div>
<p>Ensuite, il faut choisir notre exposant de chiffrement <span
class="math inline">\(e\)</span> qui doit être premier avec <span
class="math inline">\(m\)</span> et strictement inférieur à ce dernier,
je choisis donc 7 :</p>
<p><span class="math inline">\(e = 7\)</span></p>
<p>Désormais nous devons trouver notre exposant de déchiffrement. Cette
partie est un peu plus compliquée, car elle nécessite quelques notions
de maths.</p>
<p>On cherche donc <span class="math inline">\(d\)</span> qui est
l'inverse modulaire de <span class="math inline">\(e \mod m\)</span>, on
a :</p>
<p><span class="math inline">\(d \equiv e^{-1} \pmod m\)</span></p>
<p>Ce qui est équivalent à :</p>
<p><span class="math inline">\(de \equiv 1 \pmod m\)</span></p>
<p>Par définition de la <a
href="https://en.wikipedia.org/wiki/Congruence_relation">congruence</a>,
<span class="math inline">\(m\)</span> est un diviseur de <span
class="math inline">\(d e - 1\)</span>, ce qu'on peut écrire comme ceci
:</p>
<p><span class="math inline">\(de - 1 = qm\)</span> avec <span
class="math inline">\(q\)</span> le quotient de <span
class="math inline">\(\frac{(de - 1)}{m}\)</span></p>
<p>On a finalement :</p>
<p><span class="math inline">\(de - qm = 1\)</span></p>
<p>On connait <span class="math inline">\(e\)</span>, <span
class="math inline">\(m\)</span>, et on cherche <span
class="math inline">\(d\)</span> :</p>
<p>On remarque que cette expression est de la forme de l'<a
href="https://en.wikipedia.org/wiki/B%C3%A9zout&#39;s_identity">identité
de Bézout</a> <span class="math inline">\(ax + by = pgcd(a, b)\)</span>
avec <span class="math inline">\(a = e\)</span>, <span
class="math inline">\(b = m\)</span>, <span class="math inline">\(x =
d\)</span>, <span class="math inline">\(y = -q\)</span>, et <span
class="math inline">\(e\)</span> et <span
class="math inline">\(m\)</span> sont premiers entre eux donc <span
class="math inline">\(pgcd(a, b) = 1\)</span>. Or on peut trouver les
coefficients <span class="math inline">\(x\)</span> et <span
class="math inline">\(y\)</span> (et donc <span
class="math inline">\(d\)</span>, qui nous intéresse) grâce à l'<a
href="https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm">algorithme
d'Euclide étendu</a>. Une implémentation de cet algorithme pour ceux que
ça intéresse :</p>
<details>
<summary>algo_euclide_etendu.c</summary>
<pre><code class="c">#include &lt;stdio.h&gt;

void euclideEtendu(int a, int b)
{
   int r0, r1;
   int s0, s1;
   int t0, t1;
   int i;
   int q, r, s, t;

   r0 = a;
   s0 = 1;
   t0 = 0;

   r1 = b;
   s1 = 0;
   t1 = 1;

   r = 42;
   for(i = 2; r != 0; ++i) {
      q = r0 / r1;
      r = r0 - q * r1;
      s = s0 - q * s1;
      t = t0 - q * t1;

      r0 = r1;
      r1 = r;
      s0 = s1;
      s1 = s;
      t0 = t1;
      t1 = t;
   }

   printf(&quot;x = %d\n&quot;, s0);
   printf(&quot;y = %d\n&quot;, t0);
}

int main(void)
{
   int a, b;
   scanf(&quot;%d %d\n&quot;, &amp;a, &amp;b);

   euclideEtendu(a, b);   

   return 0;
}</code></pre>
</details>
<p>L'entrée :</p>
<pre><code class="nohighlight">7
8160</code></pre>
<p>La sortie :</p>
<pre><code class="nohighlight">x = -3497
y = 3</code></pre>
<p>On trouve grâce au dernier programme :</p>
<p><span class="math inline">\(d = -3497\)</span></p>
<p>On a désormais <span class="math inline">\(d\)</span> vérifiant
l'équation <span class="math inline">\(de \equiv 1 \pmod m\)</span>.
Cependant, on préfèrera travailler avec des nombres positifs, et selon
Wikipédia le coefficient <span class="math inline">\(x\)</span> n'est
pas unique (<span class="math inline">\(y\)</span> non plus mais c'est
<span class="math inline">\(x\)</span> qui nous intéresse), et on peut
en trouver une infinité qui respectent la relation suivante :</p>
<p><span class="math inline">\(x + k\frac{b}{pgcd(a, b)}\)</span> avec
<span class="math inline">\(k\)</span> un nombre entier relatif</p>
<p>Si on remplace par nos valeurs (<span class="math inline">\(x =
d\)</span>, <span class="math inline">\(b = m\)</span>, <span
class="math inline">\(pgcd(a, b) = 1\)</span>), on obtient :</p>
<p><span class="math inline">\(d + km\)</span></p>
<p>Et avec les valeurs numériques :</p>
<p><span class="math inline">\(-3497 + 8160k\)</span></p>
<p>On veut donc trouver un nombre <span class="math inline">\(d\)</span>
positif :</p>
<div class="line-block"><span class="math inline">\(-3497 + 8160k &gt;
0\)</span><br />
<span class="math inline">\(k &gt; 0,429\)</span> (arrondi)</div>
<p>Or <span class="math inline">\(k\)</span> est un nombre entier, je
vais donc arrondir à l'entier supérieur <span class="math inline">\(k =
1\)</span> pour avoir une valeur de <span
class="math inline">\(d\)</span> positive :</p>
<div class="line-block"><span class="math inline">\(d = -3497 +
m\)</span><br />
<span class="math inline">\(d = 4663\)</span></div>
<p>Notre couple de clé publique/privée est désormais généré :</p>
<ul>
<li>Clé publique de la forme (<span class="math inline">\(n\)</span>,
<span class="math inline">\(e\)</span>) : (8357, 7)</li>
<li>Clé privée de la forme (<span class="math inline">\(n\)</span>,
<span class="math inline">\(d\)</span>) : (8357, 4663)</li>
</ul>
<h3 id="chiffrementdéchiffrement">Chiffrement/Déchiffrement</h3>
<p>On peut maintenant chiffrer et déchiffrer notre message avec nos clés
en appliquant les fonctions :</p>
<div class="line-block"><span class="math inline">\(f(x) = x^e \mod
n\)</span><br />
<span class="math inline">\(f&#39;(x) = x^d \mod n\)</span></div>
<p>Les caractères seront représentés par des nombres grâce à la <a
href="https://en.wikipedia.org/wiki/ASCII">table ASCII</a> permettant de
résoudre les relations mathématiques (on imagine dans notre cas que les
caractères du message sont tous présents dans la table ASCII pour
simplifier le problème).</p>
<p>Notre message correspond donc à ceci selon la table ASCII :</p>
<figure>
<img src="/img/algo/chiffrement/rsa/exemple_message_ascii.png"
alt="/img/algo/chiffrement/rsa/exemple_message_ascii.png" />
<figcaption>Transformation du message en nombre</figcaption>
</figure>
<p>Le message chiffré :</p>
<figure>
<img src="/img/algo/chiffrement/rsa/exemple_chiffrement.png"
alt="/img/algo/chiffrement/rsa/exemple_chiffrement.png" />
<figcaption>Exemple de chiffrement</figcaption>
</figure>
<p>On se retrouve avec un message ressemblant à ceci</p>
<pre><code class="nohighlight">2546 824 4962 8071 2160 4962 8071 5933 4962 </code></pre>
<p>Que l'on peut déchiffrer :</p>
<figure>
<img src="/img/algo/chiffrement/rsa/exemple_dechiffrement.png"
alt="/img/algo/chiffrement/rsa/exemple_dechiffrement.png" />
<figcaption>Exemple de déchiffrement</figcaption>
</figure>
<p>On retrouve bien nos valeurs numériques que l'on peut facilement
transformer en caractères pour former notre message original.</p>
<h2 id="pseudo-code">Pseudo-code</h2>
<p>Le pseudo-code de l'algorithme RSA :</p>
<pre><code class="nohighlight">cléPublique(p, q) :

   Choisir aléatoirement p et q, deux nombres premiers distincts
   n = p * q
   m = (p - 1) * (q - 1)
   Choisir e strictement inférieur à m et premier avec lui

   Retourner couple (n, e)

cléPrivée(e, m, n) :

   Algorithme d&#39;Euclide étendu pour calculer d (l&#39;inverse de la multiplication
   de e mod m)

   Retourner couple (n, d)

chiffrer :

   Pour chaque caractère du message
      lettreChiffrée = lettreClaire ^ e mod n 

déchiffrer :

   Pour chaque caractère du message
      lettreClaire = lettreChiffrée ^ d mod n </code></pre>
<p>Une dernière question se pose cependant face à ce pseudo-code :
comment calculer des nombres avec des puissances aussi énormes ? En
effet, <span class="math inline">\(d = 4663\)</span> dans notre exemple
et élever un nombre à la puissance 4663 est tout simplement fou (surtout
qu'en situation réelle, notre <span class="math inline">\(e\)</span> et
<span class="math inline">\(d\)</span> peuvent comporter plusieurs
centaines de chiffres chacun). Si on calcule séparément <span
class="math inline">\(a^b\)</span> puis on applique le modulo <span
class="math inline">\(c\)</span> sur le résultat on sera confronté à un
problème de stockage car quand <span class="math inline">\(b\)</span>
est grand le résultat <span class="math inline">\(a^b\)</span> sera
tellement gigantesque que notre programme ne pourra pas stocker ce
nombre. Heureusement un algorithme nous permet de calculer facilement le
résultat d'une opération du style <span class="math inline">\(a^b \mod
c\)</span>, c'est l'<a
href="https://en.wikipedia.org/wiki/Modular_exponentiation">exponentiation
modulaire</a>.</p>
<p>Soit <span class="math inline">\(x = a^b \mod c\)</span>, on peut
trouver <span class="math inline">\(x\)</span> facilement grâce à notre
nouvel algorithme :</p>
<pre><code class="nohighlight">x = 1
Pour chaque exposant allant de 1 à b inclus
   x = (x * a) mod c</code></pre>
<p>Cet algorithme nous permet donc de travailler avec des nombres bien
plus petits qui ne dépasseront jamais <span
class="math inline">\(c\)</span> car à chaque multiplication on effectue
un modulo dessus.</p>
<h2 id="implémentation">Implémentation</h2>
<p>Une implémentation en C de l'algorithme de RSA :</p>
<details>
<summary>rsa.c</summary>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;

#define TAILLE_MAX 1000

unsigned long long message[TAILLE_MAX];
int taille;
// Clé
int p, q;
int n;
int m;
int e, d;

int PGCD(int a, int b)
{
   int r;

   while(b != 0) {
      r = a % b;
      a = b;
      b = r;
   }

   return a;
}

int euclideEtendu(int a, int b)
{
   int r0, r1;
   int s0, s1;
   int t0, t1;
   int i;
   int q, r, s, t;

   r0 = a;
   s0 = 1;
   t0 = 0;

   r1 = b;
   s1 = 0;
   t1 = 1;

   r = 42;
   for(i = 2; r != 0; ++i) {
      q = r0 / r1;
      r = r0 - q * r1;
      s = s0 - q * s1;
      t = t0 - q * t1;

      r0 = r1;
      r1 = r;
      s0 = s1;
      s1 = s;
      t0 = t1;
      t1 = t;
   }

   return s0;
}

void clePublique(void)
{
   static int premier[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 
      47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 
      131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,
      211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283,
      293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383,
      389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467,
      479, 487, 491, 499, 503, 509, 521, 523, 541};

   /*do
     {
     p = premier[rand() % 100];
     q = premier[rand() % 100];

     } while(p == q);*/

   p = 61;
   q = 137;

   n = p * q;
   m = (p - 1) * (q - 1);

   for(e = 2; PGCD(e, m) != 1; ++e)
      ;
}

void clePrivee(void)
{
   d = euclideEtendu(e, m);
   while(d &lt; 0)
      d += m;
}

void chiffrement(void)
{
   int iMessage, iExp;
   int lettre;

   for(iMessage = 0; iMessage &lt; taille; ++iMessage) {
      // Exponentiation modulaire
      lettre = message[iMessage];
      message[iMessage] = 1;
      for(iExp = 1; iExp &lt;= e; ++iExp)
         message[iMessage] = (message[iMessage] * lettre) % n;
   }
}

void dechiffrement(void)
{
   int iMessage, iExp;
   int lettre;

   for(iMessage = 0; iMessage &lt; taille; ++iMessage) {
      // Exponentiation modulaire
      lettre = message[iMessage];
      message[iMessage] = 1;
      for(iExp = 1; iExp &lt;= d; ++iExp)
         message[iMessage] = (message[iMessage] * lettre) % n;
   }
}

int main(void)
{
   char iCar;
   int iMessage;

   // Lit le message et le transforme en nombre 
   iMessage = 0;
   do
   {
      scanf(&quot;%c&quot;, &amp;iCar);
      if(iCar != &#39;\n&#39;) {
         message[iMessage] = (unsigned long long)iCar;
         ++iMessage;
      }
   } while(iCar != &#39;\n&#39;);
   taille = iMessage;

   // Génère le couple de clé
   srand(time(NULL));
   clePublique();
   clePrivee();

   printf(&quot;Cle publique : %d %d\n&quot;, n, e);
   printf(&quot;Cle privee : %d %d\n&quot;, n, d);

   // Chiffre le message et l&#39;affiche comme une suite de nombre
   chiffrement();
   for(iMessage = 0; iMessage &lt; taille; ++iMessage)
      printf(&quot;%llu &quot;, message[iMessage]);
   printf(&quot;\n&quot;);

   // Déchiffre le message et l&#39;affiche comme une chaîne
   dechiffrement();
   for(iMessage = 0; iMessage &lt; taille; ++iMessage)
      printf(&quot;%c&quot;, (char)message[iMessage]);
   printf(&quot;\n&quot;);

   return 0;
}</code></pre>
<p>Quelques remarques sur le code :</p>
<ul>
<li>Le type du message est <code>unsigned long long</code> qui est le
type le plus grand en C (il stocke des nombres allant de <span
class="math inline">\(0\)</span> à <span class="math inline">\(2^{64} -
1\)</span>), car un <code>int</code> ne sera pas toujours suffisant, on
prend donc des précautions en utilisant un type de données très grand
pour ne pas avoir de problèmes. Sachez qu'en C, il existe la
bibliothèque <a href="https://gmplib.org/">GMP</a> pour manipuler de
<strong>très</strong> grands nombres.</li>
<li>Dans la fonction <code>clePublique</code>, j'utilise un tableau
statique contenant tous les nombres premiers de 1 à 100 et je tire au
sort pour déterminer <span class="math inline">\(p\)</span> et <span
class="math inline">\(q\)</span> (j'ai rentré directement
<code>p = 61</code> et <code>q = 137</code> pour que les résultats
concordent avec notre exemple, mais la partie tirage au sort est
commentée).</li>
<li>Pour lire notre message, on va directement stocker les caractères
sous forme de nombre pour que le reste du programme soit plus simple, et
pour la sortie on convertit en <code>char</code> après le déchiffrement
pour afficher une chaîne de caractères.</li>
</ul>
</details>
<p>Le message d'entrée :</p>
<pre><code class="nohighlight">Bienvenue</code></pre>
<p>La sortie :</p>
<pre><code class="nohighlight">Cle publique : 8357 7
Cle privee : 8357 4663
2546 824 4962 8071 2160 4962 8071 5933 4962 
Bienvenue</code></pre>
<p>Il est important de noter que recréer sa propre implémentation de RSA
(ou même de n'importe quel algorithme de chiffrement) dans le but de
l'utiliser dans une application concrète est une mauvaise idée, et il
est conseillé d'utiliser des implémentations déjà existantes, libres,
accessibles à tous et qui sont utilisées par des milliers d'autres
personnes comme : <a href="https://www.openssl.org/">OpenSSL</a>, <a
href="https://gnupg.org/">GnuPG</a>, etc. L'avantage d'utiliser ce genre
d'outils est que de nombreuses personnes travaillent dessus chaque jour,
et des recherches sont effectuées régulièrement pour découvrir les
potentielles failles afin de rendre le système encore plus robuste.</p>
<h2 id="démonstration">Démonstration</h2>
<p><em>Cette partie n'est pas essentielle pour comprendre le
fonctionnement de l'algorithme, mais permet aux curieux de voir comment
démontrer que notre système marche. Plusieurs notions mathématiques sont
nécessaires pour la compréhension de la démonstration, mais sachez que
j'ai appris au fur et à mesure en rédigeant cette partie sans connaitre
à l'avance les outils mathématiques utilisés, donc il est tout à fait
possible qu'un lecteur fasse de même s'il est vraiment intéressé par le
sujet.</em></p>
<p>C'est bien beau toutes ces explications, mais mathématiquement comme
être sûr que notre algorithme marche à tous les coups ? Comment savoir
si notre message original une fois chiffré sera le même quand il est
déchiffré ?</p>
<p>Pour cela il faut prouver que l'algorithme RSA est valide, on part
donc des deux fonctions de chiffrement et de déchiffrement :</p>
<div class="line-block"><span class="math inline">\(f(x) = x^e \mod
n\)</span><br />
<span class="math inline">\(f&#39;(x) = x^d \mod n\)</span></div>
<p>Dire que notre algorithme est valide revient à prouver que :</p>
<p><span class="math inline">\(f(f&#39;(x)) = f&#39;(f(x)) = x \mod
n\)</span></p>
<p>Cependant on remarque que :</p>
<div class="line-block"><span class="math inline">\(f(f&#39;(x)) = (x^d
\mod n)^e \mod n\)</span><br />
<span class="math inline">\(f(f&#39;(x)) = x^{ed} \mod n\)</span></div>
<p>Et :</p>
<div class="line-block"><span class="math inline">\(f&#39;(f(x)) = (x^e
\mod n)^d \mod n\)</span><br />
<span class="math inline">\(f&#39;(f(x)) = x^{ed} \mod n\)</span></div>
<p>On a <span class="math inline">\(f(f&#39;(x)) = f&#39;(f(x)) = x^{ed}
\mod n\)</span>, et on cherche donc à démontrer que <span
class="math inline">\(x^{ed} \equiv x \pmod{pq}\)</span> (car <span
class="math inline">\(n = pq\)</span>). Or d'après le <a
href="https://en.wikipedia.org/wiki/Chinese_remainder_theorem">théorème
des restes chinois</a>, pour démontrer la congruence <span
class="math inline">\(pq\)</span>, il suffit de démontrer les
congruences <span class="math inline">\(p\)</span> et <span
class="math inline">\(q\)</span> séparément. Démontrons d'abord que
<span class="math inline">\(x^{ed} \equiv x \pmod p\)</span> :</p>
<p>On va diviser le problème en deux cas, soit <span
class="math inline">\(x\)</span> est divisible par <span
class="math inline">\(p\)</span>, soit il ne l'est pas, donc soit <span
class="math inline">\(x \equiv 0 \pmod p\)</span>, soit <span
class="math inline">\(x \not\equiv 0 \pmod p\)</span>, commençons par le
premier cas (qui est le plus simple) :</p>
<p><span class="math inline">\(x\)</span> est un multiple de <span
class="math inline">\(p\)</span>, donc <span
class="math inline">\(x^{ed} \equiv 0 \pmod p\)</span>, or <span
class="math inline">\(x \equiv 0 \pmod p\)</span>, donc <span
class="math inline">\(x^{ed} \equiv x \pmod p\)</span>.</p>
<p>On continue avec notre deuxième cas où <span
class="math inline">\(x\)</span> n'est pas divisible par <span
class="math inline">\(p\)</span> :</p>
<p>Tout d'abord, par définition de <span
class="math inline">\(e\)</span>, <span class="math inline">\(d\)</span>
et <span class="math inline">\(m\)</span> :</p>
<div class="line-block"><span class="math inline">\(ed \equiv 1 \pmod
m\)</span><br />
<span class="math inline">\(ed \equiv 1 \pmod{(p - 1)(q -
1)}\)</span></div>
<p>Ceci signifie que <span class="math inline">\((p - 1)(q - 1)\)</span>
est un diviseur de <span class="math inline">\(ed - 1\)</span>, on a
:</p>
<p><span class="math inline">\(ed = 1 + k(p - 1)(q - 1)\)</span> avec
<span class="math inline">\(k\)</span> un nombre entier représentant le
quotient de <span class="math inline">\(\frac{(ed - 1)}{(p - 1)(q -
1)}\)</span></p>
<p>Donc :</p>
<div class="line-block"><span class="math inline">\(x^{ed} = x^{1 + k(p
- 1)(q -1)}\)</span><br />
<span class="math inline">\(x^{ed} = x(x^{p - 1})^{k(q
-1)}\)</span></div>
<p>Et d'après le <a
href="https://en.wikipedia.org/wiki/Fermat&#39;s_little_theorem">théorème
de Fermat</a> <span class="math inline">\(x^{p - 1} \equiv 1 \pmod
p\)</span> :</p>
<div class="line-block"><span class="math inline">\(x^{ed} \equiv
x(1)^{k(q - 1)} \pmod p\)</span><br />
<span class="math inline">\(x^{ed} \equiv x \pmod p\)</span></div>
<p>Donc pour tout <span class="math inline">\(x\)</span>, on a <span
class="math inline">\(x^{ed} \equiv x \pmod p\)</span>. La démonstration
pour la congruence de <span class="math inline">\(q\)</span> est
exactement la même. On a démontré que <span class="math inline">\(x^{eq}
\equiv x \pmod{pq}\)</span>, et donc que <span
class="math inline">\(x^{eq} \equiv x \pmod n\)</span>, donc notre
algorithme vérifie l'équation au départ confirmant la validité de
RSA.</p>
<h2 id="sécurité">Sécurité</h2>
<h3 id="le-message">Le message</h3>
<p>Si vous êtes observateur, vous avez peut-être remarqué que finalement
le message chiffré obtenu est le résultat d'une simple <a
href="https://en.wikipedia.org/wiki/Substitution_cipher">substitution
mono-alphabétique</a> et que par conséquent chaque lettre sera toujours
chiffrée de la même façon. Ceci est grave car notre message ne va pas
résister longtemps à une cryptanalyse basique. Prenons l'exemple du
message "Bienvenue", on a obtenu le résultat suivant
<code>2546 824 4962 8071 2160 4962 8071 5933 4962</code>, cependant ce
message a été chiffré avec une clé publique, et donc comme n'importe qui
peut accéder à cette clé, il est facile d'établir un tableau de
correspondance en chiffrant chaque lettre de l'alphabet avec la clé
publique afin de déduire à quelle lettre de l'alphabet correspond notre
lettre du message chiffré. Ce problème est dû au fait que l'on peut
distinguer les différentes lettres dans notre message chiffré, si ce
n'était pas le cas on aurait aucunes informations sur la clé privée
utilisée ou encore sur le message déchiffré.</p>
<p>Il est donc nécessaire de procéder autrement afin de sécuriser le
message en lui-même et en rendant impossible tout cryptanalyse dessus.
Si vous utilisez l'algorithme RSA, il y a de fortes chances que vous
êtes sur un ordinateur, cependant sur un ordinateur tout est stocké à
l'aide de <a href="https://en.wikipedia.org/wiki/Bit">bit</a> (une
simple unité valant soit 0 soit 1, permettant de compter en <a
href="https://en.wikipedia.org/wiki/Binary_number">base binaire</a>), un
groupe de 8 bits est appelé un <a
href="https://en.wikipedia.org/wiki/Octet_%28computing%29">octet</a>.
Quand votre ordinateur stocke une chaîne de caractères, il stocke en
réalité une succession d'octets formant chaque lettre, par exemple dans
la table ASCII on peut utiliser un seul octet pour représenter les 128
valeurs car elles ne nécessitent que 7 bits pour être stockées. En
sachant cela, on sait qu'une suite d'octet peut être interprétée comme
une chaîne car pour notre ordinateur tout est un nombre, c'est nous qui
lui disons que tel caractère correspond à tel octet (et inversement)
avec des tables comme celle ASCII. On pourrait donc représenter notre
message non plus comme une suite d'octet mais comme un <strong>groupe
d'octet uni</strong>, ce qui fait qu'au lieu de chiffrer chaque octet un
par un, on chiffre le tout d'un seul coup, rendant alors la cryptanalyse
impossible (avec l'ancien système un octet pouvait valoir une des 128
valeurs, mais désormais notre groupe d'octet réuni peut prendre un
nombre considérable de valeurs différentes qui augmente avec la taille
du message). Il n'y a aucun moyen de trouver des informations à cause de
ce groupement, et la seule solution est d'essayer toutes les
combinaisons, mais vu le nombre de possibilités, on se rend vite compte
que c'est impossible. Prenons par exemple le message "Code" :</p>
<table style="width:60%;">
<colgroup>
<col style="width: 20%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
</colgroup>
<thead>
<tr>
<th>Lettre</th>
<th>C</th>
<th>o</th>
<th>d</th>
<th>e</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hexadécimale</td>
<td>0x43</td>
<td>0x6F</td>
<td>0x64</td>
<td>0x65</td>
</tr>
<tr>
<td>Décimale</td>
<td>67</td>
<td>111</td>
<td>100</td>
<td>101</td>
</tr>
</tbody>
</table>
<p>J'utilise la notation <a
href="https://en.wikipedia.org/wiki/Hexadecimal">hexadécimale</a> car
cette dernière permet de stocker un octet plus simplement qu'en notation
décimale. Notre message devient alors la suite d'octet
<code>0x436F6465</code> (ce nombre correspond à 1131373669 en décimal)
que notre ordinateur peut tout à fait comprendre si on lui indique
d'afficher cette suite comme une chaîne. Donc au lieu de chiffrer les
nombres <code>0x43</code>, <code>0x6F</code>, <code>0x64</code>,
<code>0x65</code> séparément on va plutôt chiffrer
<code>0x436F6465</code> uniquement. Puisqu'on sait que notre message
utilise la table ASCII et que cette dernière n'a besoin que d'un octet
pour représenter toutes les valeurs possibles, on sait qu'une lettre en
notation hexadécimale ne prendra pas plus de deux caractères (si on
exclut le <code>0x</code> qui est juste là pour indiquer que c'est de
l'hexadécimal). On peut donc une fois notre nombre déchiffré, le
découper en plusieurs nombres (toujours représentés en notation
hexadécimale) que l'on va convertir en caractère grâce à la table
ASCII.</p>
<p>En C par exemple, il est facile de convertir une chaîne en un nombre
hexadécimal et inversement :</p>
<details>
<summary>hexadecimal.c</summary>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define TAILLE_MAX 1000

int main(void)
{
   char message[TAILLE_MAX];
   char hexa[TAILLE_MAX * 2];
   char caractere[8];
   int iMessage, ihexa;

   scanf(&quot;%[^\n]s\n&quot;, message);

   // Transformation du message en une chaîne représentant notre nombre hexadécimal
   for(iMessage = 0; message[iMessage] != &#39;\0&#39;; ++iMessage) {
      sprintf(caractere, &quot;%x&quot;, message[iMessage]);
      strcat(hexa, caractere);
   }
   printf(&quot;0x%s\n&quot;, hexa);

   // Transformation en une chaîne de caractère lisible
   for(ihexa = 0; hexa[ihexa] != &#39;\0&#39;; ihexa += 2) {
      char lettre[3];
      lettre[0] = hexa[ihexa];
      lettre[1] = hexa[ihexa + 1];
      lettre[2] = &#39;\0&#39;;

      printf(&quot;%c&quot;, (int)strtoul(lettre, NULL, 16));
   }
   printf(&quot;\n&quot;);

   return 0;
}</code></pre>
<p>On peut utiliser le spécificateur <code>x</code> dans <a
href="http://www.cplusplus.com/reference/cstdio/printf/">printf</a> afin
de convertir notre lettre en nombre hexadécimal. De même, on peut
utiliser <a
href="http://www.cplusplus.com/reference/cstdlib/strtoul/">stroul</a>
afin de convertir notre nombre hexadécimal en base 10 et de l'afficher
comme un caractère.</p>
</details>
<p>En entrée par exemple du programme :</p>
<pre><code class="nohighlight">Code</code></pre>
<p>On obtient bien en sortie notre message sous forme d'un nombre
hexadécimal :</p>
<pre><code class="nohighlight">0x436f6465
Code</code></pre>
<p>Cependant quand notre message est important, le nombre obtenu est
beaucoup trop grand pour être chiffré, il faut alors découper notre
message en plusieurs sous nombres hexadécimaux au lieu d'un seul et
appliquer le même principe de chiffrement/déchiffrement.</p>
<h3 id="les-clés">Les clés</h3>
<p>Désormais qu'on sait que notre message peut être sécurisé, il ne nous
reste plus qu'à prouver que notre système de clé asymétrique est fiable
car si l'ennemi arrive à calculer la clé privée, il peut déchiffrer le
message simplement sans avoir à le casser.</p>
<p>Tout le monde peut théoriquement accéder à la clé publique d'une
personne et donc peut connaître <span class="math inline">\(n\)</span>
et <span class="math inline">\(e\)</span>, mais cela est-il réellement
un problème ? Car pour avoir la clé privée il faut trouver <span
class="math inline">\(d\)</span> puisqu'on connait déjà <span
class="math inline">\(n\)</span>, or pour trouver <span
class="math inline">\(d\)</span>, il nous faut <span
class="math inline">\(e\)</span> (que l'on a), mais surtout <span
class="math inline">\(m\)</span>. Pour rappel <span
class="math inline">\(m = (p - 1) \times (q - 1)\)</span>, et les seules
informations qu'on pourrait avoir sur <span
class="math inline">\(p\)</span> et <span
class="math inline">\(q\)</span> peuvent venir de <span
class="math inline">\(n\)</span> car <span class="math inline">\(n = p
\times q\)</span>. Il faudrait donc <strong>factoriser</strong> <span
class="math inline">\(n\)</span> en ses deux <strong>facteurs
premiers</strong> <span class="math inline">\(p\)</span> et <span
class="math inline">\(q\)</span>. Et c'est là que l'histoire se
complique, car s'il est facile de trouver et de multiplier deux nombres
premiers entre eux, il l'est beaucoup moins pour <a
href="https://en.wikipedia.org/wiki/Integer_factorization">décomposer en
produit de facteurs premiers</a>. Aujourd'hui, personne n'a encore
trouvé d'algorithme qui s'exécute en <a
href="https://en.wikipedia.org/wiki/Time_complexity#Polynomial_time">temps
polynomial</a>, et le meilleur algorithme qu'on connaisse a une
complexité exponentielle (et qui ressemble à ça pour les curieux : <span
class="math inline">\(O(\exp((\frac{64b}{9})^{\frac{1}{3}}(\log
b)^{\frac{2}{3}}))\)</span> avec <span class="math inline">\(b\)</span>
le nombre de bit de notre nombre <span
class="math inline">\(n\)</span>). Cependant, la question de l'existence
d'un algorithme efficace de décomposition d'un nombre en ses facteurs
premiers reste encore ouverte et pourrait jouer un rôle majeur en
cryptographie si la réponse était découverte. En attendant, on peut
jouer sur le fait qu'il est donc très long de décomposer <span
class="math inline">\(n\)</span>, et qu'il faudrait beaucoup de moyens
pour trouver une clé de chiffrement privée en un temps raisonnable.
C'est pourquoi il faut choisir la taille de ses clés avec attention et
les renouveler si possible régulièrement.</p>
<p>Aujourd'hui une clé est "sécurisée" si elle contient entre 2048 et
4096 bits, mais "sécurisé" n'est pas entre guillemets pour rien car
certes votre voisin sera incapable de casser votre clé, certes votre
groupe de hacker préféré non plus (à part s'ils ont des moyens colossaux
à leur disposition), mais par contre une agence gouvernementale pourrait
éventuellement y arriver. En effet des agences comme la <a
href="https://en.wikipedia.org/wiki/National_Security_Agency">NSA</a>
ont d'énormes moyens techniques mis en œuvre (qui évoluent, mais dont on
a une petite idée grâce aux révélations de <a
href="https://en.wikipedia.org/wiki/Edward_Snowden">Snowden</a> en
2013), et même si sur une grande échelle ils ne peuvent pas casser
toutes les clés aussi importantes que cela, il est possible pour eux de
casser quelques-unes en particulier si elles sont d'un très haut niveau
d'importance. Pour cela, l'agence utilise des <a
href="https://en.wikipedia.org/wiki/Supercomputer">superordinateurs</a>
qui souvent sont construits et optimisés spécifiquement dans le but de
casser telle ou telle clé, et ils investissent des millions (voir des
milliards selon leur budget annuel) dans la recherche afin de trouver
une factorisation en un temps raisonnable (d'environ un an en général).
En plus de cela, l'agence peut faire des pressions sur des organisations
contenant des données sensibles, on retiendra notamment l'affaire <a
href="https://en.wikipedia.org/wiki/Lavabit">lavabit</a> où la NSA a
obligé le créateur de ce service de mail chiffré à divulguer des
informations secrètes à propos d'Edward Snowden. Le créateur ne pouvait
en aucun cas parler de cette affaire au grand public sous peine
d'emprisonnement et d'amende considérable, et fut finalement forcé de
fermer son système de communication afin de ne pas coopérer avec la NSA.
De nombreuses autres affaires de pression de la part de la NSA ou de
gouvernements en général existent, et elles montrent bien la
détermination de certaines agences dans le but de trouver les clés
privées de certains individus.</p>
<p>Ce qu'il faut retenir de cela, est qu'il est nécessaire pour avoir un
système sécurisé d'utiliser des <strong>clés importantes en
taille</strong> et que l'on <strong>renouvelle
régulièrement</strong>.</p>
<h3 id="identification">Identification</h3>
<p>À moins que vous ayez de gros problèmes avec la NSA, votre clé
devrait normalement être sécurisée si elle est assez longue. Mais il
reste encore une faille dans notre système c'est la transmission de la
clé publique. En effet, cette communication peut être compromise si
quelqu'un se fait passer pour vous, et l'usurpation d'identité est
résolue grâce à une <strong>signature numérique</strong> (comme lorsque
vous signez un papier administratif dans la vraie vie pour vous
identifier).</p>
<p>Le principe est plutôt simple, on a vu que pour un message <span
class="math inline">\(x\)</span>, on a <span
class="math inline">\(f(f&#39;(x)) = f&#39;(f(x)) = x \mod n\)</span>.
Lorsqu'on veut signer notre message et certifier que c'est nous qui
l'avons envoyé, on va dans un premier temps chiffrer notre message avec
notre clé privée, puis on le chiffre de nouveau avec la clé publique de
la personne à qui on souhaite envoyer le message. Une fois que la
personne le reçoit, elle va déchiffrer avec sa clé privée le message
puis, elle va le déchiffrer de nouveau avec votre clé publique (car on a
chiffré dans un premier temps avec notre propre clé privée). Si le
message a un sens, cela confirme que c'est bien vous qui l'avais envoyé
car vous êtes le seul à connaître votre clé privée.</p>
<p>Malheureusement, sur de grands messages, cela prend beaucoup de temps
de chiffrer et déchiffrer deux fois au lieu d'une. On a donc eu l'idée
d'utiliser une <a
href="https://en.wikipedia.org/wiki/Hash_function">fonction de
hachage</a>, cette fonction prend en entrée un message, un nombre, une
image, etc. et lui associe une <strong>empreinte unique</strong> de
taille fixe (il suffit de changer une partie minime du message pour
avoir une empreinte totalement différente), et cette empreinte ne permet
en aucun cas de retrouver l'entrée de la fonction de hachage. Il est
possible que vous en ayez déjà entendu parler ou même utiliser si par
exemple vous utilisez Linux car lorsque vous téléchargez l'image d'une
distribution, il est souvent possible de vérifier l'intégrité et la
validité de l'image grâce à un programme utilisant une fonction de
hachage comme <a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1</a> ou
encore <a href="https://en.wikipedia.org/wiki/MD5">MD5</a>. On va donc
donner à notre fonction de hachage notre message en clair, et on va
chiffrer une première fois l'empreinte avec notre clé privée, puis on la
joint au message que l'on veut transmettre, et on chiffre le tout comme
un message normal avec la clé publique du destinataire avant de
l'envoyer. Une fois que la personne reçoit le message, elle le déchiffre
avec sa clé privée et déchiffre l'empreinte jointe avec la clé publique
de l'émetteur, elle va ensuite vérifier l'empreinte en réalisant une de
son côté (avec la même fonction de hachage que celle utilisée par
l'émetteur). Si l'empreinte est la même alors on est sûr que le message
est complet, non modifié et provient bien du destinataire, sinon c'est
qu'il a été corrompu. Cette méthode est bien plus courte et rapide car
on chiffre/déchiffre uniquement deux fois l'empreinte et non pas le
message entier.</p>
<h2 id="cassage">Cassage</h2>
<p>Notre système est donc théoriquement sécurisé, et le seul moyen que
l'on connait pour le moment est d'investir beaucoup d'argent et de temps
pour factoriser <span class="math inline">\(n\)</span>. Cependant, tout
le monde n'utilise pas RSA à la perfection, et on peut trouver certaines
failles dans des utilisations de cet algorithme qui permettent d'autres
types d'attaques.</p>
<h3 id="lattaque-de-lhomme-du-milieu">L'attaque de l'homme du
milieu</h3>
<p>Imaginons qu'Alice souhaite communiquer avec Bob, pour cela ils
s'échangent leurs clés publiques. Cependant, Carole qui est une méchante
personne, intercepte la clé publique de Bob qu'il a envoyée à Alice, et
Carole va envoyer sa propre clé publique. Désormais, lorsqu'Alice va
chiffrer son message avec la soi-disant clé de Bob, elle le chiffre en
réalité avec celle de Carole, ce qui signifie que lorsque Alice envoie
un message chiffré à Bob, si Carole l'intercepte elle va déchiffrer le
message, le lire, potentiellement le modifier, et le chiffrer avec la
clé publique de Bob avant de lui renvoyer. Ainsi, Alice et Bob ne se
doutent de rien et pensent que leur communication est sécurisée, mais
Carole a pu lire et modifier leurs messages.</p>
<p>Cette attaque peut être extrêmement gênante, et avec Internet c'est
encore plus simple de la réaliser car vous n'êtes jamais réellement sûr
que votre communication va directement au serveur sans passer par un
autre ordinateur ennemi. Mais on peut contrer cette attaque grâce à
plusieurs techniques, tout d'abord l'utilisation d'un annuaire contenant
toutes les clés publiques de chaque personne ne nécessiterait plus la
communication de clés. Cependant, il est possible que Carole soit très
puissante et soit capable de modifier cet annuaire, on pourrait alors
penser à plusieurs solutions comme un système d'identification physique
(empreinte digitale, reconnaissance faciale, reconnaissance de l'iris,
authentification par biométrie, etc.), ou encore une transmission
manuelle dans une valise diplomatique par exemple. Mais toutes ces
propositions ne sont pas applicables dans tous les domaines, sur
Internet encore une fois on ne peut pas se permettre de se baser sur une
identification physique d'un serveur, c'est alors qu'apparait les <a
href="https://en.wikipedia.org/wiki/Certificate_authority">autorités de
certifications</a>. L'idée est d'utiliser une <strong>personne
intermédiaire</strong> que l'émetteur et le destinataire font
<strong>confiance</strong>, qui se chargera de la transmission des clés,
mais pour être sûr de la sécurité on va en utiliser plusieurs qui à la
chaîne se transmettent les clés et se font confiance. On crée alors
plusieurs <strong>couches de sécurité</strong> lors de la transmission
de la clé publique aux autorités de certification, et c'est d'ailleurs
sur quoi sont basés les protocoles de sécurité <a
href="https://en.wikipedia.org/wiki/Transport_Layer_Security">SSL/TLS</a>
largement utilisés sur Internet et qui ont permis la création du
protocole <a href="https://en.wikipedia.org/wiki/HTTPS">HTTPS</a>.
Malheureusement, des organisations gouvernementales (oui encore la NSA),
peuvent faire pression sur certaines autorités de certifications afin
d'utiliser l'attaque de l'homme du milieu, et l'une des seules solutions
à ce problème est d'utiliser un <strong>service décentralisé</strong>
(là où les autorités doivent certifier une autre autorité, notre système
décentralisé demande que les deux autorités se <strong>certifient
mutuellement</strong>). Le fait que le système soit décentralisé rend
bien plus compliqué les attaques de ce genre, car chaque autorité peut
classer une autre comme étant totalement de confiance, peu de confiance
ou encore frauduleuse. Plus le niveau de classification de la confiance
est bas, plus l'autorité doit avoir de retours positifs de la part
d'autres autorités de confiance afin de valider la transmission des
clés. Si une autorité de certification est corrompue, les autres ne lui
feront plus confiance et vu qu'une confiance mutuelle est nécessaire,
cette autorité sera mise de côté voir plus du tout utilisée. On a donc
un réseau totalement décentralisé permettant plus de sécurité, et
évitant un système de pression de la part d'organisations ayant beaucoup
d'influence.</p>
<h3 id="attaque-dhåstad">Attaque d'Håstad</h3>
<p>À la création du système RSA, les ordinateurs étaient loin d'être
aussi rapides qu'aujourd'hui et ce problème d'efficacité était
réellement compromettant. Pour permettre un algorithme plus rapide, on
utilisait souvent des valeurs de <span class="math inline">\(e\)</span>
petites (3, 7, 17, etc.) afin d'améliorer le temps nécessaire à
l'algorithme pour générer des paires de clés et de chiffrer le message.
Cependant, Johan Håstad démontra en 1985, que si on envoyait un
<strong>même message</strong> à au moins <span
class="math inline">\(e\)</span> personnes avec le <strong>même
exposant</strong>, alors on pouvait déchiffrer le texte facilement. Vu
qu'en général on utilisait des exposants comme <span
class="math inline">\(e = 3\)</span>, il suffisait alors d'intercepter 3
mêmes messages qu'une personne a envoyé à différents destinataires, pour
en trouver le contenu déchiffré. Pour effectuer cette attaque, le
mathématicien a utilisé le <a
href="https://en.wikipedia.org/wiki/Chinese_remainder_theorem">théorème
des restes chinois</a> :</p>
<p>Imaginons, qu'Alice envoie à au moins 3 personnes un même message
chiffré, avec le même exposant <span class="math inline">\(e =
3\)</span>. Soit les trois messages chiffrés <span
class="math inline">\(c_1\)</span>, <span
class="math inline">\(c_2\)</span>, <span
class="math inline">\(c_3\)</span>, leurs modules de chiffrement
respectifs <span class="math inline">\(n_1\)</span>, <span
class="math inline">\(n_2\)</span>, <span
class="math inline">\(n_3\)</span>, et le message déchiffré <span
class="math inline">\(d\)</span>. On a démontré que <span
class="math inline">\(f&#39;(f(d)) = d \mod n\)</span>, ce qui signifie
que déchiffrer un message chiffré revient à exprimer <span
class="math inline">\(d \mod n\)</span>. On a donc <span
class="math inline">\(c_i \equiv d^3 \mod n_i\)</span> avec <span
class="math inline">\(i\)</span> allant de 1 à 3. Grâce au théorème des
restes chinois, on peut trouver un nombre <span
class="math inline">\(c\)</span> tel que <span class="math inline">\(c_i
\equiv c \mod n\)</span>, ce qui nous donne <span
class="math inline">\(c \equiv d^3 \mod{n_1 n_2 n_3}\)</span>. Or par
définition, <span class="math inline">\(d &lt; n_i\)</span>, et donc
<span class="math inline">\(d^3 &lt; n_1 n_2 n_3\)</span>. Alors on peut
écrire <span class="math inline">\(c = d^3\)</span>, et calculer <span
class="math inline">\(d\)</span> facilement <span
class="math inline">\(d = \sqrt[3]{c}\)</span>. On peut généraliser
cette attaque en remplaçant 3 par <span
class="math inline">\(e\)</span>, mais plus <span
class="math inline">\(e\)</span> est grand plus l'attaque est difficile
à mettre en place.</p>
<p>Cette attaque sera ensuite reprise par plusieurs autres
mathématiciens pour créer différentes variantes et améliorations : <a
href="https://en.wikipedia.org/wiki/Coppersmith&#39;s_Attack#Franklin-Reiter_Related_Message_Attack">Franklin-Reiter</a>,
<a
href="https://en.wikipedia.org/wiki/Coppersmith&#39;s_Attack#Coppersmith.E2.80.99s_Short_Pad_Attack">Coppersmith</a>.</p>
<p>Ceci nous montre bien que dans ce cas, à défaut de vouloir utiliser
l'algorithme plus rapidement, on perd énormément en sécurité, il faut
donc faire attention lors d'amélioration de ce type à ne pas affaiblir
le système de chiffrement. Un petit exposant <span
class="math inline">\(e\)</span> facilite donc cette attaque, car plus
il est petit plus le nombre de messages à récupérer est faible, et plus
le temps nécessaire à trouver le message déchiffré est court. Pour se
protéger face à cette attaque, il suffit d'utiliser un exposant <span
class="math inline">\(e\)</span> assez important.</p>
<h3 id="attaque-de-wiener">Attaque de Wiener</h3>
<p>Dans le même style qu'attaquer des messages avec des <span
class="math inline">\(e\)</span> petits, en 1990 Michael Wiener a trouvé
une attaque similaire mais sur des petits <span
class="math inline">\(d\)</span>. Il démontra que si <span
class="math inline">\(d &lt; \frac{1}{3}n^{\frac{1}{4}}\)</span>, on
peut retrouver <span class="math inline">\(d\)</span>, grâce à
l'algorithme des <a
href="https://en.wikipedia.org/wiki/Continued_fraction">fractions
continues</a>.</p>
<p>On part de l'équivalence suivante :</p>
<p><span class="math inline">\(ed \equiv 1 \mod m\)</span></p>
<p>Par définition <span class="math inline">\(m = (p - 1) \times (q -
1)\)</span>, et <span class="math inline">\(ppcm(a, b) = \frac{| ab
|}{pgcd(a, b)}\)</span> (plus d'infos sur le <a
href="https://en.wikipedia.org/wiki/Least_common_multiple">ppcm</a>), or
<span class="math inline">\(p\)</span> et <span
class="math inline">\(q\)</span> sont premiers entre eux, donc <span
class="math inline">\(pgcd(p, q) = 1\)</span>, et on peut alors écrire
:</p>
<p><span class="math inline">\(ed \equiv 1 \mod ppcm(p - 1, q -
1)\)</span></p>
<p>Cela signifie qu'il existe un nombre entier <span
class="math inline">\(K\)</span>, tel que :</p>
<p><span class="math inline">\(ed = K \times ppcm(p - 1, q - 1) +
1\)</span></p>
<p>Soit <span class="math inline">\(G = pgcd(p - 1, q - 1)\)</span>,
<span class="math inline">\(k = \frac{K}{pgcd(K, G)}\)</span> et <span
class="math inline">\(g = \frac{G}{pgcd(K, G)}\)</span>, on a la
relation suivante :</p>
<p><span class="math inline">\(ed = \frac{k}{g}(p - 1)(q - 1) +
1\)</span></p>
<p>Que l'on peut arranger en divisant le tout par <span
class="math inline">\(dpq\)</span> :</p>
<p><span class="math inline">\(\frac{e}{pq} = \frac{k}{dg}(1 -
\delta)\)</span> avec <span class="math inline">\(\delta = \frac{p + q -
1 - \frac{g}{k}}{pq}\)</span></p>
<p>À partir de là, si on arrive à déterminer <span
class="math inline">\(\frac{k}{dg}\)</span> grâce à l'algorithme des
fractions continues, on peut trouver <span
class="math inline">\(k\)</span> mais surtout <span
class="math inline">\(dg\)</span> qui nous permet de casser le système
RSA.</p>
<p>Un article spécialement sur l'attaque de Wiener (et en français),
montre comment utiliser l'algorithme des fractions continues : <a
href="http://www.jannaud.fr/static/download/Travail/rapportwiener.pdf">Attaque
de clés RSA par la méthode de Wiener</a>.</p>
<h3 id="module-de-chiffrement-commun">Module de chiffrement commun</h3>
<p>Créer un module de chiffrement à chaque génération de paires de clés
peut être une opération lourde, et certaines personnes utilisaient un
même <span class="math inline">\(n\)</span> pour toutes les paires (avec
bien entendu des <span class="math inline">\(e\)</span> et <span
class="math inline">\(d\)</span> différents). À première vue, il n'y a
pas de raison que ça ne fonctionne pas, cependant il a été démontré
qu'une personne possédant une paire de clé de ce genre, peut factoriser
assez facilement <span class="math inline">\(n\)</span> avec son propre
<span class="math inline">\(e\)</span> et <span
class="math inline">\(d\)</span> et ainsi déduire les clés privées des
autres personnes du système.</p>
<figure>
<img src="/img/algo/chiffrement/rsa/demonstration_facto_n.png"
alt="/img/algo/chiffrement/rsa/demonstration_facto_n.png" />
<figcaption>Démonstration de cette propriété</figcaption>
</figure>
<p>La démonstration vient de <em>Twenty Years of Attacks on the RSA
Cryptosystem</em> de Dan Boneh, que vous pouvez retrouver en pdf sur
Internet.</p>
<p>Et voici un exemple concret de l'utilisation de cette propriété pour
factoriser <span class="math inline">\(n\)</span> : <a
href="http://www.di-mgt.com.au/rsa_factorize_n.html">How to factorize N
given d</a>.</p>
<h3 id="attaque-sur-les-implémentations">Attaque sur les
implémentations</h3>
<p>En pratique, il est difficile de toujours faire une implémentation
parfaite d'un système de chiffrement, et des études/audits révèlent
régulièrement des failles dans certains systèmes de sécurité. Il est
donc possible de se focaliser sur des attaques d'implémentations au lieu
d'essayer de casser un système de chiffrement théorique.</p>
<h4 id="attaque-par-chronométrage">Attaque par chronométrage</h4>
<p>L'idée consiste à étudier le temps nécessaire à l'ordinateur,
stockant la clé privée, de déchiffrer (ou de signer) plusieurs messages.
Cette attaque se base sur le fait que la plupart des implémentations
utilisent un même algorithme (ou alors un algorithme connu) afin
d'effectuer le déchiffrement, et on peut donc en déduire le nombre
d'opérations effectuées et ainsi petit à petit récupérer des
informations sur <span class="math inline">\(d\)</span>. Par exemple, il
est courant d'utiliser l'exponentiation modulaire pour implémenter notre
fonction de déchiffrement, comme nous avons vu précédemment, cependant
une amélioration de cette dernière se base sur la représentation binaire
de la clé (et donc de <span class="math inline">\(d\)</span>), ce qui
nous permet après plusieurs opérations de déchiffrement de faire des
analyses statistiques sur les informations recueillies pour déterminer
<span class="math inline">\(d\)</span>. Or, en général, une amélioration
en temps est souvent cruciale en cryptographie, ceci est donc largement
utilisé.</p>
<p>Tout d'abord, regardons l'amélioration de l'exponentiation modulaire
:</p>
<p>Soit <span class="math inline">\(d\)</span> notre exposant dans
l'expression <span class="math inline">\(f&#39;(x) = x^d \mod n\)</span>
avec <span class="math inline">\(x\)</span> notre message chiffré. On
peut écrire <span class="math inline">\(d\)</span>, sous forme de
représentation binaire :</p>
<p><span class="math inline">\(d = \displaystyle\sum_{i=0}^{b-1}
a_i2^i\)</span> avec <span class="math inline">\(a\)</span> représentant
un bit (soit 0 soit 1), et <span class="math inline">\(b\)</span> le
nombre de bit pour représenter <span
class="math inline">\(d\)</span>.</p>
<p>On a donc <span class="math inline">\(x^d\)</span> qu'on représente
ainsi :</p>
<p><span class="math inline">\(x^d = \displaystyle\prod_{i=0}^{b-1}
(x^{2^i})^{a_i}\)</span></p>
<p>Cette représentation binaire permet de faire des opérations
extrêmement rapides dans la plupart des langages de programmation grâce
aux <strong>opérateurs bit à bit</strong>, en C par exemple on a les
opérateurs <code>&gt;&gt;</code> et <code>&lt;&lt;</code> pour effectuer
des décalages (ou <em>shift</em> en anglais) sur des nombres binaires
(ceci offre notamment un gain énorme de temps sur des opérations comme
les puissances).</p>
<p>L'attaque par chronométrage consistera dans notre cas, à observer le
temps que met l'ordinateur pour déchiffrer un certain message afin de
trouver petit à petit chaque bit de <span
class="math inline">\(d\)</span>. Tout d'abord, <span
class="math inline">\(d\)</span> par définition est forcément impair, on
conclut donc que le bit 0 de <span class="math inline">\(d\)</span> sera
<span class="math inline">\(d_0 = 1\)</span> (plus d'infos : <a
href="https://en.wikipedia.org/wiki/Least_significant_bit">bit de poids
faible</a>). Pour trouver les autres bits, on va émettre des hypothèses
sur la valeur de <span class="math inline">\(a_i\)</span>, qui peut être
soit 1, soit 0 (<span class="math inline">\(a_i\)</span> n'est autre que
le bit <span class="math inline">\(i\)</span> de <span
class="math inline">\(d\)</span>). S'il est égal à 0, le résultat de
<span class="math inline">\((b^{2^i})^{a_i}\)</span> sera forcément 1,
et l'opération sera alors bien plus rapide et différente en termes de
temps qu'avec <span class="math inline">\(a_i = 1\)</span>, ce qui nous
donne des informations sur des bits de <span
class="math inline">\(d\)</span>. Il est possible d'utiliser ce principe
afin de découvrir <span class="math inline">\(d\)</span> en entier,
simplement en demandant à l'ordinateur de déchiffrer des messages bien
spécifiques.</p>
<p>Cette attaque ne s'applique pas uniquement à RSA, et peut être un
aspect important de la sécurité d'une implémentation. Pour s'en
protéger, on peut par exemple effectuer des délais dans le programme
afin d'avoir un temps fixe pour chaque opération nécessaire, ou encore
utiliser une technique d'<a
href="https://en.wikipedia.org/wiki/Blinding_%28cryptography%29">aveuglement</a>.
Pour cette technique, avant de déchiffrer le message <span
class="math inline">\(x\)</span>, l'ordinateur va prendre au hasard un
nombre entier <span class="math inline">\(r\)</span> et calculer <span
class="math inline">\(x&#39; = x \times r^e \mod n\)</span>, puis faire
<span class="math inline">\(y&#39; = x&#39;^d \mod n\)</span>, et enfin
<span class="math inline">\(y = \frac{y&#39;}{r} \mod n\)</span>. Ces
opérations sont en réalité un simple chiffrement/déchiffrement, mais en
utilisant une variable intermédiaire <span
class="math inline">\(r\)</span> qui rend alors impossible l'attaque par
chronométrage car <span class="math inline">\(r\)</span> est choisi
aléatoirement par l'ordinateur.</p>
<p>Sachez qu'il y a des attaques dans la même idée, mais se basant cette
fois sur la consommation électrique de l'ordinateur qui peut varier en
fonction des opérations effectuées lors du déchiffrement.</p>
<h4 id="exemples-de-failles-dans-des-implémentations">Exemples de
failles dans des implémentations</h4>
<p>La dernière attaque traite un type d'exploitation de manière assez
large car cela ne s'applique pas uniquement pour RSA. Mais de manière
bien plus général, on trouve dans tous types de codes sources, et dans
tous les domaines, des failles permettant de réaliser des attaques
dessus. La cryptographie est loin d'être une exception et il y a
énormément d'exemples d'attaques faites sur des systèmes après avoir
trouvé des failles de sécurité importantes :</p>
<ul>
<li><p><a href="https://en.wikipedia.org/wiki/Heartbleed">Heartbleed</a>
: en 2014, une découverte majeure dans la bibliothèque <a
href="https://www.openssl.org/">OpenSSL</a> permettait de récupérer des
informations secrètes à cause d'une erreur d'implémentation. La raison
de cette attaque est que la librairie utilise une option appelée
<em>heartbeat</em> qui permet de s'assurer que le client et le serveur
sont toujours connectés, et elle fonctionne très simplement : le client
envoie une requête au serveur avec une chaîne de caractères aléatoire,
le serveur récupère la requête et renvoie la chaîne afin de montrer
qu'il est toujours présent. Le problème était que la partie du code
s'occupant de cette option ne vérifiait pas la taille indiquée dans la
requête au sujet de la chaîne, c'est-à-dire que je pouvais envoyer cette
chaîne au serveur "jIO91mq0x/" et dire qu'elle fait 42 caractères, le
serveur va alors me renvoyer les 42 derniers caractères qu'il a en
mémoire (dont la chaîne que je lui ai envoyée), ce qui peut rendre
public des données sensibles comme des clés privées de
chiffrement.</p></li>
<li><p>En début d'année 2016, une faille critique dans <a
href="http://www.openssh.com/">OpenSSH</a> donnait accès aux clés
privées SSH d'un utilisateur et donc détruisait toutes sécurités du
système de chiffrement. Une option datant de 2010 (qui n'était même pas
documentée) était activée par défaut sur un client OpenSSH et permettait
de se reconnecter automatiquement à un serveur en cas de déconnexion
soudaine. Cette option expérimentale présentait deux failles dont une
permettait de récupérer les clés privées SSH d'un utilisateur : <a
href="https://www.qualys.com/2016/01/14/cve-2016-0777-cve-2016-0778/openssh-cve-2016-0777-cve-2016-0778.txt">Exemple
concret d'exploitation de cette faille</a></p></li>
<li><p>En 2015, une faille énorme dans le code des protocoles SSL/TLS
d'Apple est découverte avec notamment ce fameux code qui a beaucoup
circulé à ce propos :</p>
<pre><code>if ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;signedParams)) != 0)
   goto fail;
   goto fail;</code></pre>
<p>Où la ligne <code>goto fail;</code> est répétée deux fois ce qui
signifie qu'importe le résultat du test précédent, la fonction ira de
toute façon au label <code>fail</code> sautant alors tous les tests de
sécurité qui sont situés après. Ceci permettait à une personne
malveillante d'utiliser un certificat qui semblait être correct, mais
qui en réalité n'avait pas une bonne clé privée associée, afin d'avoir
une connexion sécurisée https qui paraissait authentique pour
l'utilisateur alors que ce n'était pas le cas.</p></li>
<li><p>Une recherche récente a été rendue public fin 2015 lors de la
conférence 32 du <a
href="https://en.wikipedia.org/wiki/Chaos_Computer_Club">Chaos Computer
Club</a> dans laquelle Alex Halderman et Nadia Heninger exposent une
attaque consistant à forcer le serveur à utiliser d'anciens protocoles
moins sécurisés que ceux de nos jours. La vidéo de la conférence (la
partie concernant l'attaque commence à 18min13) : <a
href="https://www.youtube.com/watch?v=mS8gm-_rJgM">Logjam:
Diffie-Hellman, discrete logs, the NSA, and you [32c3]</a></p></li>
</ul>
<p>Même si peu après la découverte de ces failles, un patch a été
rapidement proposé, certaines exploitations sont présentes et possibles
depuis plusieurs années dans des systèmes et nécessitent bien plus de
mises à jour de la part des utilisateurs. De nos jours, c'est une
pratique régulière d'organiser des concours où le but est de découvrir
le plus de failles et exploitations possibles dans une implémentation en
échange d'argent pour la découverte. Cela permet de maintenir des
systèmes importants en termes de sécurité, afin d'éviter toutes failles
critiques dans l'implémentation.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Le système de chiffrement RSA est donc l'un des premiers algorithmes
asymétriques garantissant une sécurité lors du chiffrement, mais surtout
dans la transmission de la clé, en mettant en place des paires de clés
publiques et privées. Sa sécurité est basée sur le fait qu'il est long
et difficile de factoriser un nombre premier, et l'algorithme utilise
plusieurs fonctions à sens unique afin de garantir la sécurité du
message. Cependant s'il est mal utilisé ou que la sécurité est négligée
(pour gagner du temps par exemple), quelques exploitations sont
envisageables et même si aucunes n'est d'une importance majeure, elles
ne sont pas à sous-estimer. De plus les implémentations d'un tel système
sont parfois complexes à mettre en place, et ont bien plus de chance
d'être vulnérable à des attaques que l'algorithme en lui-même. On
découvre chaque année de nombreuses failles dans des systèmes utilisés
mondialement, mais bien plus rarement des attaques cassant complètement
un algorithme de chiffrement largement employé.</p>
<p>Aujourd'hui, les algorithmes de chiffrement asymétriques ne sont pas
forcément le type d'algorithme le plus utilisé car chiffrer/déchiffrer
un long message peut être très lent à cause des fonctions utilisées. En
revanche, on utilisera plutôt un mélange entre les algorithmes
symétriques et asymétriques afin de garder les avantages des deux types
de chiffrement (<strong>opérations rapides</strong> de
chiffrement/déchiffrement pour un algorithme symétrique, et
<strong>transmission sécurisée</strong> de la clé pour un algorithme
asymétrique). On appelle ce principe, la <strong>cryptographie
hybride</strong>, et l'un des premiers systèmes de ce genre fut l'<a
href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">échange
de clés Diffie-Hellman</a> imaginé par Diffie et Hellman, qui sont à
l'origine de l'utilisation d'algorithme de chiffrement asymétrique.
Actuellement, la base d'un système de cryptographie hybride est souvent
l'algorithme symétrique <a
href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a>
qui est très courant et fiable. Le gouvernement américain l'utilise
comme standard et même jusqu'à des niveaux de classification top
secrets, notamment grâce à sa rapidité et à sa robustesse (aucunes
réelles attaques ne sont connues pour le moment sur ce système de
chiffrement). L'algorithme RSA ne sera donc que rarement utilisé
entièrement, mais plutôt partiellement grâce à la cryptographie hybride,
utilisée par exemple dans <a href="http://openpgp.org/">OpenPGP</a> ou
encore <a href="https://gnupg.org/">GnuPG</a>.</p>
<p>Cependant, une nouvelle ère dans le domaine de la cryptographie
arrive : la <a
href="https://en.wikipedia.org/wiki/Quantum_cryptography">cryptographie
quantique</a>. Cette dernière permettrait une transmission de la clé de
manière totalement sécurisée et assurerait une protection garantie
contre toutes techniques de cassage reposant sur des phénomènes
physiques classiques (c'est-à-dire tous les phénomènes non quantiques).
Un excellent talk à ce propos lors de la 32c3 :</p>
<p><a href="http://www.youtube.com/watch?v=Lh8OGDNJZQk">Quantum
Cryptography [32c3]</a></p>
<p>Mais avec cette nouvelle technologie, se développe aussi les <a
href="https://en.wikipedia.org/wiki/Quantum_computing">ordinateurs
quantiques</a>, basés sur les lois de la <a
href="https://en.wikipedia.org/wiki/Quantum_mechanics">physique
quantique</a> et qui pourrait permettre théoriquement de casser
n'importe quel système cryptographique moderne en très peu de temps. En
effet, nos ordinateurs utilisent des phénomènes physiques dit
classiques, possédant un seul <em>état physique</em> à la fois (0 ou 1
dans le cas des bits), mais les ordinateurs quantiques sont capables de
prendre plusieurs états différents <strong>en même temps</strong>, grâce
aux propriétés de la <a
href="https://en.wikipedia.org/wiki/Quantum_superposition">superposition</a>
ou encore de l'<a
href="https://en.wikipedia.org/wiki/Quantum_entanglement">intrication</a>.
Ceci permettrait notamment de faire un nombre d'opérations considérables
en une fraction de seconde car au lieu de les faire une par une, on
pourrait théoriquement toutes les faire en même temps. Cette idée est
loin d'être nouvelle, et en 1994, Peter Shor présenta l'<a
href="https://en.wikipedia.org/wiki/Shor&#39;s_algorithm">algorithme de
Shor</a> qui permet de factoriser un nombre entier en un temps
polynomial sur un ordinateur quantique. Pour le moment, nous sommes
encore <strong>loin</strong> d'utiliser l'algorithme de Shor sur un
ordinateur quantique pour casser des clés de chiffrement modernes, et
même encore loin d'avoir un ordinateur quantique fiable et assez stable.
Mais il faut savoir que cette technologie se développe rapidement, on
entend beaucoup parler du fameux ordinateur quantique de <a
href="https://en.wikipedia.org/wiki/D-Wave_Systems">D-Wave</a>, et même
si certains tests de rapidité sont assez <a
href="http://news.mit.edu/2015/3q-scott-aaronson-google-quantum-computing-paper-1211">controversés</a>,
ce domaine reste extrêmement intéressant et plein de potentiel pour de
futures applications. Les ordinateurs quantiques nous permettraient de
résoudre une quantité énorme de problèmes dont la solution nécessite
trop de temps pour de simples ordinateurs non quantiques. Mais dans le
domaine de la cryptographie, ce genre de technologie pose problème en
termes de sécurité car nos systèmes de chiffrement actuels reposent sur
des problèmes mathématiques que l'on ne sait pas résoudre rapidement
avec des ordinateurs normaux (factorisation, <a
href="https://en.wikipedia.org/wiki/Discrete_logarithm">logarithme
discret</a>, <a
href="https://en.wikipedia.org/wiki/Elliptic_curve_cryptography">courbes
elliptiques</a>), et des chercheurs commencent donc déjà à chercher des
algorithmes capables de résister à des attaques faites sur un ordinateur
quantique pour se préparer au mieux à l'arrivée de ce genre d'ordinateur
et à la cryptographie <strong>post-quantique</strong>.</p>



        <footer>
        </footer>
    </body>
</html>