<!DOCTYPE html>
<html>
   <head>
      <meta charset="utf-8">

      <!-- CSS -->
      <link rel="stylesheet" type="text/css" href="/css/default.css">
      <link rel="stylesheet" type="text/css" href="/css/highlight_theme.css">

      <!-- Icon -->
      <link rel="icon" type="image/x-icon" href="/img/favicon.ico">

      <!-- Syntax highlighting -->
      <script src="/js/highlight.pack.js"></script>
      <script>hljs.initHighlightingOnLoad();</script>

      <!-- Renders LaTeX expression -->
      <script type="text/x-mathjax-config">
         MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
      </script>
      <script type="text/javascript" async 
              src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML">
      </script>

      <!-- Font Awesome -->
      <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

      <title>Tri par tas - napnac</title>
   </head>

   <body>
      <!-- Javascript -->
      <script type="text/javascript" src="/js/utils.js"></script>

      <div id="sidebar">
         <a href="/"><img src="/img/logo.png" alt="Logo du site" height="125" width="125"></a>

         <div id="menu">
            <ul>
               <li><a href="/">Accueil</a></li>
               <li><a href="/articles.html">Articles</a></li>
               <li><a href="/projets.html">Projets</a></li>
               <li><a href="/a_propos.html">A propos</a></li>
            </ul>
         </div>

         <div id="info">
            <ul>
               <li><a href="https://twitter.com/napnac"><i class="fa fa-twitter fa-fw" aria-hidden="true"></i>Twitter</a></li>
               <li><a href="https://github.com/napnac"><i class="fa fa-github fa-fw" aria-hidden="true"></i>Github</a></li>
               <li><i class="fa fa-envelope fa-fw" aria-hidden="true"></i>napnac [at] domaine</li>
               <li><i class="fa fa-rss fa-fw" aria-hidden="true"></i><a href="https://napnac.fr/feed/rss.xml">RSS</a> / <a href="https://napnac.fr/feed/atom.xml">Atom</a></li>
            </ul>
         </div>

   <hr>
   <p>Publié le : 14/05/2014<br>Modifié le : 29/04/2016</p>

      <h4>Table des matières</h4>
      <div class="toc">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#principe-de-lalgorithme">Principe de l’algorithme</a></li>
<li><a href="#exemple">Exemple</a></li>
<li><a href="#pseudo-code">Pseudo-code</a></li>
<li><a href="#complexite">Complexité</a></li>
<li><a href="#implementation">Implémentation</a></li>
<li><a href="#ameliorations-et-variantes">Améliorations et variantes</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
</div>

      </div>

      <div id="content">
         <h1><a href="">Tri par tas</a></h1>

         <h2 id="introduction"><a class="toclink" href="#introduction">Introduction</a></h2>
<p>Le tri par tas (<em>heapsort</em> en anglais) est un algorithme de tri par comparaison, plutôt efficace et qui a une complexité en $O(N \log _2 N)$. C’est un algorithme de tri <a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability">non stable</a> mais <a href="https://en.wikipedia.org/wiki/In-place_algorithm">en place</a>.</p>
<h2 id="principe-de-lalgorithme"><a class="toclink" href="#principe-de-lalgorithme">Principe de l’algorithme</a></h2>
<p>L'algorithme du tri par tas repose sur un élément fondamental : le <a href="/algo/structure/arbre/tas.html">tas</a> (d'où son nom). En effet, ce tri crée un tas max du tableau donné en entrée, et le parcourt afin de reconstituer les valeurs triées dans notre tableau.</p>
<h2 id="exemple"><a class="toclink" href="#exemple">Exemple</a></h2>
<p>On prend la suite de nombres suivante que l’on va trier dans l’ordre croissant avec le tri par tas : 1, 9, 3, 7, 6, 1, 4.</p>
<p><em>1ère étape</em> : créer le tas (max dans notre cas)</p>
<figure><img alt="Tas max correspondant au tableau" src="/img/algo/tri/tri_tas/exemple_tas_max.png" /><figcaption>Tas max correspondant au tableau</figcaption>
</figure>
<p><em>2ème étape</em> : parcourir le tas pour trier les éléments</p>
<p>Pour trier les éléments grâce à notre tas, on retire la racine à chaque tour (l'élément le plus grand de notre tas, et donc de notre tableau), on le range à sa place définitive, et on entasse le dernier élément du tas pour combler le trou de la racine mais aussi respecter les règles d'un tas.</p>
<figure><img alt="1er tour" src="/img/algo/tri/tri_tas/exemple_tour1.png" /><figcaption>1er tour</figcaption>
</figure>
<p>La racine du tas (en vert) est placée dans le tableau <em>(1)</em> et le dernier élément (en bleu) va remplacer la racine <em>(2)</em>, mais il ne faut pas oublier de l'entasser pour respecter les règles du tas max <em>(3)</em>.</p>
<p>On continue ces opérations tant que le tas contient des éléments :</p>
<figure><img alt="Exemple de tri par tas" src="/img/algo/tri/tri_tas/exemple_tour2.png" /><figcaption>Exemple de tri par tas</figcaption>
</figure>
<h2 id="pseudo-code"><a class="toclink" href="#pseudo-code">Pseudo-code</a></h2>
<p>Voici le pseudo-code du tri par tas :</p>
<pre><code class="nohighlight">triTas :

   Contruire le tas max du tableau

   Pour chaque élément du tableau (en partant de la fin)
      Placer la racine du tas dans le tableau
      Entasser le dernier élément du tas à la place de la racine
</code></pre>

<h2 id="complexite"><a class="toclink" href="#complexite">Complexité</a></h2>
<p>La complexité de l’algorithme du tri par tas est en $O(N \log _2 N)$. En effet, la boucle principale parcourt $N$ tours ($N$ étant la taille du tableau), et appelle à chaque tour une fonction pour entasser qui a une complexité logarithmique.</p>
<p><em>Si vous n’avez pas lu mon article sur le <a href="/algo/tri/tri_rapide.html">tri rapide</a>, je vous conseille au moins de lire la partie <a href="/algo/tri/tri_rapide.html#complexite">complexité</a> dans laquelle j’explique pourquoi le tri rapide peut être jusqu’à deux fois plus efficace que le tri par tas.</em></p>
<h2 id="implementation"><a class="toclink" href="#implementation">Implémentation</a></h2>
<p>Une implémentation en C++ (afin d'avoir le type <code>priority_queue</code>) du tri par tas :</p>
<a href="javascript:toggle_visibility('tri_tas.cpp');">tri_tas.cpp <i id="toggle_arrow_tri_tas.cpp" class="fa fa-angle-down" aria-hidden="true"></i></a>
<div id="tri_tas.cpp" style="display: none;">
<pre><code class="cpp">#include &lt;cstdio&gt;
#include &lt;queue&gt;
using namespace std;

const int TAILLE_MAX = 1000;

int tableau[TAILLE_MAX];
int taille;

priority_queue &lt;int&gt; tas;

void construireTasMax(void)
{
   int iTab;
   for(iTab = 0; iTab &lt; taille; ++iTab)
      tas.push(tableau[iTab]);
}

void triTas(void)
{
   int iTab;

   construireTasMax();

   for(iTab = taille - 1; iTab != 0; --iTab) {
      tableau[iTab] = tas.top();
      tas.pop();
   }
}

int main(void)
{
   int iTab;

   scanf(&quot;%d\n&quot;, &amp;taille);

   for(iTab = 0; iTab &lt; taille; ++iTab)
      scanf(&quot;%d &quot;, &amp;tableau[iTab]);

   triTas();

   for(iTab = 0; iTab &lt; taille; ++iTab)
      printf(&quot;%d &quot;, tableau[iTab]);
   printf(&quot;\n&quot;);

   return 0;
}
</code></pre>

<p>On utilise la <a href="http://www.cplusplus.com/reference/queue/priority_queue/"><code>priority_queue</code></a> de la STL afin d'avoir un tas max facilement dans notre implémentation.</p>
</div>
<p>Notre tableau d'entrée :</p>
<pre><code class="nohighlight">7
1 9 3 7 6 1 4
</code></pre>

<p>La sortie du programme :</p>
<pre><code class="nohighlight">1 1 3 4 6 7 9
</code></pre>

<h2 id="ameliorations-et-variantes"><a class="toclink" href="#ameliorations-et-variantes">Améliorations et variantes</a></h2>
<h3>Optimisation de la mémoire</h3>
<p>On peut économiser de la mémoire en évitant de créer un tas à part entière du tableau. En effet, on peut tout simplement réorganiser notre tableau afin de le parcourir comme un tas max, et ensuite il suffit de recréer les fonctions du tas à la main (<code>construireTasMax</code>, <code>entasser</code>, etc.) pour faire nos opérations dessus. Le tas aura une taille virtuelle qui occupe initialement toute la place du tableau, mais diminue progressivement au fur et à mesure que les racines du tas sont fixées à leurs places définitives dans le tableau trié.</p>
<pre><code class="nohighlight">triTas :

   Contruire le tas max dans le tableau

   Pour chaque élément du tableau (en partant de la fin)
      Echanger l'élément actuel avec la racine
      Décrémenter la taille du tas
      Entasser l'élément placé à la racine
</code></pre>

<p>On parcourt le tableau à l'envers afin d'échanger la racine actuelle avec l'élément occupant sa place définitive.</p>
<h3>Mélange d'algorithme</h3>
<p>Comme pour le tri rapide, le tri par tas peut être mélangé avec un autre algorithme de tri lorsque le tableau possède peu d’éléments afin de le rendre plus efficace. Pour en savoir plus à ce sujet, je vous invite à lire la partie <a href="/algo/tri/tri_rapide.html#melange-dalgorithme">mélange d'algorithme</a> de mon article sur le tri rapide.</p>
<h3>Smoothsort</h3>
<p>Le <em>smoothsort</em> est une variante du tri par tas permettant d'améliorer la complexité en temps dans le meilleur des cas en $O(N)$ (lorsque les nombres en entrée sont déjà triés ou quasi triés par exemple). Ce tri est assez complexe, et même s'il a une meilleure approche d'un point de vue théorique, il sera peu utilisé en pratique, tout comme le tri par tas comparé au tri rapide.</p>
<p>Le principe du smoothsort est de baser le tri non plus sur un seul tas, mais sur plusieurs de différentes tailles. Cette nouvelle structure de données est un <strong>tas de Léonard</strong>, car elle s'appuie sur la <a href="https://en.wikipedia.org/wiki/Leonardo_number">suite de Léonard</a>.</p>
<figure><img alt="Exemple de tas de Léonard (en bleu les racines des sous-arbres)" src="/img/algo/tri/tri_tas/exemple_tas_leonard.png" /><figcaption>Exemple de tas de Léonard (en bleu les racines des sous-arbres)</figcaption>
</figure>
<p>Cet ensemble a des propriétés spécifiques (sur la taille des sous-arbres, l'ordre d'apparition des racines, etc.), rendant les opérations d'insertion et de suppression assez longues à décrire et à expliquer. Il faudrait un article à part entier pour évoquer ce curieux algorithme de tri, et si ce dernier vous intéresse je vous recommande fortement cette page qui traite en profondeur du sujet : <a href="http://www.keithschwarz.com/smoothsort/">Smoothsort Demystified</a>.</p>
<h2 id="conclusion"><a class="toclink" href="#conclusion">Conclusion</a></h2>
<p>Le tri par tas est donc un algorithme de tri efficace en $O(N \log _2 N)$ non stable mais en place. En pratique, cet algorithme est moins utilisé que le tri rapide, même si en théorie il a une meilleure complexité dans le pire des cas ainsi qu'une amélioration intéressante : le <em>smoothsort</em>. Il sert en revanche à l'amélioration du tri rapide, dans sa variante l'<a href="/algo/tri/tri_rapide.html#introsort">introsort</a> et reste donc un algorithme de tri essentiel à connaître.</p>

         <footer>
            <br>
            <hr>
            <p>Une question ? Une suggestion ? N'hésitez pas à me <a href="/a_propos.html">contacter</a> pour me communiquer vos remarques.</p>
            <br>
         </footer>
      </div>
   </body>
</html>