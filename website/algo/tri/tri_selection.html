<!DOCTYPE html>
<html>
   <head>
      <meta charset="utf-8">

      <!-- CSS -->
      <link rel="stylesheet" type="text/css" href="/css/default.css">
      <link rel="stylesheet" type="text/css" href="/css/highlight_theme.css">

      <!-- Icon -->
      <link rel="icon" type="image/x-icon" href="/img/favicon.ico">

      <!-- Syntax highlighting -->
      <script src="/js/highlight.pack.js"></script>
      <script>hljs.initHighlightingOnLoad();</script>

      <!-- Renders LaTeX expression -->
      <script type="text/x-mathjax-config">
         MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
      </script>
      <script type="text/javascript" async 
              src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">
      </script>

      <title>Tri par sélection - napnac</title>
   </head>

   <body>
      <header>
         <a href="/">
            <img src="/img/logo.png" alt="Logo du site" height="100" width="300">
         </a>
      </header>

      <nav>
         <ul id="main_menu">
            <li><a href="/">Accueil</a></li>
            <li><a href="/articles.html">Articles</a></li>
            <li><a href="/projets.html">Projets</a></li>
            <li><a href="/a_propos.html">A propos</a></li>
         </ul>
      </nav>

      

<h1>Tri par sélection</h1>

<p>Publié le : 30/04/2014</p>
<p>Modifié le : 08/12/2015</p>

<h2>Introduction</h2>
<p>Le tri par sélection (<em>selection sort</em> en anglais) est un algorithme de tri par comparaison simple, mais assez inefficace sur une entrée trop importante, c’est un algorithme non <a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability">stable</a> mais qui trie <a href="https://en.wikipedia.org/wiki/In-place_algorithm">en place</a>. Il a pour complexité algorithmique $O(N^2)$ comme le <a href="/algo/tri/tri_bulles.html">tri à bulles</a>.</p>
<h2>Principe de l’algorithme</h2>
<p>Le tri par sélection se décompose en deux étapes :</p>
<ul>
<li>Sélectionner un élément (d&rsquo;où son nom).</li>
<li>Le placer à sa bonne place.</li>
</ul>
<p>Le facteur qui détermine si un élément est bien placé est son rang (par exemple : le <em>ième</em> plus petit élément sera forcément placé en <em>ième</em> position du tableau). Le tri par sélection va donc à chaque tour trouver le <em>ième</em> plus petit élément du tableau, pour ensuite l&rsquo;insérer à sa place, en commençant par le premier plus petit, et en augmentant à chaque fois (deuxième plus petit, troisième, etc.).</p>
<h2>Exemple</h2>
<p>Prenons désormais comme exemple la suite de nombres suivante : 6, 1, 9, 3. Trions cette suite avec l’algorithme du tri par sélection dans l’ordre croissant :</p>
<p><em>1er tour</em> :</p>
<p>6, <strong>1</strong>, 9, 3 -&gt; le plus petit élément du tableau est 1, on le place donc sur la première case (en l&rsquo;échangeant avec le 6).</p>
<p><em>2ème tour</em> :</p>
<p>1, 6, 9, <strong>3</strong> -&gt; le deuxième plus petit élément est 3, on le place sur la deuxième case et on l’échange avec le 6.</p>
<p><em>3ème tour</em> :</p>
<p>1, 3, 9, <strong>6</strong> -&gt; le troisième plus petit élément est 6, on l’échange avec 9 pour le placer sur la troisième case.</p>
<p><em>4ème tour</em> :</p>
<p>1, 3, 6, <strong>9</strong> -&gt; le quatrième plus petit élément du tableau est 9, il est déjà en quatrième position on ne fait rien.</p>
<p>1, 3, 6, 9</p>
<p>Ce tri se décompose réellement en deux étapes distinctes :</p>
<figure><img alt="Exemple de tri par sélection" src="/img/algo/tri/tri_selection/exemple_tri.png" /><figcaption>Exemple de tri par sélection</figcaption>
</figure>
<p>A chaque tour, on cherche le minimum dans l&rsquo;espace non trié du tableau (le minimum est représenté en bleu, et la partie non triée en blanc), ensuite on déplace cet élément à sa place définitive (représentée en vert). En faisant cela pour chaque élément du tableau, ce dernier se retrouve trié au bout de $N$ tours maximum ($N$ étant la taille du tableau).</p>
<h2>Pseudo-code</h2>
<p>Le pseudo-code du tri par sélection est simple :</p>
<pre><code class="nohighlight">triSelection :

   Pour chaque élément
      Pour chaque élément de la partie non triée
         Mettre à jour le minimum du tableau rencontré jusqu'ici
      Echanger l'élément actuel avec le minimum
</code></pre>

<h2>Complexité</h2>
<p>Comme pour le tri à bulles, le tri par sélection a une complexité en $O(N^2)$ :</p>
<ul>
<li>La première boucle parcourt $N$ tours.</li>
<li>La deuxième boucle parcourt $N – i$ tours ($i$ variant de 0 à $N$).</li>
</ul>
<p>Sa complexité est donc légèrement inférieure à $N^2$, cependant cette différence est mineure et sa complexité est considérée comme étant en $O(N^2)$.</p>
<h2>Implémentation</h2>
<p>Une implémentation en C de l&rsquo;algorithme du tri par sélection :</p>
<pre><code class="c">#include &lt;stdio.h&gt;

#define TAILLE_MAX 1000

int tableau[TAILLE_MAX];
int taille;

void echanger(int index1, int index2)
{
   int temp;

   temp = tableau[index1];
   tableau[index1] = tableau[index2];
   tableau[index2] = temp;
}

void triSelection(void)
{
   int iElement, iTab;
   int min;

   for(iElement = 0; iElement &lt; taille; ++iElement) {
      min = iElement;

      for(iTab = iElement + 1; iTab &lt; taille; ++iTab)
         if(tableau[iTab] &lt; tableau[min])
            min = iTab;

      if(min != iElement)
         echanger(iElement, min);
   }
}

int main(void)
{
   int iTab;

   scanf(&quot;%d\n&quot;, &amp;taille);

   for(iTab = 0; iTab &lt; taille; ++iTab)
      scanf(&quot;%d &quot;, &amp;tableau[iTab]);

   triSelection();

   for(iTab = 0; iTab &lt; taille; ++iTab)
      printf(&quot;%d &quot;, tableau[iTab]);
   printf(&quot;\n&quot;);

   return 0;
}
</code></pre>

<p>L&rsquo;entrée du programme :</p>
<pre><code class="nohighlight">4
6 1 9 3
</code></pre>

<p>Et la sortie attendue :</p>
<pre><code class="nohighlight">1 3 6 9
</code></pre>

<h2>Améliorations et variantes</h2>
<h3>Tri par sélection bidirectionnel</h3>
<p>Tout comme pour le tri à bulles, on peut améliorer légèrement le tri par sélection pour qu&rsquo;il effectue moins d&rsquo;opérations. Dans notre boucle qui cherche le <em>ième</em> plus petit élément, on peut aussi en profiter pour chercher le <em>jème</em> plus grand. Grâce à cela, on divise par deux le nombre de tours que l&rsquo;on réalise pour trier notre tableau, cependant, diviser par deux ne change pas la complexité finale car 2 est un facteur assez petit pour ne pas en prendre compte dans de très larges entrées. La complexité du tri reste donc quadratique.</p>
<pre><code class="nohighlight">Pour chaque élément restant
   Pour chaque élément de la partie non triée
      Mettre à jour le minimum et le maximum du tableau rencontré jusqu'ici

   Echanger l'élément i (variant de 0 à N / 2 ) avec le minimum
   Echanger l'élément j (variant de N à N / 2 ) avec le maximum
</code></pre>

<h3>Le cas des doublons</h3>
<p>Dans le cas où notre tableau contient de nombreux doublons, l&rsquo;algorithme de tri par sélection va effectuer plusieurs recherches de plus petits éléments sur le même élément qui n&rsquo;est rien d&rsquo;autre qu&rsquo;un doublon. Le <em>bingo sort</em> permet de palier ce problème, en proposant de placer tous les éléments ayant la même valeur en même temps, sans faire de nouvelles recherches à chaque tour. Encore une fois, notre algorithme sera plus rapide en général mais pas assez pour que la complexité change, elle restera donc en $O(N^2)$.</p>
<pre><code class="nohighlight">Pour chaque élément
   Pour chaque élément de la partie non triée
      Mettre à jour le minimum du tableau rencontré jusqu'ici

   Pour chaque élément de même valeur que le minimum
      Echanger avec l'élément actuel
      Augmenter l'indice de l'élément actuel
</code></pre>

<h3>Tri par tas</h3>
<p>On peut voir le <a href="/algo/tri/tri_tas.html">tri par tas</a> comme une amélioration directe du tri par sélection. En effet, si l&rsquo;on utilise un <a href="/algo/structure/arbre/tas.html">tas</a> pour permettre de trouver les plus petits éléments rapidement, on obtient une complexité en $O(N \log _2 N)$ et un tri qu&rsquo;on appelle tri par tas.</p>
<h2>Conclusion</h2>
<p>Le tri par sélection est donc un algorithme assez simple, mais peu efficace à cause de sa complexité en $O(N^2)$. Cependant des améliorations et des variantes permettent de le rendre plus rapide, et le tri par sélection sert de base au tri par tas, un autre algorithme de tri bien plus efficace avec une complexité en $O(N \log _2 N)$. Même avec une complexité quadratique, ce tri reste en pratique utilisé sur de petites entrées, mais aussi lorsqu&rsquo;on a besoin d&rsquo;un nombre d&rsquo;échanges faible au sein du tableau (contrairement au <a href="/algo/tri/tri_insertion.html">tri par insertion</a> qui peut être plus rapide, mais réalise plus d&rsquo;échanges).</p>



      <footer>
         <br>
         <hr>
         <p>Une question ? Une suggestion ? N'hésitez pas à me <a href="/a_propos.html">contacter</a> pour me communiquer vos remarques.</p>
         <br>
      </footer>

   </body>
</html>