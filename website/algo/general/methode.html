<!DOCTYPE html>
<html>
   <head>
      <meta charset="utf-8">

      <!-- CSS -->
      <link rel="stylesheet" type="text/css" href="/css/default.css">
      <link rel="stylesheet" type="text/css" href="/css/highlight_theme.css">

      <!-- Icon -->
      <link rel="icon" type="image/x-icon" href="/img/favicon.ico">

      <!-- Syntax highlighting -->
      <script src="/js/highlight.pack.js"></script>
      <script>hljs.initHighlightingOnLoad();</script>

      <!-- Renders LaTeX expression -->
      <script type="text/x-mathjax-config">
         MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
      </script>
      <script type="text/javascript" async 
              src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML">
      </script>

      <!-- Font Awesome -->
      <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

      <title>Méthode de résolution - napnac</title>
   </head>

   <body>
      <div id="sidebar">
         <a href="/"><img src="/img/logo.png" alt="Logo du site" height="125" width="125"></a>

         <div id="menu">
            <ul>
               <li><a href="/">Accueil</a></li>
               <li><a href="/articles.html">Articles</a></li>
               <li><a href="/projets.html">Projets</a></li>
               <li><a href="/a_propos.html">A propos</a></li>
            </ul>
         </div>

         <div id="info">
            <ul>
               <li><a href="https://twitter.com/napnac"><i class="fa fa-twitter fa-fw" aria-hidden="true"></i>Twitter</a></li>
               <li><a href="https://github.com/napnac"><i class="fa fa-github fa-fw" aria-hidden="true"></i>Github</a></li>
               <li><i class="fa fa-envelope fa-fw" aria-hidden="true"></i>napnac [at] domaine</li>
               <li><i class="fa fa-rss fa-fw" aria-hidden="true"></i><a href="https://napnac.fr/feed/rss.xml">RSS</a> / <a href="https://napnac.fr/feed/atom.xml">Atom</a></li>
            </ul>
         </div>

   <hr>
   <div id="article_metadata">
      <p>Publié le : 08/11/2016<br>Modifié le : 08/11/2016</p>
   </div>
      </div>

      <div id="content">
         <h1>Méthode de résolution</h1>

            <h3>Table des matières</h3>
            <div class="toc">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#enonce">Enoncé</a><ul>
<li><a href="#lecture">Lecture</a></li>
<li><a href="#reformulation">Reformulation</a></li>
<li><a href="#dimensions-et-contraintes">Dimensions et contraintes</a></li>
</ul>
</li>
<li><a href="#exemple">Exemple</a><ul>
<li><a href="#representation-graphique-du-probleme">Représentation graphique du problème</a></li>
<li><a href="#resoudre-des-exemples-a-la-main">Résoudre des exemples à la main</a></li>
</ul>
</li>
<li><a href="#algorithme">Algorithme</a><ul>
<li><a href="#algorithme-naif">Algorithme naïf</a></li>
<li><a href="#simplifier-le-probleme">Simplifier le problème</a></li>
<li><a href="#changer-de-point-de-vue">Changer de point de vue</a></li>
</ul>
</li>
<li><a href="#pseudo-code">Pseudo-code</a><ul>
<li><a href="#definition">Définition</a></li>
<li><a href="#ecriture">Ecriture</a></li>
<li><a href="#verification">Vérification</a></li>
</ul>
</li>
<li><a href="#coder-lalgorithme">Coder l&rsquo;algorithme</a></li>
<li><a href="#tester-le-code">Tester le code</a></li>
<li><a href="#debuguer-le-programme">Débuguer le programme</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
</div>


         <h2 id="introduction">Introduction</h2>
<p>Je ne le répèterai jamais assez, mais <a href="http://www.france-ioi.org/">France-IOI</a> est <strong>la référence francophone en algorithmique</strong>, et une des choses qui distingue fortement cette plateforme est la méthode de résolution qu&rsquo;elle cherche à transmettre au travers de ses exercices. Cet article a pour but de présenter cette méthode qui peut être terriblement efficace si correctement maitrisée. De plus, elle ne s&rsquo;applique pas uniquement pour des concours ou des exercices (même si les conseils donnés ici sont assez orientés concours de programmation), mais de manière générale lorsqu&rsquo;on cherche un algorithme pour résoudre un problème donné.</p>
<p>Cependant, cette méthode peut paraître longue et fastidieuse au début, et nécessite de l&rsquo;<a href="/algo/general/entrainement.html">entraînement</a> ainsi que de la rigueur pour être utilisée efficacement. La vitesse viendra avec la pratique et non en bâclant les étapes de cette méthode. Il peut être frustrant au début de résoudre lentement un problème, mais cela vous sera très utile dans le futur et vous serez capable de réaliser les différentes étapes de cette méthode bien plus rapidement grâce à votre expérience.</p>
<p>Il est important de noter que cette méthode n&rsquo;est pas réellement adaptée pour un débutant complet, c&rsquo;est-à-dire que si vous venez à peine de découvrir ce qu&rsquo;est un algorithme, il serait plus judicieux d&rsquo;acquérir davantage de connaissances sur le sujet avant d&rsquo;appréhender et d&rsquo;appliquer cette méthode. Mais il n&rsquo;y a pas énormément de prérequis non de plus, dans le sens où un niveau basique en algorithmique et en <a href="/algo/general/complexite.html">analyse de complexité</a> suffit pour commencer.</p>
<p>En plus de votre ordinateur, vous n&rsquo;aurez besoin que de feuilles et d&rsquo;un crayon.</p>
<h2 id="enonce">Enoncé</h2>
<h3 id="lecture">Lecture</h3>
<p>Que ce soit un concours de programmation ou un problème que vous cherchez à résoudre, la première étape est de <strong>lire attentivement l&rsquo;énoncé</strong>, et de ne surtout pas se précipiter. Cela peut paraitre évidant, mais c&rsquo;est une erreur commune de se tromper dans la lecture du sujet, alors qu&rsquo;il est facile d&rsquo;éviter ceci. Relisez plusieurs fois ce dernier jusqu&rsquo;à l&rsquo;avoir en tête, et essayer de vous concentrer sur le sujet et non sur l&rsquo;algorithme pour l&rsquo;instant. Il est fréquent de commencer à lire le sujet et d&rsquo;avoir une idée d&rsquo;algorithme en tête qu&rsquo;on cherche à développer, mais cette dernière n&rsquo;est quasiment jamais la bonne car on n&rsquo;a pas toutes les informations à propos de l&rsquo;énoncé. <strong>Ne cherchez pas de solutions au problème pour l&rsquo;instant</strong>, votre premier objectif est de comprendre parfaitement le sujet et de n&rsquo;avoir aucuns doutes dessus. Commencer à chercher aussi tôt ne ferra que vous perturber, vous emmêler ou encore pire, vous induire en erreur.</p>
<h3 id="reformulation">Reformulation</h3>
<p>Une fois le sujet correctement lu et appréhendé, il est crucial de le <strong>reformuler en quelques phrases</strong> (deux ou trois en général suffisent, il ne s&rsquo;agit pas ici de réécrire le problème). Ceci vous permet dans un premier temps de vérifier votre compréhension vis-à-vis de l&rsquo;énoncé, mais aussi de le décrire efficacement et de manière concise. Supprimez tous les détails inutiles, et concentrez-vous sur ce qu&rsquo;on vous demande concrètement de faire. Vous pouvez vous aider en écrivant deux phrases types, &ldquo;On nous donne&hellip;&rdquo; et &ldquo;On nous demande&hellip;&rdquo;, puis si nécessaire notez les points importants à ne pas oublier ou spécifiques au sujet. Attention cependant, car <strong>l&rsquo;étape de reformulation ne doit pas dériver du sujet</strong> (en le simplifiant ou en le généralisant par exemple), elle doit le décrire parfaitement comme si vous expliquiez l&rsquo;énoncé à une personne.</p>
<p>Il est très courant dans un concours de programmation d&rsquo;avoir une histoire qui accompagne le sujet, et l&rsquo;étape de reformulation permet d&rsquo;écarter cette dernière en explicitant le problème de manière crue et non imagée. Il faut arriver à se détacher le plus possible de l&rsquo;histoire et décrire le problème d&rsquo;un point de vue purement algorithmique.</p>
<p>Voici un exemple de sujet très simple, ainsi qu&rsquo;une reformulation de ce dernier :</p>
<blockquote>
<p>Alice et Bob sont de très bons amis, cependant les deux voyagent beaucoup et ils aimeraient se rencontrer afin de discuter de leurs dernières aventures. A force de voyager, Alice et Bob n&rsquo;ont plus énormément d&rsquo;argent, et Alice n&rsquo;a pas de quoi payer pour rencontrer Bob. Ce dernier décide donc de la rejoindre, et se renseigne sur les différents moyens de transports ainsi que leurs coûts. Son but est de voyager à prix minime, pour économiser dans de futurs voyages. Après une recherche sur son navigateur favori, Bob se retrouve avec les informations suivantes :  </p>
<table>
<thead>
<tr>
<th>Départ</th>
<th>Arrivée</th>
<th>Coût</th>
<th>Transport</th>
</tr>
</thead>
<tbody>
<tr>
<td>Shanghai</td>
<td>Pékin</td>
<td>100€</td>
<td>train</td>
</tr>
<tr>
<td>New-York</td>
<td>Londres</td>
<td>700€</td>
<td>avion</td>
</tr>
<tr>
<td>Paris</td>
<td>Shanghai</td>
<td>700€</td>
<td>avion</td>
</tr>
<tr>
<td>New-York</td>
<td>Pékin</td>
<td>800€</td>
<td>avion</td>
</tr>
<tr>
<td>Moscou</td>
<td>Shanghai</td>
<td>450€</td>
<td>avion</td>
</tr>
<tr>
<td>Pékin</td>
<td>Moscou</td>
<td>300€</td>
<td>train</td>
</tr>
<tr>
<td>Le Caire</td>
<td>Paris</td>
<td>500€</td>
<td>avion</td>
</tr>
<tr>
<td>Moscou</td>
<td>New-York</td>
<td>700€</td>
<td>avion</td>
</tr>
<tr>
<td>Paris</td>
<td>Londres</td>
<td>200€</td>
<td>train</td>
</tr>
<tr>
<td>Moscou</td>
<td>Paris</td>
<td>300€</td>
<td>train</td>
</tr>
</tbody>
</table>
<p>Sachant que Bob est actuellement à Pékin et qu&rsquo;Alice se trouve à Londres, combien Bob devra-t-il dépenser au minimum afin de rencontrer Alice ?</p>
</blockquote>
<p>Un exemple de reformulation utile de ce sujet :</p>
<blockquote>
<p>On nous donne un graphe orienté pondéré positivement.<br />
On nous demande le plus court chemin entre deux nœuds de ce graphe.</p>
</blockquote>
<p>Plus d&rsquo;histoire, plus d&rsquo;Alice et Bob, on garde uniquement le strict minimum, sans pour autant perdre des informations. Ici, l&rsquo;entrée donnée par le sujet est un graphe implicite où chaque ville est un nœud et chaque trajet un arc. Le graphe est orienté car on a une case &ldquo;Départ&rdquo; et &ldquo;Arrivée&rdquo; ce qui semble indiquer une direction à suivre. L&rsquo;information du transport (avion ou train) est en réalité inutile à notre problème puisqu&rsquo;on ne cherche qu&rsquo;à minimiser le coût, on l&rsquo;omet donc de notre description. La pondération du graphe simule le coût du trajet, or ce coût est toujours positif donc on le précise. Pour ce qui est de la sortie, on nous demande effectivement un plus court chemin reliant le nœud de départ (où se trouve Bob sur le graphe) et un nœud d&rsquo;arrivée (où se trouve Alice).</p>
<p>Une fois le sujet reformulé, il peut être intéressant de <strong>relire une dernière fois l&rsquo;énoncé</strong> pour s&rsquo;assurer de la véracité de la reformulation. En effet, cette dernière sera l&rsquo;élément central de notre réflexion, donc il faut être certain qu&rsquo;elle est correcte car on basera toute notre méthode de recherche de l&rsquo;algorithme dessus.</p>
<p>Encore une fois, on est actuellement dans la compréhension du sujet et non dans la résolution. Ne vous lancez pas à tête baissée dans une idée d&rsquo;algorithme tout de suite, attendez pour vérifier votre réflexion.</p>
<h3 id="dimensions-et-contraintes">Dimensions et contraintes</h3>
<p>Enfin, dernière sous étape qui concerne l&rsquo;énoncé, il faut noter sur votre feuille les dimensions et les contraintes du sujet.</p>
<p>Une <strong>dimension</strong> est une donnée qu&rsquo;on fournit dans l&rsquo;énoncé du problème. Dans l&rsquo;exemple d&rsquo;Alice et Bob, on pourrait avoir la liste de dimensions suivante :</p>
<blockquote>
<p>Soit $N$ le nombre de villes où peuvent voyager Alice et Bob, $1 &lt;= N &lt;= 200$<br />
Soit $M$ le prix d&rsquo;un trajet, $1 &lt;= M &lt;= 3000$€<br />
Soit $K$ le coût total du trajet de Bob pour rejoindre Alice, $1 &lt;= K &lt;= 100000$€</p>
</blockquote>
<p>On distingue plusieurs types de dimensions :</p>
<ul>
<li><strong>dimension d&rsquo;entrée</strong> : une valeur qui va concerner directement l&rsquo;entrée de votre programme (ex: $N$ ou $M$)</li>
<li><strong>dimension de sortie</strong> : une valeur qui va concerner directement la sortie de votre programme (ex: $K$)</li>
<li><strong>dimension implicite</strong> : une valeur implicite de l&rsquo;énoncé qui peut être intéressante de noter (ex: si on fournit en entrée des coordonnées de points dans l&rsquo;espace, une dimension implicite pourrait être la distance entre deux points)</li>
</ul>
<p>Pour chaque dimension il est utile de mettre la borne minimale et maximale, qui sont la plupart du temps données par le sujet ou qu&rsquo;on peut simplement calculer.</p>
<p>Une <strong>contrainte</strong> est une limite imposée par l&rsquo;énoncé, concernant généralement le temps ou la mémoire qu&rsquo;on accorde à votre programme. Ces dernières sont explicites, par exemple :</p>
<blockquote>
<p>Temps : 1s sur une machine à 1Ghz<br />
Mémoire : 32000 Ko</p>
</blockquote>
<p>Lister les dimensions et les contraintes vous permet de vérifier rapidement si votre algorithme est assez efficace. En effet, avec ces informations il suffit de calculer la complexité d&rsquo;un algorithme pour se rendre compte instantanément s&rsquo;il respecte ou non le sujet.</p>
<p><em>Attention à ne pas mettre les dimensions ou les contraintes dans la reformulation, ce sont deux sous-étapes bien distinctes.</em></p>
<h2 id="exemple">Exemple</h2>
<p>Deuxième étape de la méthode de résolution : <strong>résoudre des exemples à la main</strong>. Désormais, on va se concentrer sur la partie résolution du problème et non plus dans la compréhension du sujet, vous devriez maintenant avoir ce dernier bien en tête et correctement reformulé en quelques phrases relativement courtes.</p>
<h3 id="representation-graphique-du-probleme">Représentation graphique du problème</h3>
<p>Avant de se lancer dans la résolution d&rsquo;exemples, on peut commencer par chercher une bonne graphique représentation de notre problème. Visualiser ce dernier nous permettra de trouver une solution bien plus facilement, mais encore une fois, il y a de nombreuses façons de représenter une même chose mais peu sont réellement efficaces et utiles.</p>
<p>Une bonne visualisation indique des informations indispensables, il ne faut surtout pas surcharger la figure car elle doit rester claire et précise. Cette représentation peut prendre différentes formes selon le sujet et le contexte : graphe, arbre, tableau, graphique 2D, etc.</p>
<h3 id="resoudre-des-exemples-a-la-main">Résoudre des exemples à la main</h3>
<p>Trouver une solution est bien plus simple lorsqu&rsquo;on essaie nous même de résoudre le problème plutôt que d&rsquo;y réfléchir dans sa tête. En effet, notre cerveau est un outil très efficace pour ce genre de tâche, et se demander comment on ferrait personnellement pour résoudre le problème peut être un bon départ de réflexion. De plus, votre cerveau peut trouver rapidement des raccourcis pour éviter de répéter des mêmes opérations fastidieuses, et ceci nous aidera grandement pour trouver un algorithme efficace.</p>
<p>Il est courant d&rsquo;avoir des exemples dans l&rsquo;énoncé du problème, mais il en faudra plus pour trouver l&rsquo;algorithme. Cependant, générer plusieurs <strong>bons exemples</strong> est loin d&rsquo;être facile. Les exemples doivent être tous assez différents les uns des autres pour généraliser l&rsquo;algorithme et faire ressortir des idées, pas trop longs pour ne pas perdre trop de temps (surtout pendant un concours de programmation), mais ni trop courts pour ne pas être inutiles.</p>
<p>En plus d&rsquo;aider à résoudre le problème et à trouver un algorithme, cette étape importante permet aussi de fournir des tests pour notre futur code (si les exemples à la main sont résolus correctement). On peut trouver des <strong>cas spéciaux</strong> ou des <strong>cas limites</strong> (en fonction des contraintes et des dimensions du problème) qui peuvent nous permettre de tester l&rsquo;efficacité de l&rsquo;algorithme. Un exemple de cas limite pour le problème d&rsquo;Alice et Bob serait une entrée avec des millions (voire des milliards) d&rsquo;itinéraires possibles. L&rsquo;objectif de ce genre d&rsquo;exemple est de tester si notre algorithme respecte ou non les contraintes du sujet.</p>
<h2 id="algorithme">Algorithme</h2>
<p>Si à partir des exemples, vous n&rsquo;avez encore aucunes réelles idées de l&rsquo;algorithme à employer, il est possible d&rsquo;utiliser différentes stratégies afin de changer d&rsquo;approche.</p>
<h3 id="algorithme-naif">Algorithme naïf</h3>
<p>Un algorithme dit <strong>naïf</strong> est la première méthode bourrin qui vous vient à l&rsquo;esprit lorsqu&rsquo;on vous pose un problème. Ce dernier ne se soucie pas des contraintes, des dimensions, ou autre, et cherche uniquement à résoudre l&rsquo;énoncé. Par exemple, si l&rsquo;on reprend notre reformulation du sujet :</p>
<blockquote>
<p>On nous donne un graphe orienté pondéré positivement.<br />
On nous demande le plus court chemin entre deux nœuds de ce graphe.</p>
</blockquote>
<p>Imaginons qu&rsquo;on ne connaisse aucun algorithme de plus court chemin sur un graphe, il faut donc qu&rsquo;on arrive à en créer un nous même. L&rsquo;algorithme naïf serait alors de tester bêtement tous les chemins et de sélectionner le plus court. Rien de plus simple, et même si cet algorithme est terriblement peu efficace, il est souvent très intéressant de partir de cela pour ensuite l&rsquo;améliorer et découvrir un algorithme qui respecte les contraintes et les dimensions (c&rsquo;est d&rsquo;ailleurs la stratégie que j&rsquo;adopte dans mon article sur l&rsquo;algorithme de plus court chemin <a href="/algo/structure/graphe/plus_court_chemin/bellman_ford.html">Bellman-Ford</a>).</p>
<p>L&rsquo;avantage de cette méthode est qu&rsquo;il est évident de trouver l&rsquo;algorithme naïf pour résoudre un problème, et que ses points faibles sont très rapidement soulignés lorsqu&rsquo;on cherche à réaliser un exemple à la main avec ce dernier. En effet, on va vite remarquer ce que notre algorithme répète inutilement, et il suffit d&rsquo;optimiser ces points en trouvant une méthode plus réfléchie et moins naïve.</p>
<p><em>Un ou deux exemples devraient suffire, pas besoin de recommencer entièrement l&rsquo;étape précédente. En revanche, choisissez des exemples un minimum longs pour avoir le temps de trouver les points faibles.</em></p>
<p>N&rsquo;oubliez pas de calculer la complexité en temps et en mémoire de votre algorithme bourrin pour deux raisons principalement :</p>
<ul>
<li>Il arrive que l&rsquo;algorithme naïf soit une solution suffisante dans des cas simplistes. En concours, il est alors inutile de chercher à améliorer l&rsquo;algorithme s&rsquo;il respecte déjà les contraintes, d&rsquo;autant plus que l&rsquo;algorithme bourrin est souvent rapide et simple à programmer.</li>
<li>Connaître la complexité en temps et en mémoire permet de se rendre compte des améliorations nécessaires pour que le nouvel algorithme soit efficace.</li>
</ul>
<h3 id="simplifier-le-probleme">Simplifier le problème</h3>
<p>Si vous bloquez sur le sujet, essayez de le simplifier car cela permettra de faire ressortir plus d&rsquo;idées qui sont souvent très utiles pour le problème original. Pour cela, on réalise un tableau des dimensions fondamentales du sujet, et on essaie d&rsquo;appliquer différentes opérations sur chaque dimension :</p>
<ul>
<li><strong>Supprimer</strong> : l&rsquo;auteur d&rsquo;un problème peut rajouter des dimensions afin de rendre un sujet plus complexe, il peut donc être judicieux de supprimer entièrement une dimension pour rendre le processus de réflexion plus simple et plus efficace. Prenons un exemple où l&rsquo;on vous fournit des intervalles de temps, on pourrait supprimer une dimension en faisant en sorte d&rsquo;utiliser des points fixes dans le temps au lieu d&rsquo;intervalle.</li>
<li><strong>Fixer</strong> : pour mieux généraliser le problème, on peut fixer une ou plusieurs dimensions à des valeurs bien précises. Par exemple, si le sujet implique des rectangles à dimensions variables, que se passe-t-il si tous les rectangles ont la même largeur et la même hauteur ? Ou encore, si tous les rectangles deviennent des carrés ?</li>
<li><strong>Réduire</strong> : si on n&rsquo;arrive pas à trouver un algorithme assez efficace, il faut commencer par un algorithme plus simple mais moins intelligent (attention ici on ne veut pas retomber sur l&rsquo;algorithme naïf). Réduire des dimensions par 2, 10, etc. peut aider à trouver un début d&rsquo;algorithme, qu&rsquo;on pourra ensuite améliorer.</li>
</ul>
<h3 id="changer-de-point-de-vue">Changer de point de vue</h3>
<p>Enfin, si vous n&rsquo;avez vraiment aucunes idées correctes, c&rsquo;est que votre point de vue n&rsquo;est pas bon. Tentez de résoudre le problème avec des algorithmes <em>classiques</em>, car souvent deux sujets peuvent sembler totalement différents mais en réalité il est possible de les représenter grâce à une seule même structure et ainsi de les résoudre pratiquement de la même façon. Les sujets impliquant des graphes dit <em>implicites</em> en sont l&rsquo;exemple parfait. Imaginez qu&rsquo;on vous donne un nombre $N$ et un nombre $M$, ainsi que différentes opérations mathématiques (comme ajouter $A$, soustraire $B$, ou encore multiplier $C$), et vous devez déterminer s&rsquo;il est possible d&rsquo;utiliser les opérations données pour passer du nombre $N$ au nombre $M$. Présenté comme ceci, on ne se doute pas qu&rsquo;il s&rsquo;agît en réalité d&rsquo;un problème de graphe, mais lorsqu&rsquo;on adopte ce nouveau point de vue, on se rend compte qu&rsquo;on peut représenter ce problème sous la forme d&rsquo;un graphe où chaque nœud correspond à un résultat, et chaque arc est une opération. Le but apparaît alors comme trivial, on veut se rendre d&rsquo;un nœud de départ $N$ au nœud d&rsquo;arrivée $M$, on applique donc un simple <a href="/algo/structure/graphe/parcours.html">algorithme de parcours de graphe</a>.</p>
<p>Le fait d&rsquo;avoir changé totalement de point de vue nous a fait découvrir une nouvelle façon de représenter le problème, et il est tout à fait possible de faire la même chose pour d&rsquo;autre algorithme classique (comme la <a href="/algo/general/approche/dynamique.html">programmation dynamique</a>, l&rsquo;approche du <a href="https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms">diviser pour régner</a>, etc.).</p>
<h2 id="pseudo-code">Pseudo-code</h2>
<p>Vous avez enfin trouvé dans votre tête l&rsquo;algorithme recherché, cependant lorsqu&rsquo;on veut résoudre un problème un minimum conséquent, <strong>on ne code jamais directement</strong> mais on passe par une étape intermédiaire : le pseudo-code. Avant d&rsquo;expliquer concrètement ce qu&rsquo;est le pseudo-code, j&rsquo;aimerais vraiment m&rsquo;attarder sur l&rsquo;importance de ce dernier qui est souvent trop négligé (surtout pendant des concours).</p>
<p>Imaginons que vous venez de trouver l&rsquo;algorithme. Vous avez votre idée en tête ainsi que toutes les informations pour résoudre le sujet, et vous décidez donc de passer directement à l&rsquo;étape de programmation car vous jugez la partie pseudo-code inutile. Comme vous n&rsquo;avez aucune réelle structure, vous programmez ce qui vous vient en premier à l&rsquo;esprit, cependant au fur et à mesure que vous codez vous vous rendez compte qu&rsquo;il faudra ajouter/supprimer/changer telle ou telle partie du programme à cause de détails auxquels vous n&rsquo;avez pas pensé auparavant. Vous allez donc passer beaucoup de temps à réécrire ou à bidouiller votre code afin de prendre en compte ces changements, et ceci va résulter en un programme souvent sale et mal structuré (voire carrément faux). Or l&rsquo;étape de débugage est fondamentale et débuguer ce genre de code est un cauchemar qui ne finit en général pas très bien. Après avoir perdu <strong>énormément</strong> de temps à corriger vos erreurs (si vous arrivez au bout de cette étape), vous vous rendez compte en testant votre algorithme qu&rsquo;il n&rsquo;est tout simplement pas assez efficace et que sa complexité en temps ne satisfait pas les contraintes de l&rsquo;énoncé.</p>
<p>Cet exemple de scénario peut paraître exagéré mais il est en réalité très fréquent en concours (bien plus qu&rsquo;on ne le croit). Maintenant, regardons de plus près l&rsquo;utilité du pseudo-code.</p>
<h3 id="definition">Définition</h3>
<p>Le pseudo-code est une manière d&rsquo;établir un algorithme sur le papier, sans se soucier des détails d&rsquo;implémentation ou du quelconque langage utilisé ensuite. Cette étape est extrêmement importante car elle permet de se concentrer <strong>uniquement sur l&rsquo;algorithme</strong> et non sur la manière dont vous allez le programmer. De plus, cela structure correctement vos idées, ce qui vous permettra de coder le programme en quelques minutes seulement (ce n&rsquo;est donc en aucun cas une perte de temps). On peut voir le pseudo-code comme le plan d&rsquo;une dissertation, qui sans ce dernier serait maladroite, non structurée et qui pourrait porter à confusion.</p>
<p>L&rsquo;avantage énorme d&rsquo;un pseudo-code est qu&rsquo;il est assez court (une vingtaine de lignes suffisent en général pour les sujets les plus difficiles) et moins rigoureux qu&rsquo;un programme informatique, on peut donc faire plusieurs ébauches ou carrément changer totalement d&rsquo;algorithme en quelques instants (ce qui prendrait <strong>bien plus de temps</strong> si l&rsquo;on programmait à chaque fois notre nouvelle idée). Cette étape est en réalité un gain de temps considérable, ainsi qu&rsquo;un moyen efficace de vérifier et de structurer les différents prototypes d&rsquo;algorithme pour résoudre un sujet.</p>
<p>De plus, un bon pseudo-code aide à réduire les risques de bugs dans notre futur programme car on aura déjà établi la structure du code ainsi que la manière d&rsquo;implémenter notre algorithme. On réduit alors encore une fois le temps perdu à débuguer ce qui est toujours avantageux.</p>
<h3 id="ecriture">Ecriture</h3>
<p>Il n&rsquo;y a pas de règles de syntaxe pour le pseudo-code et c&rsquo;est ce qui le rend très personnel, chacun a sa manière d&rsquo;en écrire, cependant il y a quelques méthodes qui sont intéressantes de suivre afin de constituer un pseudo-code réellement utile :</p>
<ul>
<li>Un pseudo-code se doit d&rsquo;être concis, il ne s&rsquo;agit pas ici de réécrire en français tout un programme informatique. On ne mettra que ce qui nous intéresse réellement, et uniquement ce qui concerne l&rsquo;algorithme en lui-même. Vu qu&rsquo;il y a différentes façons de l&rsquo;implémenter, <strong>on ne se souciera pas des détails d&rsquo;implémentation</strong> (qui seront déterminés dans une prochaine étape).</li>
<li>En revanche, il faut faire attention à ne surtout pas oublier des parties de l&rsquo;algorithme en pensant que ce sont des détails d&rsquo;implémentation. Si une portion du pseudo-code est floue ou peu détaillée, et qu&rsquo;elle concerne directement l&rsquo;algorithme, il faut la travailler davantage avant de coder. Le plus dur dans l&rsquo;écriture du pseudo-code est le juste milieu entre simplification et exhaustivité, car il doit être à la fois simple pour permettre ensuite de programmer rapidement et facilement, mais aussi complet afin de décrire entièrement notre algorithme.</li>
<li>Notre pseudo-code doit faire <strong>ressortir les éléments principaux de notre algorithme</strong> (structures de données, boucles, fonctions, etc.). C&rsquo;est pourquoi on utilisera ces outils uniquement quand ils concernent directement l&rsquo;algorithme. Par exemple, les entrées et les sorties de notre programme ne sont que des détails et on écrira <code>Lire graphe</code> sans détailler davantage, ou encore <code>Afficher tableau</code> au lieu d&rsquo;une boucle.</li>
<li>Tout comme il est normal d&rsquo;<a href="https://en.wikipedia.org/wiki/Indent_style">indenter</a> son code, il est essentiel <strong>d&rsquo;indenter son pseudo-code</strong> pour faciliter la lecture. N&rsquo;hésitez pas à laisser de la place sur votre feuille si vous devez ensuite rajouter des précisions.</li>
<li>Les variables sont des détails d&rsquo;implémentation, il est donc inutile de les déclarer, en revanche préciser le type et la valeur d&rsquo;initialisation peut être intéressant dans certains cas.</li>
<li>Le pseudo-code ne doit pas contenir de commentaire car ce dernier doit être assez clair et écrit en français.</li>
</ul>
<p>A titre d&rsquo;exemple, voici mon pseudo-code allant avec notre problème de voyage entre Alice et Bob :</p>
<pre><code class="nohighlight">Lire le graphe orienté pondéré positivement

coût_min = Dijkstra(Pékin, Londres)

Afficher coût_min


Dijkstra (départ, arrivée) :

   départ.coût = 0
   Enfiler le nœud de départ

   Tant que la file à priorité n'est pas vide
      Défiler le nœud au début de la file

      Si c'est le nœud d'arrivée
         Retourner nœud.coût

      Marquer le nœud comme visité
      Pour chaque voisin du nœud
         Si le voisin n'est pas visité
            voisin.coût = nœud.coût + coût_arc
            Enfiler le voisin
</code></pre>

<p>J&rsquo;utilise ici l&rsquo;<a href="/algo/structure/graphe/plus_court_chemin/dijkstra.html">algorithme de Dijkstra</a> en tant qu&rsquo;algorithme de plus court chemin sur mon graphe.</p>
<p><em>En général pendant un concours, lorsqu&rsquo;on utilise un algorithme aussi classique que celui de Dijkstra, et que ce dernier ne contient aucunes modifications majeures, on peut se permettre pour gagner du temps de ne pas détailler ladite fonction dans le pseudo-code (à condition de savoir la coder parfaitement sans aucuns doutes).</em></p>
<p>Au travers de mes articles, j&rsquo;utiliserai toujours des pseudo-codes avant l&rsquo;implémentation pour plusieurs raisons :</p>
<ul>
<li>Un pseudo-code est écrit en français, et il permet d&rsquo;appréhender l&rsquo;algorithme abordé facilement.</li>
<li>Il ne dépend d&rsquo;aucun langage de programmation (que ça soit au niveau de la syntaxe, ou encore des détails), donc que vous programmiez en C, en Python, en Ocaml, ou autre, vous pouvez très bien le lire, le comprendre et l&rsquo;implémenter de votre côté.</li>
<li>Le pseudo-code apporte une réelle structure ce qui est extrêmement pratique quand on veut implémenter correctement un algorithme.</li>
</ul>
<p>Cette étape qui peut paraître pénible voire inutile, est <strong>essentielle</strong>, et pratiquer l&rsquo;écriture du pseudo-code est une bonne habitude, surtout lorsqu&rsquo;on débute. Forcez-vous si nécessaire à en écrire au début, même si ça peut paraître trivial sur des problèmes simples, vous verrez qu&rsquo;ensuite cela sera indispensable.</p>
<h3 id="verification">Vérification</h3>
<p>Une fois le pseudo-code correctement établit, il faut une dernière étape de vérification (assez rapide) pour s&rsquo;assurer au maximum d&rsquo;avoir une solution valide avant de se lancer dans le code :</p>
<ul>
<li><strong>Relire le sujet</strong> afin d&rsquo;être certain de bien répondre à ce dernier et de ne pas avoir inconsciemment dévié du problème initial lors de la recherche d&rsquo;une solution.</li>
<li><strong>Vérifier avec des exemples</strong> que le pseudo-code retourne bien la sortie attendue (réutilisez ceux de l&rsquo;énoncé ou vos propres exemples que vous avez générés auparavant).</li>
<li><strong>Calculer la complexité en temps et en mémoire</strong> à nouveau pour être convaincu de l&rsquo;efficacité de l&rsquo;algorithme.</li>
</ul>
<h2 id="coder-lalgorithme">Coder l&rsquo;algorithme</h2>
<p>A partir de ce moment, vous devez être sûr de votre algorithme car coder, tester et débuguer un programme est un processus qui peut être très long si les étapes précédentes ne sont pas correctement suivies. Normalement, vous avez votre algorithme en tête, un pseudo-code clair et précis, ainsi que plusieurs exemples (en plus de ceux du sujet) pour tester le programme. Tout est réuni pour coder efficacement, rapidement, et si possible avec le moins de bug possible. Il y a tout de même quelques astuces à respecter pour éviter au mieux les potentielles erreurs (ces conseils s&rsquo;appliquent principalement lors de concours où le temps est limité) :</p>
<ul>
<li><strong>Ne cherchez surtout pas à optimiser votre programme lorsque vous êtes en train de l&rsquo;écrire !</strong> Comme le dit si bien <a href="https://en.wikipedia.org/wiki/Donald_Knuth">Donald Knuth</a> : <em>&ldquo;We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil&rdquo;</em>. Inutile de chercher à optimiser des petites parties de votre code, car l&rsquo;impact sur la complexité en temps et en mémoire sera sans doute minime et vous risquez d&rsquo;introduire plus de bugs.</li>
<li>Ne vous compliquez pas la tâche quand il y a une alternative plus simple. En concours, le but est de créer <strong>le programme le plus simple possible</strong> (pour réduire le nombre d&rsquo;erreurs). Par exemple, il est rarement utile de faire une allocation dynamique qui prend du temps et risque d&rsquo;être mal effectuée, en revanche il est commun et bien plus pratique de déclarer les variables majeures du programme en tant que variable globale pour simplifier le programme et éviter des bugs inutiles liés à l&rsquo;allocation et à la libération de la mémoire.</li>
<li>Utilisez de <em>bons</em> noms de variables et de fonctions pour ne pas se retrouver avec des noms à une lettre comme <code>i</code> et <code>j</code> partout dans votre code (au risque de confondre et de s&rsquo;emmêler dans l&rsquo;algorithme). C&rsquo;est plus une habitude à prendre, mais nommer correctement une variable peut se révéler plus dur qu&rsquo;on ne le croit. Un nom correct doit être précis, clair et relativement concis. On préfèrera largement <code>for(iNoeud = 0; iNoeud &lt; nbNoeud; ++iNoeud)</code> que <code>for(i = 0; i &lt; n; ++i)</code> car on voit directement de quoi l&rsquo;on parle et ce que contiennent les variables.</li>
<li>N&rsquo;hésitez pas à re-déclarer des variables au lieu de réutiliser d&rsquo;anciennes qui non plus forcément de rapport (notamment dans les boucles, car il serait dommage de réutiliser une variable qui contient des restes indésirables et qui pourrait introduire un bug très difficile à détecter).</li>
</ul>
<p>Dans mes articles, encore une fois, j&rsquo;essaie le plus souvent possible de suivre cette méthode. Vous pouvez donc retrouver facilement plusieurs exemples d&rsquo;une application concrète de ces conseils.</p>
<p>Lorsque vous avez terminé de coder, vous pouvez éventuellement faire une rapide comparaison du pseudo-code et du programme pour vérifier de n&rsquo;avoir rien oublié (vu que les deux devraient avoir une structure commune).</p>
<h2 id="tester-le-code">Tester le code</h2>
<p>Une fois l&rsquo;algorithme codé, il est nécessaire de s&rsquo;assurer de la <strong>validité du programme</strong>.</p>
<p>Créez un fichier pour chaque exemple que vous possédez, et exécutez votre programme avec ces derniers pour s&rsquo;assurer de la sortie. Il est souvent indispensable d&rsquo;avoir un fichier contenant un exemple de cas limite (vous pouvez le générer automatiquement en quelques lignes de code pour ne pas perdre du temps à le remplir à la main).</p>
<p>Si vous faites des variantes d&rsquo;un ou plusieurs fichiers tests, n&rsquo;oubliez pas de les conserver dans des fichiers à part car cela vous donne des tests supplémentaires pour vérifier votre programme.</p>
<p>Enfin, la sortie des exemples est une bonne manière de tester notre code, mais on peut aussi afficher le contenu des variables/structures de données principales pour confirmer que tout fonctionne parfaitement.</p>
<h2 id="debuguer-le-programme">Débuguer le programme</h2>
<p>Malheureusement, il est rare de coder du premier coup sans bug, et cette chance diminue d&rsquo;autant plus que la complexité du problème augmente. Savoir débuguer un programme rapidement et efficacement est donc un atout énorme (surtout dans les concours de programmation).</p>
<p>Avant de vous lancer dans le code à tête baissée, il faut trouver l&rsquo;exemple d&rsquo;entrée le plus simple possible qui fasse planter votre programme (vous pouvez utiliser vos différents exemples des étapes précédentes pour vous aider). Cela aura l&rsquo;avantage énorme de simplifier grandement la recherche du problème, et ceci représente un potentiel gain de temps non négligeable (surtout que le débugage peut être une étape très longue).</p>
<p>Afficher ce que contiennent les variables importantes de l&rsquo;algorithme est primordial pour trouver d&rsquo;où vient l&rsquo;erreur (attention à ne pas afficher trop d&rsquo;informations inutiles non plus, ce qui risquerait de vous faire perdre du temps). Il est aussi possible de raisonner par <a href="/algo/recherche/dichotomie.html">dichotomie</a> pour localiser le bug, en s&rsquo;assurant des endroits du programme qui fonctionnent correctement puis en affinant les recherches jusqu&rsquo;à réduire l&rsquo;intervalle à une ou plusieurs lignes de code.</p>
<p>Enfin, dans des cas précis comme une <a href="https://en.wikipedia.org/wiki/Segmentation_fault">erreur de segmentation</a>, on peut avoir recours à des outils externes (comme <a href="https://www.gnu.org/software/gdb/">gdb</a> pour le C et le C++ principalement), mais ces derniers sont complexes et si vous ne savez pas correctement les utiliser cela sera plus une perte de temps qu&rsquo;autre chose. De manière générale, on évitera d&rsquo;utiliser ces outils pour débuguer un programme aussi court que le nôtre, mais sachez qu&rsquo;ils peuvent être utiles dans des situations particulières.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Il n&rsquo;y a pas de méthode miraculeuse pour résoudre un sujet, mais ces différentes étapes ont pour but de maximiser vos chances de trouver la solution à votre problème. Même si plusieurs des conseils étaient orientés pour des concours de programmation, cette manière globale de réfléchir est applicable à bien d&rsquo;autres domaines (on peut notamment penser aux mathématiques).</p>
<p>Encore une fois, cette approche de résolution n&rsquo;est pas la mienne, mais c&rsquo;est l&rsquo;interprétation que je fais de la méthode de <a href="http://www.france-ioi.org/">France-IOI</a>. Je vous invite fortement à lire leurs propres documents sur le sujet (onglet &ldquo;Méthode&rdquo; de la partie &ldquo;Cours et problèmes&rdquo;) afin d&rsquo;étudier les différentes étapes d&rsquo;un point de vue différent (même si dans l&rsquo;ensemble les idées sont communes).</p>
<p>J&rsquo;insiste aussi sur le fait que cette méthode de résolution nécessite <a href="/algo/general/entrainement.html"><strong>beaucoup d&rsquo;entraînement</strong></a>, et qu&rsquo;il ne faut surtout pas sauter ou bâcler des étapes, mais au contraire les réaliser le plus sérieusement possible. Avec la pratique, des automatismes se créeront et vous prendrez de moins en moins de temps à effectuer chacune des étapes, mais en attendant il faut être patient et rigoureux.</p>

         <footer>
            <br>
            <hr>
            <p>Une question ? Une suggestion ? N'hésitez pas à me <a href="/a_propos.html">contacter</a> pour me communiquer vos remarques.</p>
            <br>
         </footer>
      </div>
   </body>
</html>