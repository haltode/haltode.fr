<!DOCTYPE html>
<html>
   <head>
      <meta charset="utf-8">

      <!-- CSS -->
      <link rel="stylesheet" type="text/css" href="/css/default.css">
      <link rel="stylesheet" type="text/css" href="/css/highlight_theme.css">

      <!-- Icon -->
      <link rel="icon" type="image/x-icon" href="/img/favicon.ico">

      <!-- Syntax highlighting -->
      <script src="/js/highlight.pack.js"></script>
      <script>hljs.initHighlightingOnLoad();</script>

      <!-- Renders LaTeX expression -->
      <script type="text/x-mathjax-config">
         MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
      </script>
      <script type="text/javascript" async 
              src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">
      </script>

      <title>Dichotomie - napnac</title>
   </head>

   <body>
      <div id="page">
         <header>
            <div id="menu">
	       <ul>
		  <li><a href="/"><img src="/img/logo.png" alt="Logo du site" height="80" width="80"></a></li>
		  <li><a href="/">Accueil</a></li>
		  <li><a href="/articles.html">Articles</a></li>
		  <li><a href="/projets.html">Projets</a></li>
		  <li><a href="/a_propos.html">A propos</a></li>
	       </ul>
	    </div>
	 </header>


<h1>Dichotomie</h1>

<p>Publié le : 28/06/2014<br><i>Modifié le : 14/01/2016</i></p>
<div class="toc">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#principe-de-la-dichotomie">Principe de la dichotomie</a></li>
<li><a href="#exemple">Exemple</a></li>
<li><a href="#pseudo-code">Pseudo-code</a></li>
<li><a href="#complexite">Complexité</a></li>
<li><a href="#implementation">Implémentation</a><ul>
<li><a href="#recursif">Récursif</a></li>
<li><a href="#iteratif">Itératif</a></li>
<li><a href="#cc">C/C++</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
</div>
<h2 id="introduction">Introduction</h2>
<p>Si je vous donne un annuaire téléphonique contenant plusieurs milliers de coordonnées, et que je vous demande de trouver une personne, normalement en quelques secondes vous y arrivez. Même si je rajoute plusieurs millions de personnes dans l&rsquo;annuaire, vous devriez toujours être capable de repérer n&rsquo;importe qui en moins d&rsquo;une minute. Mais comment faire pour qu&rsquo;un ordinateur nous remplace pour effectuer cette tâche ? Comment concrétiser l&rsquo;algorithme que vous utilisez (sans le savoir) pour qu&rsquo;un ordinateur le comprenne ? Votre cerveau est un outil incroyable qui n&rsquo;aime pas faire des actions répétitives, et il essaiera naturellement de trouver une façon plus rapide de résoudre un problème. Vous n&rsquo;auriez pas idée de commencer par regarder toutes les personnes avec un prénom en &ldquo;A&rdquo; si vous savez que la personne que vous cherchez est &ldquo;Jean&rdquo;. Ce que vous faites plutôt, c&rsquo;est que vous divisez l&rsquo;intervalle de recherche à partir d&rsquo;un résultat, vous ouvrez par exemple une page au hasard qui devrait correspondre à peu près à la lettre que vous cherchez, et vous affinez au fur et à mesure en fonction du mot de la page. Votre méthode se base sur une caractéristique très importante de votre annuaire : il est <strong>trié</strong> par ordre alphabétique.</p>
<p>Jouons à un petit jeu appelé <em>le plus ou moins</em>. Je choisis un nombre entre 1 et 100 et vous devez le deviner en moins de coup possible. A chaque fois que vous me dites un nombre, je vous dis si ce dernier est supérieur ou inférieur à celui que j&rsquo;ai choisi (ou égal si vous avez trouvé).</p>
<p>Vu comme ça, on pourrait se dire qu&rsquo;on a 1 chance sur 100 de tomber sur le bon nombre, mais en réfléchissant bien on peut améliorer nos chances en s&rsquo;aidant de la réponse que je donne à chaque fois (si c&rsquo;est plus ou moins). Je choisis donc mon nombre, et au premier tour vous dites 50, si je vous dis « plus » vous savez que mon nombre sera forcément dans l&rsquo;intervalle de 51 à 100, si je vous dis « moins » il sera dans l&rsquo;intervalle 1 à 49, et si je vous dis égal vous avez trouvé le nombre. On peut continuer d&rsquo;utiliser ce principe pour diviser par deux à chaque fois notre intervalle de recherche jusqu&rsquo;à avoir un seul élément dans notre intervalle, qui est forcément celui que j&rsquo;ai choisi au début du jeu. Cette méthode s&rsquo;appelle la dichotomie, et vous utilisez un algorithme très similaire lorsque vous recherchez une personne dans un annuaire, mais elle ne s&rsquo;applique pas qu&rsquo;à cela, et on la retrouve dans bien d&rsquo;autres domaines.</p>
<h2 id="principe-de-la-dichotomie">Principe de la dichotomie</h2>
<p>La dichotomie (<em>binary search</em> en anglais), est un algorithme de recherche efficace pour trouver un nombre dans un ensemble <strong>trié</strong> (ce point est très important puisque l&rsquo;algorithme repose dessus). La dichotomie utilise le principe du <a href="https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms">diviser pour régner</a> afin de découper notre problème initiale en un sous problème plus petit.</p>
<p>On commence toujours la dichotomie dans un intervalle de recherche, puis à chaque étape on compare notre élément qu&rsquo;on cherche à l&rsquo;élément central de l&rsquo;intervalle :</p>
<ul>
<li>Si l&rsquo;élément qu&rsquo;on cherche est supérieur, on peut continuer de chercher dans la moitié supérieure de l&rsquo;intervalle.</li>
<li>Si l&rsquo;élément est inférieur, on continue de chercher dans la moitié inférieure.</li>
<li>Sinon l&rsquo;élément est égal, on l&rsquo;a donc trouvé et on peut arrêter de chercher.</li>
</ul>
<p>A chaque tour, on actualise notre intervalle de recherche et on recommence les opérations tant qu&rsquo;on n&rsquo;a pas trouvé notre élément.</p>
<h2 id="exemple">Exemple</h2>
<p>Prenons un tableau trié : 1, 8, 15, 42, 99, 160, 380, 512, 678, 952, 1304. Nous cherchons dans ce tableau l&rsquo;emplacement de l&rsquo;élément 512 et nous allons utiliser le principe de la dichotomie pour le trouver :</p>
<p>1, 8, 15, 42, 99, <strong>160</strong>, 380, 512, 678, 952, 1304 : on compare l&rsquo;élément du milieu de l&rsquo;intervalle (c&rsquo;est le premier tour, on commence donc par un intervalle contenant tout le tableau) avec l&rsquo;élément qu&rsquo;on cherche. 512 &gt; 160, donc on peut oublier les éléments avant 160 (compris), pour se concentrer sur la partie supérieure de l&rsquo;intervalle.</p>
<p>380, 512, <strong>678</strong>, 952, 1304 : notre intervalle est donc divisé en deux, et on continue nos opérations. 512 &lt; 678 donc on continue notre recherche dans la partie inférieure de l&rsquo;intervalle.</p>
<p><strong>380</strong>, 512 : 512 &gt; 380, on continue dans la partie supérieure de l&rsquo;intervalle.</p>
<p>512 : notre intervalle ne contient plus qu&rsquo;un seul élément, c&rsquo;est donc forcément celui qu&rsquo;on recherche.</p>
<p>Pour résumé le principe :</p>
<figure><img alt="Exemple de dichotomie" src="/img/algo/recherche/dichotomie/exemple_dichotomie.png" /><figcaption>Exemple de dichotomie</figcaption>
</figure>
<p>L&rsquo;élément en bleu est celui du milieu que l&rsquo;on compare, et ensuite on choisit la bonne portion du tableau (en vert) en fonction de cette comparaison pour couper notre intervalle en deux à chaque tour.</p>
<h2 id="pseudo-code">Pseudo-code</h2>
<p>On peut faire le pseudo-code suivant d&rsquo;un algorithme de la dichotomie :</p>
<pre><code class="nohighlight">dichotomie :

   Tant qu'on n'a pas trouvé l'élément
      Si l'élément est supérieur au milieu
         Réduire l'intervalle à la partie supérieure
      Si l'élément est inférieur au milieu
         Réduire l'intervalle à la partie inférieure
      Sinon
         Arreter la recherche
</code></pre>

<p>Et il est tout à fait possible d&rsquo;écrire cet algorithme sous forme <a href="https://en.wikipedia.org/wiki/Recursion_%28computer_science%29">récursive</a> :</p>
<pre><code class="nohighlight">dichotomie (début, fin) :

   Si la recherche est supérieure au milieu
      Retourner dichotomie(milieu + 1, fin)
   Si la recherche est inférieure au milieu
      Retourner dichotomie(debut, milieu - 1)
   Sinon
      Retourner l'élément au milieu
</code></pre>

<h2 id="complexite">Complexité</h2>
<p>Pour calculer la complexité en temps de la recherche dichotomique, on peut visualiser la décomposition des intervalles grâce à un <a href="/algo/structure/arbre.html">arbre</a> :</p>
<figure><img alt="Calcul de la complexité" src="/img/algo/recherche/dichotomie/calcul_complexite.png" /><figcaption>Calcul de la complexité</figcaption>
</figure>
<p>Chaque opération possible est représentée dans notre arbre, c&rsquo;est-à-dire qu&rsquo;à chaque tour on coupe notre tableau (qu&rsquo;on note $n$) en deux. On voit qu&rsquo;on arrive à une profondeur maximale de l&rsquo;arbre en $\log _2 N$ avec $N$ la taille de notre tableau (pour en savoir plus sur le logarithme : <a href="https://en.wikipedia.org/wiki/Logarithm">lien de la page Wikipédia</a>), la complexité de la recherche dichotomique est donc dans le pire des cas en $O(\log _2 N)$.</p>
<p>Pour vous faire comprendre à quel point cette recherche est efficace, imaginons que vous possédez une bibliothèque numérique de $N$ livres tous triés en fonction du titre par ordre alphabétique. Votre machine sur laquelle vous faites vos recherches de livres est très lente, et peut effectuer uniquement 2000 opérations à la seconde (aujourd&rsquo;hui les ordinateurs classiques peuvent en effectuer plusieurs milliards&hellip;). Si vous implémentez une recherche dichotomique, il vous faudra environ plus de livres qu&rsquo;il n&rsquo;y a de particules dans un billion d&rsquo;univers visible pour que votre machine prenne plus de temps qu&rsquo;un clignement d&rsquo;œil.</p>
<h2 id="implementation">Implémentation</h2>
<p>Dans ces implémentations, je suppose que l&rsquo;élément appartient bien au tableau afin de simplifier le code et de se concentrer sur la recherche dichotomique.</p>
<h3 id="recursif">Récursif</h3>
<p>L&rsquo;implémentation récursive en C de la recherche :</p>
<pre><code class="c">#include &lt;stdio.h&gt;

#define TAILLE_MAX 1000

int tableau[TAILLE_MAX];
int taille;
int recherche;

int dichotomie(int debut, int fin)
{
   int milieu;
   milieu = (debut + fin) / 2;

   if(recherche &gt; tableau[milieu])
      return dichotomie(milieu + 1, fin);
   else if(recherche &lt; tableau[milieu])
      return dichotomie(debut, milieu - 1);
   else
      return milieu;
}

int main(void)
{
   int iTab;

   scanf(&quot;%d\n&quot;, &amp;taille);

   for(iTab = 0; iTab &lt; taille; ++iTab)
      scanf(&quot;%d &quot;, &amp;tableau[iTab]);
   scanf(&quot;\n&quot;);

   scanf(&quot;%d\n&quot;, &amp;recherche);

   printf(&quot;%d\n&quot;, dichotomie(0, taille - 1) + 1);

   return 0;
}
</code></pre>

<p>Si on donne notre tableau en entrée, ainsi que l&rsquo;élément qu&rsquo;on recherche :</p>
<pre><code class="nohighlight">11
1 8 15 42 99 160 380 512 678 952 1304
512
</code></pre>

<p>On obtient bien en sortie :</p>
<pre><code class="nohighlight">8
</code></pre>

<h3 id="iteratif">Itératif</h3>
<p>La version itérative en C :</p>
<pre><code class="c">#include &lt;stdio.h&gt;

#define TAILLE_MAX 1000

int tableau[TAILLE_MAX];
int taille;
int recherche;

int dichotomie(void)
{
   int debut, milieu, fin;

   debut = 0;
   fin = taille - 1;

   do
   {
      milieu = (debut + fin) / 2;

      if(recherche &gt; tableau[milieu])
         debut = milieu + 1;
      else if(recherche &lt; tableau[milieu])
         fin = milieu - 1;
      else
         return milieu;

   } while(tableau[milieu] != recherche);

   return -1;
}

int main(void)
{
   int iTab;

   scanf(&quot;%d\n&quot;, &amp;taille);

   for(iTab = 0; iTab &lt; taille; ++iTab)
      scanf(&quot;%d &quot;, &amp;tableau[iTab]);
   scanf(&quot;\n&quot;);

   scanf(&quot;%d\n&quot;, &amp;recherche);

   printf(&quot;%d\n&quot;, dichotomie() + 1);

   return 0;
}
</code></pre>

<p>Le tableau et l&rsquo;élément recherché :</p>
<pre><code class="nohighlight">11
1 8 15 42 99 160 380 512 678 952 1304
512
</code></pre>

<p>Et la sortie obtenue :</p>
<pre><code class="nohighlight">8
</code></pre>

<h3 id="cc">C/C++</h3>
<p>En C, il existe une fonction <a href="http://www.cplusplus.com/reference/cstdlib/bsearch/"><code>bsearch</code></a> permettant de réaliser une dichotomie.</p>
<p>De même, en C++, la <a href="https://en.wikipedia.org/wiki/Standard_Template_Library">STL</a> (<em>Standard Template Library</em>) implémente des fonctions de recherche dichotomique :</p>
<ul>
<li><a href="http://www.cplusplus.com/reference/algorithm/lower_bound/"><code>lower_bound</code></a></li>
<li><a href="http://www.cplusplus.com/reference/algorithm/upper_bound/"><code>upper_bound</code></a></li>
<li><a href="http://www.cplusplus.com/reference/algorithm/equal_range/"><code>equal_range</code></a></li>
<li><a href="http://www.cplusplus.com/reference/algorithm/binary_search/"><code>binary_search</code></a></li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>Nous avons donc vu que notre dichotomie permet de chercher, de manière générale, un élément dans un ensemble d&rsquo;élément trié extrêmement rapidement en $O(\log _2 N)$. Cet algorithme s&rsquo;applique très bien à des tableaux pouvant contenir différents types de données (entiers, flottants, chaînes de caractères, etc.), mais on le retrouve aussi dans plusieurs autres applications :</p>
<ul>
<li>L&rsquo;optimisation : on utilise la dichotomie dans plusieurs optimisations d&rsquo;algorithmes, comme avec le <a href="/algo/tri/tri_insertion.html">tri par insertion</a> où la recherche dichotomique améliore grandement la complexité en temps.</li>
<li>L&rsquo;étude de fonction monotone : si on connait une fonction mathématique respectant $f(x) \leq f(y)$ avec $x &lt; y$, on peut appliquer une recherche dichotomique (pour l&rsquo;intervalle $[x, y]$) sur les éléments de cette fonction puisqu&rsquo;elle respecte le principe de l&rsquo;algorithme.</li>
<li>Trouver un bug dans son programme : ça peut paraitre surprenant, mais il m&rsquo;arrive d&rsquo;utiliser l&rsquo;idée de la recherche dichotomique pour situer un bug dans mon programme. Notre intervalle de recherche au début est le code entier (on peut commencer par un plus petit intervalle si notre code est très long), et on va chercher à le réduire petit à petit en éliminant des parties que l&rsquo;on considère justes. Finalement, on se retrouve avec un intervalle assez restreint pour trouver l&rsquo;origine du bug et pouvoir ainsi le fixer.</li>
</ul>


         <footer>
            <br>
            <hr>
            <p>Une question ? Une suggestion ? N'hésitez pas à me <a href="/a_propos.html">contacter</a> pour me communiquer vos remarques.</p>
            <br>
         </footer>
      </div>
   </body>
</html>