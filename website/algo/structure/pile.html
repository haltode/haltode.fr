<!DOCTYPE html>
<html>
   <head>
      <meta charset="utf-8">

      <!-- CSS -->
      <link rel="stylesheet" type="text/css" href="/css/default.css">

      <!-- Font/Icon -->
      <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Lato&#38;subset=latin,latin-ext">
      <link rel="icon" type="image/x-icon" href="/img/favicon.ico">

      <!-- Syntax highlighting -->
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/github-gist.min.css">
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script>

      <!-- Renders LaTeX expression -->
      <script type="text/x-mathjax-config">
         MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
      </script>
      <script type="text/javascript" async 
              src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">
      </script>

      <title>Pile - napnac</title>
   </head>

   <body>
      <header>
         <a href="/">
            <img src="/img/logo.png" alt="Logo du site" height="100" width="300">
         </a>
      </header>

      <nav>
         <ul id="main_menu">
            <li><a href="/">Accueil</a></li>
            <li><a href="/articles.html">Articles</a></li>
            <li><a href="/projets.html">Projets</a></li>
            <li><a href="/a_propos.html">A propos</a></li>
         </ul>
      </nav>

      

<a href=""><h1>Pile</h1></a>

<p>Publié le : 08/06/2014</p>
<p>Modifié le : 28/11/2015</p>

<h2>Introduction</h2>
<p>Prenons l&rsquo;exemple d&rsquo;une fonction dans un programme. Cette fonction peut appeler d&rsquo;autres fonctions qui à leurs tours appellent d&rsquo;autres fonctions (qui elles même appellent des fonctions, etc.). Comment savoir et se souvenir de l&rsquo;ordre d&rsquo;appels, de qui appelle qui, et où retourner une fois la fonction appelée terminée ? Une première réponse pourrait être de stocker toutes ces informations dans un simple tableau, mais comment le parcourir ? Où insérer les nouvelles données ? Comment enlever les éléments inutiles (lorsqu&rsquo;une fonction a finie d&rsquo;être exécutée) ?</p>
<p>Toutes ces questions nous amènent à penser qu&rsquo;il nous faut une structure de données organisée, bien définie et qui puisse gérer cette idée d&rsquo;imbrication : la pile.</p>
<h2>Principe de la pile</h2>
<p>Une pile (<em>stack</em> en anglais) est une structure de données de type <strong>LIFO</strong> (<strong>L</strong>ast <strong>I</strong>n <strong>F</strong>irst <strong>O</strong>ut, <em>dernier arrivé premier sorti</em>). Elle fonctionne exactement comme une pile d’assiettes :</p>
<ul>
<li>Quand on ajoute une assiette sur la pile on l’ajoute en haut.</li>
<li>Quand on enlève une assiette on enlève celle du haut pour ne pas faire tomber le reste.</li>
</ul>
<p>C’est le principe LIFO, lorsqu’on ajoute un élément sur une pile il est en haut, et lorsqu’on retire un élément on prend le dernier ajouté (celui tout en haut).</p>
<p><img alt="Exemple de représentation d'une pile" src="/img/algo/structure/pile/exemple_pile.png" /></p>
<p>L’action d’ajouter un élément dans la pile est appelée : <strong>empiler</strong> (ou <em>push</em> en anglais) :</p>
<p><img alt="Un nouvel élément est empilé" src="/img/algo/structure/pile/exemple_ajout.png" /></p>
<p>L’action d’enlever un élément de la pile est appelée : <strong>dépiler</strong> (ou <em>pop</em> en anglais) :</p>
<p><img alt="Un élément est dépilé" src="/img/algo/structure/pile/exemple_suppression.png" /></p>
<p>Pour représenter une pile, je vais vous présenter deux moyens :</p>
<ul>
<li>Avec une <a href="/algo/structure/liste_chainee.html">liste chaînée</a>.</li>
<li>Avec un tableau ainsi qu’un indice nous indiquant le prochain élément libre dans la pile. Cet indice est appelé pointeur de pile (ou <em>stack pointer</em> en anglais, souvent abrégé <em>SP</em>).</li>
</ul>
<h2>Quelques fonctions pour manipuler une pile</h2>
<p>Comme pour une liste chaînée, il existe différentes fonctions de bases permettant de manipuler une pile.</p>
<h3>Avec une liste chaînée</h3>
<pre><code class="nohighlight">créerPile :
   Initialiser la pile à NULL
supprimerPile :
   Pour chaque élément de la pile
      Supprimer l'élément actuel

empiler (élément) :
   Faire pointer le haut de la pile vers le nouvel élément
dépiler :
   Sauvegarder les données de l'élément en haut de la pile
   Supprimer l'élément en haut
   Faire pointer le haut de la pile vers NULL
   Retourner les données sauvegardées

estVide :
   Si le premier élément de la pile est NULL
      Retourner vrai
   Sinon
      Retourner faux
</code></pre>

<h3>Avec un tableau</h3>
<pre><code class="nohighlight">créerPile :
   Créer un tableau d'une taille fixe et suffisamment grand pour la pile
   Initialiser le pointeur de pile (PP) à 0
supprimerPile :
   Supprimer le tableau

empiler (élément) :
   Affecter les données du nouvel élément à la case d'index PP du tableau
   Incrémenter le PP
dépiler :
   Décrémenter le PP
   Retourner les données de l'élément d'index PP du tableau

estVide :
   Si PP = 0
      Retourner vrai
   Sinon 
      Retourner faux
</code></pre>

<h2>Complexité</h2>
<p>Soit $N$ le nombre d&rsquo;éléments de la pile.</p>
<ul>
<li><code>créerPile</code> : $O(1)$</li>
<li><code>supprimerPile</code> : $O(N)$</li>
<li><code>empiler</code> : $O(1)$</li>
<li><code>dépiler</code> : $O(1)$</li>
<li><code>estVide</code> : $O(1)$</li>
</ul>
<h2>Implémentation</h2>
<h3>Liste chaînée</h3>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct Noeud Noeud;
struct Noeud
{
   Noeud *suivant;
   int donnee;
};

typedef Noeud *Pile;

void creerPile(Pile *pile)
{
   *pile = NULL;
}

void supprimerPile(Pile *pile)
{
   Noeud *iPile;

   for(iPile = *pile; iPile != NULL; ) {
      Noeud *temp;

      temp = iPile-&gt;suivant;
      free(iPile);
      iPile = temp;
   }
}

void empiler(Pile *pile, int donnee)
{
   Noeud *nouveau;

   nouveau = malloc(sizeof(Noeud));
   nouveau-&gt;suivant = *pile;
   nouveau-&gt;donnee = donnee;

   *pile = nouveau;
}

int depiler(Pile *pile)
{
   Noeud *temp;
   int donnee;

   temp = (*pile)-&gt;suivant;
   donnee = (*pile)-&gt;donnee;
   free(*pile);
   *pile = temp;

   return donnee;
}

int estVide(Pile *pile)
{
   if(*pile == NULL)
      return 1;
   else
      return 0;
}

int main(void)
{
   Pile pile;

   creerPile(&amp;pile);

   empiler(&amp;pile, 42);
   // 42
   empiler(&amp;pile, 9);
   // 9
   // 42

   int retour = depiler(&amp;pile);
   // retour = 9

   supprimerPile(&amp;pile);

   return 0;
}
</code></pre>

<p>Le code est simple et ne nécessite pas d’explication, si besoin je vous invite à relire l&rsquo;article sur les <a href="/algo/structure/liste_chainee.html">listes chaînées</a> pour bien comprendre le code.</p>
<h3>Tableau</h3>
<pre><code class="c">#include &lt;stdio.h&gt;

#define TAILLE_MAX 256

int pile[TAILLE_MAX];
int PP;

void creerPile(void)
{
   PP = 0;
}

void empiler(int donnee)
{
   pile[PP] = donnee;
   ++PP;
}

int depiler(void)
{
   --PP;
   return pile[PP];
}

int estVidePile(void)
{
   if(PP == 0)
      return 1;
   else
      return 0;
}

int main(void)
{
   creerPile();

   empiler(42);
   // 42
   empiler(9);
   // 9
   // 42

   int retour = depiler();
   // retour = 9

   return 0;
}
</code></pre>

<p>Cette implémentation est facile à comprendre et à utiliser.</p>
<h3>STL</h3>
<p>Si vous programmez en C++, la <a href="https://en.wikipedia.org/wiki/Standard_Template_Library">STL</a> (<em>Standard Template Library</em>) fournit une implémentation et des fonctions permettant de manipuler une pile : <a href="http://www.cplusplus.com/reference/stack/stack/">http://www.cplusplus.com/reference/stack/stack/</a></p>
<h2>Conclusion</h2>
<p>La pile est donc une structure de données facile à implémenter et peut être pratique dans de nombreux domaines : </p>
<ul>
<li>Dans un éditeur : quand vous écrivez votre prochain article sur votre éditeur préféré, et que vous ne cessez de faire des <kbd>ctrl</kbd>+<kbd>z</kbd> et <kbd>ctrl</kbd>+<kbd>y</kbd> pour revenir en arrière/avant, vous utilisez en réalité une pile. Chaque opération va être empilée pour garder l&rsquo;ordre dans lequel vous les avez réalisées, et vous pouvez ainsi facilement parcourir la pile des opérations pour vous retrouver à tel moment précis de votre édition.</li>
<li>Lors d&rsquo;un appel de fonction : à chaque fois que vous appelez une fonction dans votre programme, la pile d&rsquo;exécution (ou <a href="https://en.wikipedia.org/wiki/Call_stack">pile d&rsquo;appel</a>) empile les informations à propos de l&rsquo;endroit où vous réalisez l&rsquo;appel pour se souvenir où revenir à la fin de la fonction appelée.</li>
<li>Pour évaluer des expressions : dans certains cas, une pile peut être utilisée pour évaluer des expressions (mathématiques ou syntaxiques). Par exemple, si vous devez évaluer une expression en notation polonaise inverse (<a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation">NPI</a>), une pile est indispensable pour calculer l&rsquo;expression au fur et à mesure des opérations (quand vous rencontrez un nombre vous l&rsquo;empilez, quand vous rencontrez un opérateur vous dépilez les deux derniers éléments, et vous empilez le résultat).</li>
<li>Plusieurs <a href="https://en.wikipedia.org/wiki/Virtual_machine">machines virtuelles</a> sont implémentées sur le principe d&rsquo;une pile, par exemple celle de Java. Si vous voulez en savoir plus à ce sujet, cet article explique très bien le principe de machine virtuelle et les différentes implémentations possibles : <a href="https://markfaction.wordpress.com/2012/07/15/stack-based-vs-register-based-virtual-machine-architecture-and-the-dalvik-vm/">https://markfaction.wordpress.com/2012/07/15/stack-based-vs-register-based-virtual-machine-architecture-and-the-dalvik-vm/</a></li>
</ul>



      <footer>
         <br>
         <hr>
         <p>Une question ? Une suggestion ? N'hésitez pas à me <a href="/a_propos.html">contacter</a> pour me communiquer vos remarques.</p>
         <br>
      </footer>

   </body>
</html>