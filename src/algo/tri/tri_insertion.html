<!DOCTYPE html>
<html>
   <head>
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato&#38;subset=latin,latin-ext" type="text/css" />
      <link rel="icon" type="image/x-icon" href="/static/img/favicon.ico">
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/github-gist.min.css">
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script>
      <!-- CSS -->
<style>
body {
   font-family: "Helvetica Neue", 'Lato', Helvetica, sans-serif;
   max-width: 1000px;
   margin: 0 auto;
   position: relative;
   width: 95%;
   line-height: 1.5;
}

/* ---- Titles ---- */

h1 {
   padding-top: 2%;
   padding-bottom: 2%;
   color: #DE4834;
}

h2, h3, h4, h5, h6 {
   padding-top: 1%;
   padding-bottom: 1%;
   color: #DE4834;
}

/* ---- Link ---- */

a {
   text-decoration: none;
   color: #2E64FE;
}

/* ---- List (+ main menu list) ---- */

ul {
   padding-left: 30px;
}

#main_menu {
   list-style: none;
   margin: 0;
   padding: 0;
   text-align: center;
}
#main_menu li {
   display: inline;
   margin-right: 1px;
}
#main_menu li a {
   line-height: 1em;
   padding: 4px 20px;
   text-align: center;
}
#main_menu li a:hover, #main_menu li a:active {
   text-decoration: underline;
}

/* ---- Tables (same look as from github markdown layout) ---- */

table {
   display: block;
   width: 100%;
   overflow: auto;
   word-break: normal;
   word-break: keep-all;
   border-collapse: collapse;
   border-spacing: 0;
   margin-top: 0;
   margin-bottom: 16px;
}

table th {
   font-weight: bold;
}

table th,
table td {
   padding: 6px 13px;
   border: 1px solid #ddd;
}

table tr {
   background-color: #fff;
   border-top: 1px solid #ccc;
}

table tr:nth-child(2n) {
   background-color: #f8f8f8;
}

/* ---- Image and caption ---- */

.figure {
   text-align: center;
}

.caption {
   font-style: italic;
   text-align: center;
}

/* ---- Temporary css ---- */

.pret {
   background-color: #00CC00;
   display: inline;
}

.relire {
   background-color: #FF9900;
   display: inline;
}

.encours {
   background-color: #3366CC;
   display: inline;
}

.faire {
   background-color: #FF0000;
   display: inline;
}
</style>
      <!---- ---->
      <title>Tri par insertion - NapNac</title>
   </head>

   <body>

      <!-- Javascript -->
<script type="text/javascript">
    function toggle_visibility(id) {
       var element = document.getElementById(id);
       if(element.style.display == 'block')
          element.style.display = 'none';
       else
          element.style.display = 'block';
    }
</script>
      <!---- ---->

      <header>
         <a href="/">
            <img src="/static/img/logo.png" alt="Logo du site" height="100" width="300">
         </a>

      </header>

      <nav>
         <ul id="main_menu">
            <li><a href="/">Accueil</a></li>
            <li><a href="/articles.html">Articles</a></li>
            <li><a href="/projets.html">Projets</a></li>
            <li><a href="/a_propos.html">A propos</a></li>
         </ul>
      </nav>

      <!-- Page/Article -->

<a href=""><h1 id="tri-par-insertion">Tri par insertion</h1></a>
<p>Publi&#233; le : 01/05/2014<br />
<em>Modifi&#233; le : 15/11/2015</em></p>
<ul id="summary">
<li><a href="#introduction">Introduction</a></li>
<li><a href="#principe-de-lalgorithme">Principe de l&#8217;algorithme</a></li>
<li><a href="#exemple">Exemple</a></li>
<li><a href="#pseudo-code">Pseudo-code</a></li>
<li><a href="#complexit&#233;">Complexit&#233;</a></li>
<li><a href="#impl&#233;mentation">Impl&#233;mentation</a></li>
<li><a href="#am&#233;liorations-et-variantes">Am&#233;liorations et variantes</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>Le tri par insertion (<em>insertion sort</em> en anglais) est un algorithme de tri par comparaison simple, et intuitif mais toujours avec une complexit&#233; en <em>O(N&#178;)</em>. Vous l&#8217;avez sans doute d&#233;j&#224; utilis&#233; sans m&#234;me vous en rendre compte : lorsque vous triez des cartes par exemple. C&#8217;est un algorithme de tri <a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability">stable</a>, <a href="https://en.wikipedia.org/wiki/In-place_algorithm">en place</a>, et le plus rapide en pratique sur une entr&#233;e de petite taille.</p>
<h2 id="principe-de-lalgorithme">Principe de l&#8217;algorithme</h2>
<p>Le principe du tri par insertion est de trier les &#233;l&#233;ments du tableau comme avec des cartes :</p>
<ul>
<li>On prend nos cartes m&#233;lang&#233;es dans notre main.</li>
<li>On cr&#233;e deux ensembles de carte, l&#8217;un correspond &#224; l&#8217;ensemble de carte tri&#233;e, l&#8217;autre contient l&#8217;ensemble des cartes restantes (non tri&#233;es).</li>
<li>On prend au fur et &#224; mesure, une carte dans l&#8217;ensemble non tri&#233; et on l&#8217;ins&#232;re &#224; sa bonne place dans l&#8217;ensemble de carte tri&#233;e.</li>
<li>On r&#233;p&#232;te cette op&#233;ration tant qu&#8217;il y a des cartes dans l&#8217;ensemble non tri&#233;.</li>
</ul>
<h2 id="exemple">Exemple</h2>
<p>Prenons comme exemple la suite de nombre suivante : 9, 2, 7, 1 que l&#8217;on veut trier en ordre croissant avec l&#8217;algorithme du tri par insertion :</p>
<p><em>1er tour</em> :</p>
<p>9 | <strong>2</strong>, 7, 1 -&gt; &#224; gauche la partie tri&#233;e du tableau (le premier &#233;l&#233;ment est consid&#233;r&#233; comme tri&#233; puisqu'il est seul dans cette partie), &#224; droite la partie non tri&#233;e. On prend le premier &#233;l&#233;ment de la partie non tri&#233;e, 2, et on l'ins&#232;re &#224; sa place dans la partie tri&#233;e, c'est-&#224;-dire &#224; gauche de 9.</p>
<p><em>2&#232;me tour</em> :</p>
<p>2, 9 | <strong>7</strong>, 1 -&gt; on prend 7, et on le place entre 2 et 9 dans la partie tri&#233;e.</p>
<p><em>3&#232;me tour</em> :</p>
<p>2, 7, 9 | <strong>1</strong> -&gt; on continue avec 1 que l&#8217;on place au d&#233;but de la premi&#232;re partie.</p>
<p>1, 2, 7, 9</p>
<p>Pour ins&#233;rer un &#233;l&#233;ment dans la partie tri&#233;e, on parcourt de droite &#224; gauche tant que l'&#233;l&#233;ment est plus grand que celui que l'on souhaite ins&#233;rer.</p>
<p>Pour r&#233;sumer l'id&#233;e de l'algorithme :</p>
<div class="figure">
<img src="/static/img/algo/tri/tri_insertion/exemple_tri.png" alt="Exemple de tri par insertion" />
<p class="caption">Exemple de tri par insertion</p>
</div>
<p>La partie verte du tableau est la partie tri&#233;e, l'&#233;l&#233;ment en bleu est le prochain &#233;l&#233;ment non tri&#233; &#224; placer et la partie blanche est la partie non tri&#233;e.</p>
<h2 id="pseudo-code">Pseudo-code</h2>
<pre class="nohighlight"><code>triInsertion :
   
   Pour chaque &#233;l&#233;ment non tri&#233; du tableau
      D&#233;caler vers la droite dans la partie tri&#233;e, les &#233;l&#233;ments sup&#233;rieurs &#224; 
      celui que l&#39;on souhaite ins&#233;rer
      Placer notre &#233;l&#233;ment &#224; sa place dans le trou ainsi cr&#233;&#233;</code></pre>
<h2 id="complexit&#233;">Complexit&#233;</h2>
<p>L&#8217;algorithme du tri par insertion a une complexit&#233; de <em>O(N&#178;)</em> :</p>
<ul>
<li>La premi&#232;re boucle parcourt <em>N &#8211; 1</em> tours, ici on notera plut&#244;t <em>N</em> tours car le <em>&#8211; 1</em> n&#8217;est pas tr&#232;s important.</li>
<li>D&#233;caler les &#233;l&#233;ments de la partie tri&#233;e prend <em>i</em> tours (avec <em>i</em> variant de 0 &#224; <em>N</em>).</li>
</ul>
<p>Dans le pire des cas on parcourt <em>N * N</em> tours, donc le tri par insertion a une complexit&#233; en temps de <em>O(N&#178;)</em>.</p>
<h2 id="impl&#233;mentation">Impl&#233;mentation</h2>
<p>L&#8217;impl&#233;mentation en C du tri par insertion :</p>
<p>main.c :</p>
<h2 id="am&#233;liorations-et-variantes">Am&#233;liorations et variantes</h2>
<h3 id="utiliser-des-listes-cha&#238;n&#233;es">Utiliser des listes cha&#238;n&#233;es</h3>
<p>Le tri par insertion doit d&#233;caler de nombreuses fois le tableau pour ins&#233;rer un &#233;l&#233;ment, ce qui est une op&#233;ration lourde et inutile puisqu'on peut utiliser des <a href="/algo/structure/liste_chainee.html">listes cha&#238;n&#233;es</a> afin de contrer ce probl&#232;me. Les listes cha&#238;n&#233;es permettent d'ins&#233;rer notre &#233;l&#233;ment de fa&#231;on simple et plus rapide, cependant comme il faut toujours calculer o&#249; placer cet &#233;l&#233;ment, la complexit&#233; reste quadratique.</p>
<h3 id="tri-shell">Tri Shell</h3>
<p>Le tri par insertion est un algorithme de tri tr&#232;s efficace sur des entr&#233;es quasi tri&#233;, et on peut utiliser cette propri&#233;t&#233; int&#233;ressante du tri pour l'am&#233;liorer. En effet, le tri Shell (<em>Shell sort</em> en anglais, du nom de son inventeur Donald L. Shell) va &#233;changer certaines valeurs du tableau &#224; un &#233;cart bien pr&#233;cis afin de le rendre dans la plupart des cas presque tri&#233;. Une fois qu'on a ce tableau r&#233;-arrang&#233;, on lui applique notre tri par insertion classique, mais ce dernier sera bien plus rapide gr&#226;ce &#224; notre premi&#232;re &#233;tape.</p>
<p>Pour calculer cet &#233;cart, on utilise cette formule :</p>
<p><em>Ecart(N) = 3 * Ecart(N - 1) + 1</em><br />
avec <em>Ecart(0) = 0</em></p>
<p>Par exemple, on souhaite trier la suite de nombres : 5, 8, 2, 9, 1, 3 dans l'ordre croissant :</p>
<p>On calcule les &#233;carts tant que le r&#233;sultat est inf&#233;rieur &#224; la taille du tableau.</p>
<p><em>Ecart(0) = 0</em><br />
<em>Ecart(1) = 3 * Ecart(0) + 1 = 3 * 0 + 1 = 1</em><br />
<em>Ecart(2) = 3 * Ecart(1) + 1 = 3 * 1 + 1 = 4</em><br />
<em>Ecart(3) = 3 * Ecart(2) + 1 = 3 * 4 + 1 = 13</em></p>
<p>On a donc deux &#233;carts que l'on peut utiliser : 1 et 4 (13 &#233;tant sup&#233;rieur au nombre d'&#233;l&#233;ments du tableau). Cependant appliquer un &#233;cart de 1 revient &#224; faire un tri par insertion normal, on utilisera donc uniquement l'&#233;cart de 4 dans cet exemple.</p>
<p>On compare ensuite chaque &#233;l&#233;ment du tableau &#233;cart&#233; de quatre &#233;l&#233;ments :</p>
<p><strong>5</strong>, 8, 2, 9, <strong>1</strong>, 3 -&gt; on voit que 5 est sup&#233;rieur &#224; 1, on les &#233;change.<br />
1, <strong>8</strong>, 2, 9, 5, <strong>3</strong> -&gt; on voit que 8 est sup&#233;rieur &#224; 3, on les &#233;change.<br />
1, 3, 2, 9, 5, 8 -&gt; plus d&#8217;&#233;change possible avec un &#233;cart de 4.</p>
<p>On r&#233;p&#232;te cette op&#233;ration tant qu'il nous reste des &#233;carts, dans notre cas c'est la fin de la premi&#232;re &#233;tape du tri. Maintenant notre tableau est r&#233;organis&#233; et quasi tri&#233;, on peut donc lui appliquer un tri par insertion.</p>
<p>Malheureusement, le tri Shell reste avec une complexit&#233; quadratique dans le pire des cas, mais est une bonne am&#233;lioration de mani&#232;re g&#233;n&#233;ral.</p>
<h3 id="dichotomie">Dichotomie</h3>
<p>Le tri par insertion est bas&#233; sur le fait que le tableau est coup&#233; en deux parties, l&#8217;une tri&#233;e (celle qui nous int&#233;resse) et l&#8217;autre non tri&#233;e. On peut am&#233;liorer la recherche de l'emplacement o&#249; ins&#233;rer notre &#233;l&#233;ment gr&#226;ce &#224; la <a href="/algo/recherche/dichotomie.html">dichotomie</a> (c&#8217;est un algorithme de recherche efficace dans un ensemble d&#8217;objet d&#233;j&#224; tri&#233;, ce qui est parfait pour notre cas).</p>
<p>Cette recherche consiste &#224; utiliser la m&#233;thode du <a href="https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms">diviser pour r&#233;gner</a>, on cherche l&#8217;emplacement pour notre &#233;l&#233;ment &#224; l&#8217;aide d&#8217;intervalles. Notre intervalle de d&#233;part est : <em>d&#233;but partie tri&#233;e</em> -&gt; <em>fin partie tri&#233;e</em> :</p>
<ul>
<li>On teste si l&#8217;&#233;l&#233;ment situ&#233; au milieu de notre intervalle est inf&#233;rieur &#224; l&#8217;&#233;l&#233;ment que l&#8217;on veut ins&#233;rer.</li>
<li>Si c&#8217;est le cas on recommence l&#8217;op&#233;ration mais cette fois ci avec cet intervalle : <em>milieu ancien inter</em> -&gt; <em>fin ancien inter</em>.</li>
<li>Sinon on recommence mais avec l&#8217;intervalle suivant : <em>d&#233;but ancien inter</em> -&gt; <em>milieu ancien inter</em>.</li>
</ul>
<p>Une fois que l&#8217;intervalle ne contient plus qu&#8217;un seul &#233;l&#233;ment, on a trouv&#233; l&#8217;emplacement o&#249; ins&#233;rer l'&#233;l&#233;ment &#224; sa place. Gr&#226;ce &#224; cette am&#233;lioration, l&#8217;algorithme du tri par insertion a pour complexit&#233; <em>O(N * log N)</em>.</p>
<p><em>J'ai expliqu&#233; ici tr&#232;s rapidement le principe de la dichotomie, j'en parle plus longuement dans mon article &#224; ce propos donc si vous n'avez pas tout suivi, je vous conseille d'aller le lire pour bien saisir ce concept fondamental en algorithmie.</em></p>
<h2 id="conclusion">Conclusion</h2>
<p>L'algorithme du tri par insertion est simple et relativement intuitif, m&#234;me s'il a une complexit&#233; en temps quadratique. Cet algorithme de tri reste tr&#232;s utilis&#233; &#224; cause de ses facult&#233;s &#224; s'ex&#233;cuter en temps quasi lin&#233;aire sur des entr&#233;es d&#233;j&#224; tri&#233;e, et de mani&#232;re tr&#232;s efficace sur de petites entr&#233;es en g&#233;n&#233;ral (souvent plus performant, dans ce cas, que des algorithmes de tri en <em>O(N * log N)</em>).</p>
 
      <!-- ------------ -->

      <footer>
         <br>
         <p style="text-align: center;"><a href="https://sous-surveillance.fr"><img style="border: 0;" 
         src="/static/img/PJL_banner.png" alt="Non à la loi renseignement" 
         title="Non à la loi renseignement" height="60" width="468" /></a></p>
      </footer>
   </body>
</html>
