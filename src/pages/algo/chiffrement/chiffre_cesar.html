<!DOCTYPE html>
<html>
   <head>
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato&#38;subset=latin,latin-ext" type="text/css" />
      <link rel="icon" type="image/x-icon" href="//static.napnac.ga/img/favicon.ico">
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/github-gist.min.css">

      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script>

      <!-- CSS -->
<style>
body {
   font-family: "Helvetica Neue", 'Lato', Helvetica, sans-serif;
   max-width: 1000px;
   margin: 0 auto;
   position: relative;
   width: 95%;
   line-height: 1.5;
}

/* ---- Titles ---- */

h1 {
   padding-top: 2%;
   padding-bottom: 2%;
   color: #DE4834;
}

h2, h3, h4, h5, h6 {
   padding-top: 1%;
   padding-bottom: 1%;
   color: #DE4834;
}

/* ---- Link ---- */

a {
   text-decoration: none;
   color: #2E64FE;
}

/* ---- List (+ main menu list) ---- */

ul {
   padding-left: 30px;
}

#main_menu {
   list-style: none;
   margin: 0;
   padding: 0;
   text-align: center;
}
#main_menu li {
   display: inline;
   margin-right: 1px;
}
#main_menu li a {
   line-height: 1em;
   padding: 4px 20px;
   text-align: center;
}
#main_menu li a:hover, #main_menu li a:active {
   text-decoration: underline;
}

/* ---- Tables (same look as from github markdown layout) ---- */

table {
   display: block;
   width: 100%;
   overflow: auto;
   word-break: normal;
   word-break: keep-all;
   border-collapse: collapse;
   border-spacing: 0;
   margin-top: 0;
   margin-bottom: 16px;
}

table th {
   font-weight: bold;
}

table th,
table td {
   padding: 6px 13px;
   border: 1px solid #ddd;
}

table tr {
   background-color: #fff;
   border-top: 1px solid #ccc;
}

table tr:nth-child(2n) {
   background-color: #f8f8f8;
}

/* ---- Image and caption ---- */

.figure {
   text-align: center;
}

.caption {
   font-style: italic;
   text-align: center;
}

/* ---- Summary ---- */

#summary {
   width: 70%;
   text-align: justify;
   line-height: 1.6;
}

/* ---- Temporary css ---- */

.pret {
   background-color: #00CC00;
   display: inline;
}

.relire {
   background-color: #FF9900;
   display: inline;
}

.encours {
   background-color: #3366CC;
   display: inline;
}

.faire {
   background-color: #FF0000;
   display: inline;
}
</style>
      <!---- ---->

      <title>Chiffre de César - NapNac</title>
   </head>

   <body>

      <!-- Javascript -->
<script type="text/javascript">
function toggle_visibility(id) {
   var element = document.getElementById(id);
   if(element.style.display == 'block')
      element.style.display = 'none';
   else
      element.style.display = 'block';
}
</script>
      <!---- ---->

      <header>
         <a href="/">
            <img src="//static.napnac.ga/img/logo.png" alt="Logo du site" height="100" width="300">
         </a>

      </header>

      <nav>
         <ul id="main_menu">
            <li><a href="/">Accueil</a></li>
            <li><a href="/articles.html">Articles</a></li>
            <li><a href="/projets.html">Projets</a></li>
            <li><a href="/a_propos.html">A propos</a></li>
         </ul>
      </nav>

      <!-- Page/Article -->

<a href=""><h1 id="chiffre-de-c&#233;sar">Chiffre de C&#233;sar</h1></a>
<p>Publi&#233; le : 21/05/2014<br />
<em>Modifi&#233; le : 12/12/2015</em></p>
<ul id="summary">
<li><a href="#introduction">Introduction</a></li>
<li><a href="#principe-de-lalgorithme">Principe de l&#8217;algorithme</a></li>
<li><a href="#exemple">Exemple</a></li>
<li><a href="#pseudo-code">Pseudo-code</a></li>
<li><a href="#impl&#233;mentation">Impl&#233;mentation</a></li>
<li><a href="#cassage">Cassage</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>TODO : faire intro</p>
<p>Les premiers algorithmes de chiffrement ne datent pas de Jules C&#233;sar, mais ce dernier</p>
<p>Le chiffre de C&#233;sar (aussi appel&#233; <em>chiffrement par d&#233;calage</em>) est un algorithme de chiffrement <strong>sym&#233;trique</strong> tr&#232;s simple utilis&#233; par Jules C&#233;sar pour communiquer des messages secrets. Cet algorithme n&#8217;est pas du tout s&#233;curis&#233; pour deux raisons que nous aborderons apr&#232;s avoir vu le chiffrement et le d&#233;chiffrement.</p>
<h2 id="principe-de-lalgorithme">Principe de l&#8217;algorithme</h2>
<p>Le chiffre de C&#233;sar (aussi appel&#233; <em>chiffrement par d&#233;calage</em>) utilise une <a href="https://en.wikipedia.org/wiki/Substitution_cipher">substitution mono-alphab&#233;tique</a> pour chiffrer et d&#233;chiffrer un message, c&#8217;est-&#224;-dire que l&#8217;on d&#233;cale de <em>x</em> rangs vers la droite dans l&#8217;alphabet la lettre du message lors du chiffrement, et de <em>x</em> rangs vers la gauche lors du d&#233;chiffrement. On appelle <em>x</em> la <strong>cl&#233; de chiffrement</strong>, et cette derni&#232;re doit &#234;tre la m&#234;me pour le chiffrement et le d&#233;chiffrement car le chiffre de C&#233;sar est un <a href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm">chiffrement sym&#233;trique</a>.</p>
<h2 id="exemple">Exemple</h2>
<p>Prenons le mot &quot;Linux&quot;, que l&#8217;on va chiffrer puis d&#233;chiffrer &#224; l&#8217;aide du chiffre de C&#233;sar et avec une cl&#233; de chiffrement de 2.</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/chiffrement/chiffre_cesar/exemple_chiffrement.png" alt="Exemple de chiffrement" />
<p class="caption">Exemple de chiffrement</p>
</div>
<p>On a deux alphabets repr&#233;sent&#233;s, un normal et un autre d&#233;cal&#233; de 2 rangs vers la droite (car c'est notre cl&#233; de chiffrement). Cette repr&#233;sentation permet de facilement visualiser le d&#233;calage puisqu'il suffit de regarder la case correspondante dans le nouvel alphabet pour chiffrer notre message. Chaque lettre (repr&#233;sent&#233;e en bleu) de notre message en clair aura donc une lettre &#233;quivalente (repr&#233;sent&#233;e en vert) dans le nouvel alphabet.</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/chiffrement/chiffre_cesar/exemple_dechiffrement.png" alt="Exemple de d&#233;chiffrement" />
<p class="caption">Exemple de d&#233;chiffrement</p>
</div>
<p>De la m&#234;me mani&#232;re, pour le d&#233;chiffrement il suffit de faire correspondre les lettres de notre nouvel alphabet, &#224; celui normal afin de lire notre message chiffr&#233;.</p>
<h2 id="pseudo-code">Pseudo-code</h2>
<p>Le pseudo-code du chiffre de C&#233;sar est tr&#232;s simple :</p>
<pre class="nohighlight"><code>chiffrer :

   Pour chaque caract&#232;re du message
      Si c&#39;est une lettre
         D&#233;caler cette lettre de x rangs vers la droite

d&#233;chiffrer :

   Pour chaque caract&#232;re du message
      Si c&#39;est une lettre
         D&#233;caler cette lettre de x rangs vers la gauche </code></pre>
<p>Il faut cependant faire attention &#224; une chose, lorsqu'on d&#233;passe la lettre Z pendant le chiffrement, il faut pouvoir revenir au d&#233;but de l'alphabet, comme une sorte de boucle et inversement avec la lettre A lors du d&#233;chiffrement.</p>
<h2 id="impl&#233;mentation">Impl&#233;mentation</h2>
<p>Une impl&#233;mentation en C du chiffre de C&#233;sar :</p>
<a href="javascript:toggle_visibility('chiffre_cesar.c');">chiffre_cesar.c</a>
<div id="chiffre_cesar.c" style="display: none;">
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;ctype.h&gt;</span>

<span class="dt">char</span> message[] = <span class="st">&quot;Linux&quot;</span>;
<span class="dt">int</span> cle = <span class="dv">2</span>;

<span class="dt">void</span> chiffrement(<span class="dt">void</span>)
{
   <span class="dt">int</span> indexTab;

   <span class="kw">for</span>(indexTab = <span class="dv">0</span>; message[indexTab] != &#39;\<span class="dv">0</span>&#39;; ++indexTab)
   {
      <span class="kw">if</span>(isupper(message[indexTab]))
      {
         message[indexTab] -= &#39;A&#39;;
         message[indexTab] = ((message[indexTab] + cle) % <span class="dv">26</span> + <span class="dv">26</span>) % <span class="dv">26</span>;
         message[indexTab] += &#39;A&#39;;
      }
      <span class="kw">else</span> <span class="kw">if</span>(islower(message[indexTab]))
      {
         message[indexTab] -= &#39;a&#39;;
         message[indexTab] = ((message[indexTab] + cle) % <span class="dv">26</span> + <span class="dv">26</span>) % <span class="dv">26</span>;
         message[indexTab] += &#39;a&#39;;
      }
   }
}

<span class="dt">void</span> dechiffrement(<span class="dt">void</span>)
{
   <span class="dt">int</span> indexTab;

   <span class="kw">for</span>(indexTab = <span class="dv">0</span>; message[indexTab] != &#39;\<span class="dv">0</span>&#39;; ++indexTab)
   {
      <span class="kw">if</span>(isupper(message[indexTab]))
      {
         message[indexTab] -= &#39;A&#39;;
         message[indexTab] = ((message[indexTab] - cle) % <span class="dv">26</span> + <span class="dv">26</span>) % <span class="dv">26</span>;
         message[indexTab] += &#39;A&#39;;
      }
      <span class="kw">else</span> <span class="kw">if</span>(islower(message[indexTab]))
      {
         message[indexTab] -= &#39;a&#39;;
         message[indexTab] = ((message[indexTab] - cle) % <span class="dv">26</span> + <span class="dv">26</span>) % <span class="dv">26</span>;
         message[indexTab] += &#39;a&#39;;
      }
   }
}

<span class="dt">int</span> main(<span class="dt">void</span>)
{
   printf(<span class="st">&quot;%s</span><span class="ch">\n</span><span class="st">&quot;</span>, message);

   chiffrement();
   printf(<span class="st">&quot;%s</span><span class="ch">\n</span><span class="st">&quot;</span>, message);

   dechiffrement();
   printf(<span class="st">&quot;%s</span><span class="ch">\n</span><span class="st">&quot;</span>, message);

   <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</div>
<p>TODO : explication code</p>
<h2 id="cassage">Cassage</h2>
<p>Cet algorithme de chiffrement poss&#232;de cependant des failles, et il est tout &#224; fait possible de le &quot;casser&quot;, c'est-&#224;-dire d'obtenir le message original sans poss&#233;der la cl&#233; de chiffrement.</p>
<h3 id="force-brute">Force brute</h3>
<p>L'attaque par force brute (<em>brute force attack</em> en anglais), consiste simplement &#224; tester toutes les possibilit&#233;s de cl&#233; de chiffrement une par une, jusqu'&#224; trouver la bonne.</p>
<p>Le probl&#232;me avec le chiffre de C&#233;sar est qu'il n'existe en r&#233;alit&#233; que 26 uniques possibilit&#233;s de cl&#233; de chiffrement. En effet, si l'on utilise une cl&#233; sup&#233;rieure &#224; 26 cela revient &#224; utiliser une cl&#233; de <em>x mod 26</em>, par exemple si je chiffre le mot &quot;Linux&quot; avec une cl&#233; de chiffrement de 28 j'obtiens exactement le m&#234;me r&#233;sultat qu'avec ma cl&#233; de 2 car <em>28 mod 26 = 2</em>. Il est de m&#234;me pour les cl&#233;s n&#233;gatives, si j'utilise une cl&#233; de -1 cela revient &#224; utiliser une cl&#233; de 25.</p>
<p>Notre attaque n&#233;cessite donc l'analyse d'uniquement 26 cl&#233;s de chiffrement, ce qui n'est rien pour un ordinateur qui peut faire des milliards d'op&#233;rations &#224; la seconde :</p>
<pre class="nohighlight"><code>forceBrute :

   Pour chaque cl&#233; allant de 1 &#224; 26, &#224; pas de 1
      d&#233;chiffrer(message)
      Afficher message d&#233;chiffr&#233;</code></pre>
<p>Une impl&#233;mentation en C de cette attaque :</p>
<a href="javascript:toggle_visibility('force_brute.c');">force_brute.c</a>
<div id="force_brute.c" style="display: none;">
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &lt;ctype.h&gt;</span>

<span class="ot">#define TAILLE_MAX 500</span>

<span class="dt">const</span> <span class="dt">char</span> message[] = <span class="st">&quot;Nkpwz&quot;</span>;
<span class="dt">char</span> copie[TAILLE_MAX];
<span class="dt">int</span> cle;

<span class="dt">void</span> dechiffrement(<span class="dt">void</span>)
{
   <span class="dt">int</span> indexTab;

   <span class="kw">for</span>(indexTab = <span class="dv">0</span>; copie[indexTab] != &#39;\<span class="dv">0</span>&#39;; ++indexTab)
   {
      <span class="kw">if</span>(isupper(copie[indexTab]))
         copie[indexTab] = ((copie[indexTab] - &#39;A&#39; - cle) % <span class="dv">26</span> + <span class="dv">26</span>) % <span class="dv">26</span> + &#39;A&#39;;
      <span class="kw">else</span> <span class="kw">if</span>(islower(copie[indexTab]))
         copie[indexTab] = ((copie[indexTab] - &#39;a&#39; - cle) % <span class="dv">26</span> + <span class="dv">26</span>) % <span class="dv">26</span> + &#39;a&#39;;
   }
}

<span class="dt">void</span> forceBrute(<span class="dt">void</span>)
{
   <span class="kw">for</span>(cle = <span class="dv">1</span>; cle &lt; <span class="dv">26</span>; ++cle)
   {
      strcpy(copie, message);
      dechiffrement();
      printf(<span class="st">&quot;Pour une cle de %d : %s</span><span class="ch">\n</span><span class="st">&quot;</span>, cle, copie);
   }
}

<span class="dt">int</span> main(<span class="dt">void</span>)
{
   forceBrute();

   <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</div>
<p>Ici vu qu'il n'y a que 26 possibilit&#233;s, on se contente d'afficher tous les messages d&#233;chiffr&#233;s pour que l'utilisateur voit directement lequel ressemble &#224; du fran&#231;ais (on pourrait aussi impl&#233;menter un syst&#232;me qui diff&#233;rencie des phrases en fran&#231;ais de phrases sans aucuns sens, mais l'impl&#233;mentation se focalise uniquement sur l'attaque).</p>
<p>Cette m&#233;thode est assez bourrin, car tester toutes les combinaisons possibles est souvent une mauvaise id&#233;e, cependant dans notre cas o&#249; on sait qu&#8217;il n&#8217;y a que 26 possibilit&#233;s &#224; tester, cette m&#233;thode devient tout de suite le choix parfait pour casser le chiffre de C&#233;sar. En plus d&#8217;&#234;tre extr&#234;mement rapide, elle est aussi tr&#232;s simple &#224; mettre en place car une simple boucle suffit.</p>
<h3 id="analyse-fr&#233;quentielle">Analyse fr&#233;quentielle</h3>
<p>L'analyse fr&#233;quentielle (<em>frequency analysis</em> en anglais) examine la fr&#233;quence d'apparition des lettres employ&#233;es dans le message chiffr&#233; afin d'en deviner la cl&#233; pour le d&#233;chiffrer ensuite.</p>
<p>Cette attaque est possible sur le chiffre de C&#233;sar car c'est un syst&#232;me de chiffrement &#224; <strong>substitution mono-alphab&#233;tique</strong> ce qui signifie que si l&#8217;on chiffre plusieurs fois la lettre A avec une m&#234;me cl&#233; de chiffrement <em>x</em>, alors la lettre chiffr&#233;e sera toujours la m&#234;me. Ce type de syst&#232;me s&#8217;oppose donc &#224; la <strong>substitution poly-alphab&#233;tique</strong> utilis&#233;e par le <a href="/algo/chiffrement/chiffre_vigenere.html">chiffre de Vigen&#232;re</a> par exemple. De plus, l'analyse fr&#233;quentielle repose sur le fait que chaque langue poss&#232;de des lettres plus utilis&#233;es que d'autres (en fran&#231;ais par exemple la lettre E est plus utilis&#233;e que la lettre D, la lettre H l'est moins que la lettre O, etc.).</p>
<p>On peut donc analyser la fr&#233;quence d'apparition de chaque lettre dans notre message chiffr&#233;, et en d&#233;duire la lettre correspondante dans le message clair en &#233;tablissant un lien avec les lettres les plus utilis&#233;es en fran&#231;ais (on suppose ici que notre message a &#233;t&#233; &#233;crit en fran&#231;ais avant d'&#234;tre chiffr&#233;).</p>
<p>Par exemple, si dans notre message chiffr&#233; on remarque que la lettre M est la plus utilis&#233;e, on peut en d&#233;duire que c'est la lettre E dans notre message clair. Ce qui signifie que l'on peut calculer la diff&#233;rence de rangs entre les deux lettres pour avoir la cl&#233; de chiffrement (si M correspond effectivement &#224; E). Pour confirmer notre hypoth&#232;se, on peut continuer en cherchant la diff&#233;rence de rangs entre la deuxi&#232;me lettre la plus utilis&#233;e en fran&#231;ais (le A) et la deuxi&#232;me lettre la plus employ&#233;e dans notre message chiffr&#233;. Si les deux cl&#233;s correspondent, il y a alors de forte chances que ce soit la bonne cl&#233; de chiffrement.</p>
<p>Le pseudo-code de l&#8217;attaque par analyse fr&#233;quentielle :</p>
<pre class="nohighlight"><code>analyseFr&#233;quentielle :

   D&#233;terminer le nombre d&#8217;occurrence de chaque lettre

   Pour chaque lettre possible
      D&#233;duire la lettre correspondante dans le message clair
   Afficher les possibilit&#233;s de cl&#233;s de chiffrement (dans l&#39;ordre de pertinence)</code></pre>
<p>Dans ce pseudo-code on se contente d'afficher par ordre de pertinence nos possibilit&#233;s de cl&#233;s pour chaque lettre.</p>
<p>Sur de petits textes, cette attaque risque de ne pas bien fonctionner car notre m&#233;thode repose sur des statistiques et si on n'a pas assez de donn&#233;es, on ne devinera pas forc&#233;ment la cl&#233; du premier coup, alors que sur un long texte la premi&#232;re cl&#233; affich&#233;e est tr&#232;s souvent la bonne.</p>
<p>L'attaque cod&#233;e en C :</p>
<a href="javascript:toggle_visibility('analyse_frequentielle.c');">analyse_frequentielle.c</a>
<div id="analyse_frequentielle.c" style="display: none;">
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;ctype.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>

<span class="ot">#define NB_LETTRE_ALPHABET 26</span>
<span class="ot">#define TAILLE_MAX 500</span>

<span class="dt">const</span> <span class="dt">char</span> baseLettrePlusUtilisee[NB_LETTRE_ALPHABET] =
{
   &#39;e&#39;, &#39;a&#39;, &#39;i&#39;, &#39;s&#39;, &#39;t&#39;, &#39;n&#39;, &#39;r&#39;, &#39;u&#39;, &#39;l&#39;, &#39;o&#39;, &#39;d&#39;, &#39;m&#39;, &#39;p&#39;,&#39;c&#39;, &#39;v&#39;, &#39;q&#39;, 
   &#39;g&#39;, &#39;b&#39;, &#39;f&#39;, &#39;j&#39;, &#39;h&#39;, &#39;z&#39;, &#39;x&#39;, &#39;y&#39;, &#39;k&#39;, &#39;w&#39;
};

<span class="dt">char</span> message[] = <span class="st">&quot;Hj yjcyj jxy ozxyj qf utzw atzx rtsywjw vzj q&#39;fsfqdxj kwjvzjsynjqqj jxy ywjx zynqj xzw ij qtslx yjcyjx jy wjxyj knfgqj, atzx utzaje qj atnw js yjxyfsy hj uwtlwfrrj !&quot;</span>;
<span class="dt">char</span> messageDechiffre[TAILLE_MAX];
<span class="dt">int</span> cleSupposee[NB_LETTRE_ALPHABET];
<span class="dt">int</span> cle;

<span class="dt">void</span> dechiffrement(<span class="dt">void</span>)
{
   <span class="dt">int</span> indexTab;

   <span class="kw">for</span>(indexTab = <span class="dv">0</span>; messageDechiffre[indexTab] != &#39;\<span class="dv">0</span>&#39;; ++indexTab)
   {
      <span class="kw">if</span>(isupper(messageDechiffre[indexTab]))
         messageDechiffre[indexTab] = ((messageDechiffre[indexTab] - &#39;A&#39; - cle) % <span class="dv">26</span> + <span class="dv">26</span>) % <span class="dv">26</span> + &#39;A&#39;;
      <span class="kw">else</span> <span class="kw">if</span>(islower(messageDechiffre[indexTab]))
         messageDechiffre[indexTab] = ((messageDechiffre[indexTab] - &#39;a&#39; - cle) % <span class="dv">26</span> + <span class="dv">26</span>) % <span class="dv">26</span> + &#39;a&#39;;
   }
}

<span class="dt">void</span> preparerMessage(<span class="dt">void</span>)
{
   <span class="dt">int</span> indexTab;

   <span class="kw">for</span>(indexTab = <span class="dv">0</span>; message[indexTab] != &#39;\<span class="dv">0</span>&#39;; ++indexTab)
      message[indexTab] = tolower(message[indexTab]);
}

<span class="dt">void</span> determinerOccurrenceMot(<span class="dt">int</span> occurrence[NB_LETTRE_ALPHABET])
{
   <span class="dt">int</span> indexTab;

   <span class="kw">for</span>(indexTab = <span class="dv">0</span>; indexTab &lt; NB_LETTRE_ALPHABET; ++indexTab)
      occurrence[indexTab] = <span class="dv">0</span>;

   preparerMessage();

   <span class="kw">for</span>(indexTab = <span class="dv">0</span>; message[indexTab] != &#39;\<span class="dv">0</span>&#39;; ++indexTab)
      <span class="kw">if</span>(islower(message[indexTab]))
         ++occurrence[message[indexTab] - &#39;a&#39;];
}

<span class="dt">void</span> determinerClePossible(<span class="dt">int</span> occurrence[NB_LETTRE_ALPHABET])
{
   <span class="dt">int</span> indexBase;

   <span class="kw">for</span>(indexBase = <span class="dv">0</span>; indexBase &lt; NB_LETTRE_ALPHABET; ++indexBase)
   {
      <span class="dt">int</span> indexTab;
      <span class="dt">int</span> indexMax, maximum;

      maximum = -<span class="dv">1</span>;

      <span class="kw">for</span>(indexTab = <span class="dv">0</span>; indexTab &lt; NB_LETTRE_ALPHABET; ++indexTab)
      {
         <span class="kw">if</span>(occurrence[indexTab] &gt; maximum)
         {
            maximum = occurrence[indexTab];
            indexMax = indexTab;
         }  
      }

      occurrence[indexMax] = -<span class="dv">1</span>;

      cleSupposee[indexBase] = baseLettrePlusUtilisee[indexBase] - (indexMax + &#39;a&#39;);

      <span class="kw">if</span>(cleSupposee[indexBase] &lt; <span class="dv">0</span>)
         cleSupposee[indexBase] = -cleSupposee[indexBase];
   }
}

<span class="dt">void</span> analyseFrequentielle(<span class="dt">void</span>)
{
   <span class="dt">int</span> occurrence[NB_LETTRE_ALPHABET];

   determinerOccurrenceMot(occurrence);
   determinerClePossible(occurrence);
}

<span class="dt">int</span> main(<span class="dt">void</span>)
{
   <span class="dt">int</span> indexTab;

   strcpy(messageDechiffre, message);

   analyseFrequentielle();

   <span class="kw">for</span>(indexTab = <span class="dv">0</span>; indexTab &lt; NB_LETTRE_ALPHABET; ++indexTab)
      printf(<span class="st">&quot;%d &quot;</span>, cleSupposee[indexTab]);

   printf(<span class="st">&quot;</span><span class="ch">\n\n</span><span class="st">&quot;</span>);

   cle = cleSupposee[<span class="dv">0</span>];
   dechiffrement();
   printf(<span class="st">&quot;Message dechiffre avec la 1ere proposition de cle (%d) : </span><span class="ch">\n\n</span><span class="st">%s</span><span class="ch">\n</span><span class="st">&quot;</span>, cleSupposee[<span class="dv">0</span>], messageDechiffre);

   <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</div>
<p>Cette m&#233;thode d'attaque n'est pas r&#233;ellement adapt&#233;e au chiffre de C&#233;sar puisqu'on peut simplement utiliser l'attaque par force brute, cependant d'autres algorithmes de chiffrement n'ont pas aussi peu de possibilit&#233;s de cl&#233;s que le chiffre de C&#233;sar, et casser ces derniers n&#233;cessite donc une attaque plus r&#233;fl&#233;chie et plus intelligente comme l'analyse fr&#233;quentielle.</p>
<h2 id="conclusion">Conclusion</h2>
<p>TODO : faire conclusion</p>
<p>Le chiffre de C&#233;sar est donc un algorithme de chiffrement sym&#233;trique ancien, et tr&#232;s simple. Cependant, il est vuln&#233;rable &#224; plusieurs attaques comme celle de la force brute ou celle de l&#8217;analyse fr&#233;quentielle ce qui le rend inutile de nos jours.</p>
 
      <!-- ------------ -->

      <footer>
         <br>
         <p style="text-align: center;"><a href="https://sous-surveillance.fr"><img style="border: 0;" 
         src="//static.napnac.ga/img/PJL_banner.png" alt="Non à la loi renseignement" 
         title="Non à la loi renseignement" height="60" width="468" /></a></p>
      </footer>
   </body>
</html>
