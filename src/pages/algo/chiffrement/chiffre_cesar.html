<!DOCTYPE html>
<html>
   <head>
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato&#38;subset=latin,latin-ext" type="text/css" />
      <link rel="icon" type="image/x-icon" href="//static.napnac.ga/img/favicon.ico">
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/github-gist.min.css">

      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script>

      <!-- CSS -->
<style>
body {
   font-family: "Helvetica Neue", 'Lato', Helvetica, sans-serif;
   max-width: 1000px;
   margin: 0 auto;
   position: relative;
   width: 95%;
   line-height: 1.5;
}

/* ---- Titles ---- */

h1 {
   padding-top: 2%;
   padding-bottom: 2%;
   color: #DE4834;
}

h2, h3, h4, h5, h6 {
   padding-top: 1%;
   padding-bottom: 1%;
   color: #DE4834;
}

/* ---- Link ---- */

a {
   text-decoration: none;
   color: #2E64FE;
}

/* ---- List (+ main menu list) ---- */

ul {
   padding-left: 30px;
}

#main_menu {
   list-style: none;
   margin: 0;
   padding: 0;
   text-align: center;
}
#main_menu li {
   display: inline;
   margin-right: 1px;
}
#main_menu li a {
   line-height: 1em;
   padding: 4px 20px;
   text-align: center;
}
#main_menu li a:hover, #main_menu li a:active {
   text-decoration: underline;
}

/* ---- Tables (same look as from github markdown layout) ---- */

table {
   display: block;
   width: 100%;
   overflow: auto;
   word-break: normal;
   word-break: keep-all;
   border-collapse: collapse;
   border-spacing: 0;
   margin-top: 0;
   margin-bottom: 16px;
}

table th {
   font-weight: bold;
}

table th,
table td {
   padding: 6px 13px;
   border: 1px solid #ddd;
}

table tr {
   background-color: #fff;
   border-top: 1px solid #ccc;
}

table tr:nth-child(2n) {
   background-color: #f8f8f8;
}

/* ---- Image and caption ---- */

.figure {
   text-align: center;
}

.caption {
   font-style: italic;
   text-align: center;
}

/* ---- Summary ---- */

#summary {
   width: 70%;
   text-align: justify;
   line-height: 1.6;
}

/* ---- Temporary css ---- */

.pret {
   background-color: #00CC00;
   display: inline;
}

.relire {
   background-color: #FF9900;
   display: inline;
}

.encours {
   background-color: #3366CC;
   display: inline;
}

.faire {
   background-color: #FF0000;
   display: inline;
}
</style>
      <!---- ---->

      <title>Chiffre de César - NapNac</title>
   </head>

   <body>

      <!-- Javascript -->
<script type="text/javascript">
function toggle_visibility(id) {
   var element = document.getElementById(id);
   if(element.style.display == 'block')
      element.style.display = 'none';
   else
      element.style.display = 'block';
}
</script>
      <!---- ---->

      <header>
         <a href="/">
            <img src="//static.napnac.ga/img/logo.png" alt="Logo du site" height="100" width="300">
         </a>

      </header>

      <nav>
         <ul id="main_menu">
            <li><a href="/">Accueil</a></li>
            <li><a href="/articles.html">Articles</a></li>
            <li><a href="/projets.html">Projets</a></li>
            <li><a href="/a_propos.html">A propos</a></li>
         </ul>
      </nav>

      <!-- Page/Article -->

<a href=""><h1 id="chiffre-de-c&#233;sar">Chiffre de C&#233;sar</h1></a>
<p>Publi&#233; le : 21/05/2014<br />
<em>Modifi&#233; le : 14/12/2015</em></p>
<ul id="summary">
<li><a href="#introduction">Introduction</a></li>
<li><a href="#principe-de-lalgorithme">Principe de l&#8217;algorithme</a></li>
<li><a href="#exemple">Exemple</a></li>
<li><a href="#pseudo-code">Pseudo-code</a></li>
<li><a href="#impl&#233;mentation">Impl&#233;mentation</a></li>
<li><a href="#cassage">Cassage</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>Les premiers algorithmes de chiffrement ne datent pas de Jules C&#233;sar, mais ce dernier va instaurer un syst&#232;me au sein de son empire, afin de communiquer sans que personnes ne puissent intercepter ses messages secrets. Pour cela, il utilisait une m&#233;thode tr&#232;s simple qui consistait &#224; d&#233;caler chaque lettre de trois rangs vers la droite dans l'alphabet pour que le message paraisse alors incompr&#233;hensible, &#224; part pour la personne connaissant l'astuce. L'empereur a ainsi donn&#233; le nom &#224; l'un des premiers algorithmes de chiffrement : le chiffre de C&#233;sar.</p>
<h2 id="principe-de-lalgorithme">Principe de l&#8217;algorithme</h2>
<p>Le chiffre de C&#233;sar (aussi appel&#233; <em>chiffrement par d&#233;calage</em>) utilise une <a href="https://en.wikipedia.org/wiki/Substitution_cipher">substitution mono-alphab&#233;tique</a> pour chiffrer et d&#233;chiffrer un message, c&#8217;est-&#224;-dire que l&#8217;on d&#233;cale de <em>x</em> rangs vers la droite dans l&#8217;alphabet la lettre du message lors du chiffrement, et de <em>x</em> rangs vers la gauche lors du d&#233;chiffrement. On appelle <em>x</em> la <strong>cl&#233; de chiffrement</strong>, et cette derni&#232;re doit &#234;tre la m&#234;me pour le chiffrement et le d&#233;chiffrement car le chiffre de C&#233;sar est un <a href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm">chiffrement sym&#233;trique</a>.</p>
<h2 id="exemple">Exemple</h2>
<p>Prenons le mot &quot;Linux&quot;, que l&#8217;on va chiffrer puis d&#233;chiffrer &#224; l&#8217;aide du chiffre de C&#233;sar et avec une cl&#233; de chiffrement de 2.</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/chiffrement/chiffre_cesar/exemple_chiffrement.png" alt="Exemple de chiffrement" />
<p class="caption">Exemple de chiffrement</p>
</div>
<p>On a deux alphabets repr&#233;sent&#233;s, un normal et un autre d&#233;cal&#233; de 2 rangs vers la droite (car c'est notre cl&#233; de chiffrement). Cette repr&#233;sentation permet de facilement visualiser le d&#233;calage puisqu'il suffit de regarder la case correspondante dans le nouvel alphabet pour chiffrer notre message. Chaque lettre (repr&#233;sent&#233;e en bleu) de notre message en clair aura donc une lettre &#233;quivalente (repr&#233;sent&#233;e en vert) dans le nouvel alphabet.</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/chiffrement/chiffre_cesar/exemple_dechiffrement.png" alt="Exemple de d&#233;chiffrement" />
<p class="caption">Exemple de d&#233;chiffrement</p>
</div>
<p>De la m&#234;me mani&#232;re, pour le d&#233;chiffrement il suffit de faire correspondre les lettres de notre nouvel alphabet, &#224; celui normal afin de lire notre message chiffr&#233;.</p>
<h2 id="pseudo-code">Pseudo-code</h2>
<p>Le pseudo-code du chiffre de C&#233;sar est tr&#232;s simple :</p>
<pre class="nohighlight"><code>chiffrer :

   Pour chaque caract&#232;re du message
      Si c&#39;est une lettre
         D&#233;caler cette lettre de x rangs vers la droite

d&#233;chiffrer :

   Pour chaque caract&#232;re du message
      Si c&#39;est une lettre
         D&#233;caler cette lettre de x rangs vers la gauche </code></pre>
<p>Il faut cependant faire attention &#224; une chose, lorsqu'on d&#233;passe la lettre Z pendant le chiffrement, il faut pouvoir revenir au d&#233;but de l'alphabet, comme une sorte de boucle et inversement avec la lettre A lors du d&#233;chiffrement.</p>
<h2 id="impl&#233;mentation">Impl&#233;mentation</h2>
<p>Une impl&#233;mentation en C du chiffre de C&#233;sar :</p>
<a href="javascript:toggle_visibility('chiffre_cesar.c');">chiffre_cesar.c</a>
<div id="chiffre_cesar.c" style="display: none;">
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;ctype.h&gt;</span>

<span class="ot">#define TAILLE_MAX 1000</span>

<span class="dt">char</span> message[TAILLE_MAX];
<span class="dt">int</span> cle;

<span class="dt">void</span> chiffrement(<span class="dt">void</span>)
{
   <span class="dt">int</span> iTab;

   <span class="kw">for</span>(iTab = <span class="dv">0</span>; message[iTab] != &#39;\<span class="dv">0</span>&#39;; ++iTab) {
      <span class="kw">if</span>(isalpha(message[iTab])) {
         <span class="dt">char</span> typo;
         typo = (isupper(message[iTab])) ? &#39;A&#39; : &#39;a&#39;;

         message[iTab] -= typo;
         message[iTab] = ((message[iTab] + cle) % <span class="dv">26</span> + <span class="dv">26</span>) % <span class="dv">26</span>;
         message[iTab] += typo;
      }
   }
}

<span class="dt">void</span> dechiffrement(<span class="dt">void</span>)
{
   <span class="dt">int</span> iTab;

   <span class="kw">for</span>(iTab = <span class="dv">0</span>; message[iTab] != &#39;\<span class="dv">0</span>&#39;; ++iTab) {
      <span class="kw">if</span>(isalpha(message[iTab])) {
         <span class="dt">char</span> typo;
         typo = (isupper(message[iTab])) ? &#39;A&#39; : &#39;a&#39;;

         message[iTab] -= typo;
         message[iTab] = ((message[iTab] - cle) % <span class="dv">26</span> + <span class="dv">26</span>) % <span class="dv">26</span>;
         message[iTab] += typo;
      }
   }
}

<span class="dt">int</span> main(<span class="dt">void</span>)
{
   scanf(<span class="st">&quot;%[^</span><span class="ch">\n</span><span class="st">]s</span><span class="ch">\n</span><span class="st">&quot;</span>, message);
   scanf(<span class="st">&quot;%d</span><span class="ch">\n</span><span class="st">&quot;</span>, &amp;cle);

   chiffrement();
   printf(<span class="st">&quot;%s</span><span class="ch">\n</span><span class="st">&quot;</span>, message);
   dechiffrement();
   printf(<span class="st">&quot;%s</span><span class="ch">\n</span><span class="st">&quot;</span>, message);

   <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</div>
<p>Pour d&#233;caler notre lettre, on r&#233;cup&#232;re d&#233;j&#224; son rang dans l'alphabet pour simplifier les calculs (d'o&#249; le <code>- typo</code> et le <code>+ typo</code>), puis on ajoute (pour le chiffrement) ou on enl&#232;ve (pour le d&#233;chiffrement) la valeur de la cl&#233;, et ensuite on applique un <a href="https://en.wikipedia.org/wiki/Modulo_operation">modulo</a> 26 pour ne pas d&#233;passer le Z et revenir au d&#233;but dans ce cas. Cependant, en C, le modulo n&#233;gatif est particulier, par exemple <em>-3 mod 2 = -1</em>, il faut donc rajouter 26 au cas o&#249; le r&#233;sultat est n&#233;gatif (pour le rendre positif), et ensuite on applique de nouveau notre modulo 26.</p>
<p>En entr&#233;e de notre programme :</p>
<pre class="in"><code>Linux
2</code></pre>
<p>Et la sortie :</p>
<pre class="out"><code>Nkpwz
Linux</code></pre>
<h2 id="cassage">Cassage</h2>
<p>Cet algorithme de chiffrement poss&#232;de cependant des failles, et il est tout &#224; fait possible de le &quot;casser&quot;, c'est-&#224;-dire d'obtenir le message original sans poss&#233;der la cl&#233; de chiffrement.</p>
<h3 id="force-brute">Force brute</h3>
<p>L'attaque par force brute (<em>brute force attack</em> en anglais), consiste simplement &#224; tester toutes les possibilit&#233;s de cl&#233; de chiffrement une par une, jusqu'&#224; trouver la bonne.</p>
<p>Le probl&#232;me avec le chiffre de C&#233;sar est qu'il n'existe en r&#233;alit&#233; que 26 uniques possibilit&#233;s de cl&#233; de chiffrement. En effet, si l'on utilise une cl&#233; sup&#233;rieure &#224; 26 cela revient &#224; utiliser une cl&#233; de <em>x mod 26</em>, par exemple si je chiffre le mot &quot;Linux&quot; avec une cl&#233; de chiffrement de 28 j'obtiens exactement le m&#234;me r&#233;sultat qu'avec ma cl&#233; de 2 car <em>28 mod 26 = 2</em>. Il est de m&#234;me pour les cl&#233;s n&#233;gatives, si j'utilise une cl&#233; de -1 cela revient &#224; utiliser une cl&#233; de 25.</p>
<p>Notre attaque n&#233;cessite donc l'analyse d'uniquement 26 cl&#233;s de chiffrement, ce qui n'est rien pour un ordinateur qui peut faire des milliards d'op&#233;rations &#224; la seconde :</p>
<pre class="nohighlight"><code>forceBrute :

   Pour chaque cl&#233; allant de 1 &#224; 26, &#224; pas de 1
      d&#233;chiffrer(message)
      Afficher message d&#233;chiffr&#233;</code></pre>
<p>Une impl&#233;mentation en C de cette attaque :</p>
<a href="javascript:toggle_visibility('force_brute.c');">force_brute.c</a>
<div id="force_brute.c" style="display: none;">
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &lt;ctype.h&gt;</span>

<span class="ot">#define TAILLE_MAX 1000</span>

<span class="dt">char</span> message[TAILLE_MAX];
<span class="dt">char</span> copie[TAILLE_MAX];

<span class="dt">void</span> dechiffrement(<span class="dt">int</span> cle)
{
   <span class="dt">int</span> iTab;

   <span class="kw">for</span>(iTab = <span class="dv">0</span>; copie[iTab] != &#39;\<span class="dv">0</span>&#39;; ++iTab) {
      <span class="kw">if</span>(isalpha(copie[iTab])) {
         <span class="dt">char</span> typo;
         typo = (isupper(copie[iTab])) ? &#39;A&#39; : &#39;a&#39;;

         copie[iTab] -= typo;
         copie[iTab] = ((copie[iTab] - cle) % <span class="dv">26</span> + <span class="dv">26</span>) % <span class="dv">26</span>;
         copie[iTab] += typo;
      }
   }
}

<span class="dt">void</span> forceBrute(<span class="dt">void</span>)
{
   <span class="dt">int</span> iCle;
   <span class="kw">for</span>(iCle = <span class="dv">1</span>; iCle &lt; <span class="dv">26</span>; ++iCle) {
      strcpy(copie, message);
      dechiffrement(iCle);
      printf(<span class="st">&quot;Cle de %d : %s</span><span class="ch">\n</span><span class="st">&quot;</span>, iCle, copie);
   }
}

<span class="dt">int</span> main(<span class="dt">void</span>)
{
   scanf(<span class="st">&quot;%[^</span><span class="ch">\n</span><span class="st">]s</span><span class="ch">\n</span><span class="st">&quot;</span>, message);

   forceBrute();

   <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</div>
<p>Un exemple de message chiffr&#233; en entr&#233;e :</p>
<pre class="in"><code>Nkpwz</code></pre>
<p>Et la sortie obtenue :</p>
<a href="javascript:toggle_visibility('test02.out');">test02.out</a>
<div id="test02.out" style="display: none;">
<pre class="out"><code>Cle de 1 : Mjovy
Cle de 2 : Linux
Cle de 3 : Khmtw
Cle de 4 : Jglsv
Cle de 5 : Ifkru
Cle de 6 : Hejqt
Cle de 7 : Gdips
Cle de 8 : Fchor
Cle de 9 : Ebgnq
Cle de 10 : Dafmp
Cle de 11 : Czelo
Cle de 12 : Bydkn
Cle de 13 : Axcjm
Cle de 14 : Zwbil
Cle de 15 : Yvahk
Cle de 16 : Xuzgj
Cle de 17 : Wtyfi
Cle de 18 : Vsxeh
Cle de 19 : Urwdg
Cle de 20 : Tqvcf
Cle de 21 : Spube
Cle de 22 : Rotad
Cle de 23 : Qnszc
Cle de 24 : Pmryb
Cle de 25 : Olqxa</code></pre>
</div>
<p>Ici vu qu'il n'y a que 26 possibilit&#233;s, on se contente d'afficher tous les messages d&#233;chiffr&#233;s pour que l'utilisateur voit directement lequel ressemble &#224; du fran&#231;ais (on pourrait aussi impl&#233;menter un syst&#232;me qui diff&#233;rencie des phrases en fran&#231;ais de phrases sans aucuns sens, mais l'impl&#233;mentation se focalise uniquement sur l'attaque).</p>
<p>Cette m&#233;thode est assez bourrin, car tester toutes les combinaisons possibles est souvent une mauvaise id&#233;e, cependant dans notre cas o&#249; on sait qu&#8217;il n&#8217;y a que 26 possibilit&#233;s &#224; tester, cette m&#233;thode devient tout de suite le choix parfait pour casser le chiffre de C&#233;sar. En plus d&#8217;&#234;tre extr&#234;mement rapide, elle est aussi tr&#232;s simple &#224; mettre en place car une simple boucle suffit.</p>
<h3 id="analyse-fr&#233;quentielle">Analyse fr&#233;quentielle</h3>
<p>L'analyse fr&#233;quentielle (<em>frequency analysis</em> en anglais) examine la fr&#233;quence d'apparition des lettres employ&#233;es dans le message chiffr&#233; afin d'en deviner la cl&#233; pour le d&#233;chiffrer ensuite.</p>
<p>Cette attaque est possible sur le chiffre de C&#233;sar car c'est un syst&#232;me de chiffrement &#224; <strong>substitution mono-alphab&#233;tique</strong> ce qui signifie que si l&#8217;on chiffre plusieurs fois la lettre A avec une m&#234;me cl&#233; de chiffrement <em>x</em>, alors la lettre chiffr&#233;e sera toujours la m&#234;me. Ce type de syst&#232;me s&#8217;oppose donc &#224; la <strong>substitution poly-alphab&#233;tique</strong> utilis&#233;e par le <a href="/algo/chiffrement/chiffre_vigenere.html">chiffre de Vigen&#232;re</a> par exemple. De plus, l'analyse fr&#233;quentielle repose sur le fait que chaque langue poss&#232;de des lettres plus utilis&#233;es que d'autres (en fran&#231;ais par exemple la lettre E est plus utilis&#233;e que la lettre D, la lettre H l'est moins que la lettre O, etc.).</p>
<p>On peut donc analyser la fr&#233;quence d'apparition de chaque lettre dans notre message chiffr&#233;, et en d&#233;duire la lettre correspondante dans le message clair en &#233;tablissant un lien avec les lettres les plus utilis&#233;es en fran&#231;ais (on suppose ici que notre message a &#233;t&#233; &#233;crit en fran&#231;ais avant d'&#234;tre chiffr&#233;).</p>
<p>Par exemple, si dans notre message chiffr&#233; on remarque que la lettre M est la plus utilis&#233;e, on peut en d&#233;duire que c'est la lettre E dans notre message clair. Ce qui signifie que l'on peut calculer la diff&#233;rence de rangs entre les deux lettres pour avoir la cl&#233; de chiffrement (si M correspond effectivement &#224; E). Pour confirmer notre hypoth&#232;se, on peut continuer en cherchant la diff&#233;rence de rangs entre la deuxi&#232;me lettre la plus utilis&#233;e en fran&#231;ais (le A) et la deuxi&#232;me lettre la plus employ&#233;e dans notre message chiffr&#233;. Si les deux cl&#233;s correspondent, il y a alors de forte chances que ce soit la bonne cl&#233; de chiffrement.</p>
<p>Le pseudo-code de l&#8217;attaque par analyse fr&#233;quentielle :</p>
<pre class="nohighlight"><code>analyseFr&#233;quentielle :

   D&#233;terminer le nombre d&#8217;occurrence de chaque lettre
   D&#233;duire la cl&#233; de chiffrement la plus probable
   D&#233;chiffrer le message avec la cl&#233; trouv&#233;e</code></pre>
<p>Dans ce pseudo-code on se contente d'afficher par ordre de pertinence nos possibilit&#233;s de cl&#233;s pour chaque lettre.</p>
<p>Sur de petits textes, cette attaque risque de ne pas bien fonctionner car notre m&#233;thode repose sur des statistiques et si on n'a pas assez de donn&#233;es, on ne devinera pas forc&#233;ment la cl&#233; du premier coup, alors que sur un long texte la premi&#232;re cl&#233; affich&#233;e est tr&#232;s souvent la bonne.</p>
<p>L'attaque cod&#233;e en C :</p>
<a href="javascript:toggle_visibility('analyse_frequentielle.c');">analyse_frequentielle.c</a>
<div id="analyse_frequentielle.c" style="display: none;">
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;ctype.h&gt;</span>

<span class="ot">#define TAILLE_MAX 1000</span>
<span class="ot">#define NB_LETTRE 26</span>

<span class="dt">char</span> message[TAILLE_MAX];
<span class="dt">int</span> cle;

<span class="dt">void</span> dechiffrement(<span class="dt">void</span>)
{
   <span class="dt">int</span> iTab;

   <span class="kw">for</span>(iTab = <span class="dv">0</span>; message[iTab] != &#39;\<span class="dv">0</span>&#39;; ++iTab) {
      <span class="kw">if</span>(isalpha(message[iTab])) {
         <span class="dt">char</span> typo;
         typo = (isupper(message[iTab])) ? &#39;A&#39; : &#39;a&#39;;

         message[iTab] -= typo;
         message[iTab] = ((message[iTab] - cle) % <span class="dv">26</span> + <span class="dv">26</span>) % <span class="dv">26</span>;
         message[iTab] += typo;
      }
   }
}

<span class="dt">void</span> analyseFrequentielle(<span class="dt">void</span>)
{
   <span class="dt">int</span> occurrence[NB_LETTRE];
   <span class="dt">int</span> iLettre, iMax;

   <span class="kw">for</span>(iLettre = <span class="dv">0</span>; iLettre &lt; NB_LETTRE; ++iLettre)
      occurrence[iLettre] = <span class="dv">0</span>;
   <span class="kw">for</span>(iLettre = <span class="dv">0</span>; message[iLettre] != &#39;\<span class="dv">0</span>&#39;; ++iLettre) {
      <span class="kw">if</span>(isalpha(message[iLettre])) {
         <span class="dt">char</span> typo;
         typo = (isupper(message[iLettre])) ? &#39;A&#39; : &#39;a&#39;;
         ++occurrence[message[iLettre] - typo];
      }
   }


   iMax = <span class="dv">0</span>;
   <span class="kw">for</span>(iLettre = <span class="dv">0</span>; iLettre &lt; NB_LETTRE; ++iLettre)
      <span class="kw">if</span>(occurrence[iLettre] &gt; occurrence[iMax])
         iMax = iLettre;

   cle = &#39;e&#39; - (iMax + &#39;a&#39;);
   <span class="kw">if</span>(cle &lt; <span class="dv">0</span>)
      cle = -cle;
}

<span class="dt">int</span> main(<span class="dt">void</span>)
{
   scanf(<span class="st">&quot;%[^</span><span class="ch">\n</span><span class="st">]s</span><span class="ch">\n</span><span class="st">&quot;</span>, message);

   analyseFrequentielle();
   dechiffrement();
   printf(<span class="st">&quot;Cle de %d : </span><span class="ch">\n\n</span><span class="st">%s</span><span class="ch">\n</span><span class="st">&quot;</span>, cle, message);

   <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</div>
<p>Un texte chiffr&#233; en entr&#233;e :</p>
<pre class="in"><code>Lb ex mxqmx xlm xvkbm xg yktgvtbl, xm jn&#39;be vhgmbxgm tllxs wx vtktvmxkxl, e&#39;tgterlx ykxjnxgmbxeex xlm tllxs ybtuex xm whggx xg zxgxkte et uhggx vex wn ikxfbxk vhni. Ex ikhzktffx gx mxlmx jnx ex ikxfbxk kxlnemtm wx vex (jnb xlm et ienl ikhutuex), ftbl hg ihnkktbm itk xqxfiex tfxebhkxk e&#39;tgterlx xg l&#39;tiinrtgm lnk ienlbxnkl kxlnemtml wx vexl xm lb vxl wxkgbxkl vhkkxlihgwxgm tehkl be r tnkt ubxg ienl wx vatgvxl jnx vx lhbm et uhggx vex.</code></pre>
<p>Le texte d&#233;chiffr&#233; :</p>
<pre class="out"><code>Cle de 19 : 

Si le texte est ecrit en francais, et qu&#39;il contient assez de caracteres, l&#39;analyse frequentielle est assez fiable et donne en general la bonne cle du premier coup. Le programme ne teste que le premier resultat de cle (qui est la plus probable), mais on pourrait par exemple ameliorer l&#39;analyse en s&#39;appuyant sur plusieurs resultats de cles et si ces derniers correspondent alors il y aura bien plus de chances que ce soit la bonne cle.</code></pre>
<p>Cette m&#233;thode d'attaque n'est pas r&#233;ellement adapt&#233;e au chiffre de C&#233;sar puisqu'on peut simplement utiliser l'attaque par force brute, cependant d'autres algorithmes de chiffrement n'ont pas aussi peu de possibilit&#233;s de cl&#233;s que le chiffre de C&#233;sar, et casser ces derniers n&#233;cessite donc une attaque plus r&#233;fl&#233;chie et plus intelligente comme l'analyse fr&#233;quentielle.</p>
<h2 id="conclusion">Conclusion</h2>
<p>La cryptanalyse n'existait pas encore &#224; l'&#233;poque de Jules C&#233;sar, et ce dernier pouvait donc &#234;tre serein en utilisant un syst&#232;me aussi simple et peu s&#233;curis&#233; qu'est le chiffre de C&#233;sar. Cet algorithme n'est plus utilis&#233; depuis bien longtemps, mais &#224; permis de base de r&#233;flexion &#224; d'autres algorithmes plus efficaces comme le <a href="/algo/chiffrement/chiffre_vigenere.html">chiffre de Vigen&#232;re</a>.</p>
 
      <!-- ------------ -->

      <footer>
         <br>
         <p style="text-align: center;"><a href="https://sous-surveillance.fr"><img style="border: 0;" 
         src="//static.napnac.ga/img/PJL_banner.png" alt="Non à la loi renseignement" 
         title="Non à la loi renseignement" height="60" width="468" /></a></p>
      </footer>
   </body>
</html>
