<!DOCTYPE html>
<html>
   <head>
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato&#38;subset=latin,latin-ext" type="text/css" />
      <link rel="icon" type="image/x-icon" href="//static.napnac.ga/img/favicon.ico">
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/github-gist.min.css">

      <!-- Syntax highlighting -->
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script>

      <!-- Renders LaTeX expression with KaTeX -->
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/contrib/auto-render.min.js"></script>

      <!-- CSS -->
<style>
body {
   font-family: "Helvetica Neue", 'Lato', Helvetica, sans-serif;
   max-width: 1000px;
   margin: 0 auto;
   position: relative;
   width: 95%;
   line-height: 1.5;
}

/* ---- Titles ---- */

h1 {
   padding-top: 2%;
   padding-bottom: 2%;
   color: #DE4834;
}

h2, h3, h4, h5, h6 {
   padding-top: 1%;
   padding-bottom: 1%;
   color: #DE4834;
}

/* ---- Link ---- */

a {
   text-decoration: none;
   color: #2E64FE;
}

/* ---- List (+ main menu list) ---- */

ul {
   padding-left: 30px;
}

#main_menu {
   list-style: none;
   margin: 0;
   padding: 0;
   text-align: center;
}
#main_menu li {
   display: inline;
   margin-right: 1px;
}
#main_menu li a {
   line-height: 1em;
   padding: 4px 20px;
   text-align: center;
}
#main_menu li a:hover, #main_menu li a:active {
   text-decoration: underline;
}

/* ---- Tables (same look as from github markdown layout) ---- */

table {
   display: block;
   width: 100%;
   overflow: auto;
   word-break: normal;
   word-break: keep-all;
   border-collapse: collapse;
   border-spacing: 0;
   margin-top: 0;
   margin-bottom: 16px;
}

table th {
   font-weight: bold;
}

table th,
table td {
   padding: 6px 13px;
   border: 1px solid #ddd;
}

table tr {
   background-color: #fff;
   border-top: 1px solid #ccc;
}

table tr:nth-child(2n) {
   background-color: #f8f8f8;
}

/* ---- Image and caption ---- */

.figure {
   text-align: center;
}

.caption {
   font-style: italic;
   text-align: center;
}

/* ---- Summary ---- */

#summary {
   width: 70%;
   text-align: justify;
   line-height: 1.6;
}

/* ---- Code ---- */
pre {
   width: 90%;
   white-space: pre-wrap;
   word-break: break-all;
   word-wrap: break-word;
}
</style>
      <!---- ---->

      <title>RSA - napnac</title>
   </head>

   <body>

      <!-- Javascript -->
<script type="text/javascript">
function toggle_visibility(id) {
   var element = document.getElementById(id);
   if(element.style.display == 'block')
      element.style.display = 'none';
   else
      element.style.display = 'block';
}
</script>
      <!---- ---->

      <header>
         <a href="/">
            <img src="//static.napnac.ga/img/logo.png" alt="Logo du site" height="100" width="300">
         </a>

      </header>

      <nav>
         <ul id="main_menu">
            <li><a href="/">Accueil</a></li>
            <li><a href="/articles.html">Articles</a></li>
            <li><a href="/projets.html">Projets</a></li>
            <li><a href="/a_propos.html">A propos</a></li>
         </ul>
      </nav>

      <!-- Page/Article -->

<a href=""><h1 id="rsa">RSA</h1></a>
<p>Publi&#233; le : 31/05/2014<br />
<em>Modifi&#233; le : 02/02/2016</em></p>
<ul id="summary">
<li><a href="#introduction">Introduction</a></li>
<li><a href="#principe-de-lalgorithme">Principe de l'algorithme</a></li>
<li><a href="#exemple">Exemple</a></li>
<li><a href="#pseudo-code">Pseudo-code</a></li>
<li><a href="#impl&#233;mentation">Impl&#233;mentation</a></li>
<li><a href="#d&#233;monstration">D&#233;monstration</a></li>
<li><a href="#s&#233;curit&#233;">S&#233;curit&#233;</a></li>
<li><a href="#cassage">Cassage</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>Tous les algorithmes de chiffrement <strong>sym&#233;triques</strong> ont un probl&#232;me commun : la transmission de cl&#233;. Quel que soit l'algorithme utilis&#233;, si la cl&#233; est intercept&#233;e par l'ennemi, alors il peut lire les communications, mais aussi se faire passer pour le destinataire et l'exp&#233;diteur du message. Ce probl&#232;me est fondamental car transmettre une cl&#233; de chiffrement est tr&#232;s d&#233;licat, et m&#234;me impossible dans certains cas (par exemple avec Internet, c'est compliqu&#233; d'aller voir physiquement le responsable de chaque serveur pour qu'il vous transmette une cl&#233;), il &#233;tait donc n&#233;cessaire de trouver une autre solution face &#224; ce probl&#232;me : les chiffrements <strong>asym&#233;triques</strong>.</p>
<p>L'id&#233;e du chiffrement asym&#233;trique est d'utiliser deux cl&#233;s au lieu d'une, que l'on va attribuer &#224; chaque personne :</p>
<ul>
<li>Une cl&#233; <strong>publique</strong> qu'on peut diffuser, transmettre et montrer &#224; absolument tout le monde sans que cela pose un probl&#232;me de s&#233;curit&#233; (c'est d'ailleurs conseill&#233; de la rendre la plus accessible possible).</li>
<li>Une cl&#233; <strong>priv&#233;e</strong> qu'il ne faut en aucun cas &#233;voquer, cette cl&#233; doit rester secr&#232;te et vous ne devez la communiquer &#224; personne.</li>
</ul>
<p>Les bases du chiffrement asym&#233;trique furent introduites par <strong>Whitfield Diffie</strong> et <strong>Martin Hellman</strong> en 1976, lorsqu'ils ont montr&#233; comment r&#233;soudre le probl&#232;me d'&#233;change de cl&#233;s de mani&#232;re s&#233;curis&#233;e. La particularit&#233; de ce syst&#232;me est qu'il est simple de g&#233;n&#233;rer des couples de cl&#233;s, mais quasiment impossible de retrouver la cl&#233; priv&#233;e &#224; partir de la cl&#233; publique.</p>
<p>En 1977 l'algorithme RSA est pr&#233;sent&#233;, et sera l'un des premiers syst&#232;mes de chiffrement asym&#233;triques utilisant ce concept de paires de cl&#233;s et &#224; en faire une impl&#233;mentation possible pour la communication de messages gr&#226;ce &#224; des principes math&#233;matiques. Cet algorithme est encore tr&#232;s utilis&#233; de nos jours, surtout sur Internet (dans le commerce en ligne, les transactions s&#233;curis&#233;es, etc.) et constitue la base de quasiment tous les syst&#232;mes de chiffrement modernes.</p>
<h2 id="principe-de-lalgorithme">Principe de l'algorithme</h2>
<p>L'algorithme RSA va dans un premier temps g&#233;n&#233;rer deux couples de cl&#233;s asym&#233;triques, l'un pour l'<strong>&#233;metteur</strong> qu'on appellera <em>Alice</em>, et l'autre pour le <strong>destinataire</strong> qu'on appellera <em>Bob</em>. Une fois que chaque personne a ses deux cl&#233;s, on peut proc&#233;der &#224; une communication s&#233;curis&#233;e. Alice va chercher la cl&#233; publique de Bob (en g&#233;n&#233;ral on pratique &#224; un &#233;change des cl&#233;s publiques avant de communiquer, ou alors on les diffuse publiquement), et elle va chiffrer son message avec. Ensuite le message chiffr&#233; est transmis &#224; Bob, et il va le d&#233;chiffrer gr&#226;ce &#224; sa cl&#233; priv&#233;e (qu'il n'a communiqu&#233; &#224; personne). Aucun &#233;change de cl&#233; sensible n'est n&#233;cessaire, et seule la cl&#233; priv&#233;e de Bob peut d&#233;chiffrer le message, la communication est alors s&#233;curis&#233;e.</p>
<p>La s&#233;curit&#233; de l'algorithme se trouve dans l'utilisation d'une fonction de chiffrement et de d&#233;chiffrement <strong><a href="https://en.wikipedia.org/wiki/One-way_function">&#224; sens unique</a></strong>. Cette fonction est, comme pour la g&#233;n&#233;ration de cl&#233;, tr&#232;s simple &#224; appliquer dans un sens (avec la cl&#233; priv&#233;e), mais extr&#234;mement complexe dans l'autre (sans la cl&#233; priv&#233;e).</p>
<p>Tout d'abord, regardons comment g&#233;n&#233;rer nos cl&#233;s :</p>
<ul>
<li>Choisir deux <a href="https://en.wikipedia.org/wiki/Prime_number">nombres premiers</a> distincts <span class="math inline">p</span> et <span class="math inline">q</span>.</li>
<li>Calculer le produit <span class="math inline">p \times q</span> appel&#233; <strong>module de chiffrement</strong> et abr&#233;g&#233; <span class="math inline">n</span>.</li>
<li>Calculer l'<a href="https://en.wikipedia.org/wiki/Euler&#39;s_totient_function">indicatrice d'Euler</a> de <span class="math inline">n</span>, qu'on notera <span class="math inline">m = (p - 1) \times (q - 1)</span> (l'indicatrice d'Euler est une fonction permettant de compter les nombres premiers &#224; <span class="math inline">x</span> situ&#233;s entre 1 et <span class="math inline">x</span> compris).</li>
<li>Choisir un <strong>exposant de chiffrement</strong> not&#233; <span class="math inline">e</span>, qui soit premier avec <span class="math inline">m</span> et strictement inf&#233;rieur &#224; ce dernier.</li>
<li>Calculer l'<strong>exposant de d&#233;chiffrement</strong> not&#233; <span class="math inline">d</span>, qui est l'<a href="https://en.wikipedia.org/wiki/Modular_multiplicative_inverse">inverse modulaire</a> de <span class="math inline">e \mod m</span> (en savoir plus sur le <a href="https://en.wikipedia.org/wiki/Modulo_operation">modulo</a>).</li>
</ul>
<p>La cl&#233; publique correspond au couple (<span class="math inline">n</span>, <span class="math inline">e</span>) et la cl&#233; priv&#233;e au couple (<span class="math inline">n</span>, <span class="math inline">d</span>).</p>
<p>Pour chiffrer notre message, on utilisera alors cette relation :</p>
<p><span class="math inline">f(x) = x^e \mod n</span></p>
<p>Avec <span class="math inline">x</span> le message en clair, et <span class="math inline">f(x)</span> le message chiffr&#233;.</p>
<p>Et pour le d&#233;chiffrement, on utilise la fonction suivante :</p>
<p><span class="math inline">f&#39;(x) = x^d \mod n</span></p>
<p>Avec cette fois <span class="math inline">x</span> le message chiffr&#233; et <span class="math inline">f&#39;(x)</span> le message d&#233;chiffr&#233;.</p>
<h2 id="exemple">Exemple</h2>
<p>Choisissons comme message &quot;Bienvenue&quot;, et chiffrons-le avec l'algorithme RSA.</p>
<h3 id="g&#233;n&#233;ration-des-cl&#233;s">G&#233;n&#233;ration des cl&#233;s</h3>
<p>La premi&#232;re &#233;tape est de g&#233;n&#233;rer notre cl&#233; publique et priv&#233;e car je n'en poss&#232;de pas encore, et comme je n'ai pas d'ami nomm&#233; Bob &#224; qui envoyer des messages secrets, je vais m'envoyer le message chiffr&#233; &#224; moi-m&#234;me (pour simplifier les explications et ne pas &#234;tre embrouill&#233; dans toutes les valeurs num&#233;riques). On applique donc notre algorithme de cr&#233;ation de cl&#233;s :</p>
<p>Soit <span class="math inline">p</span> et <span class="math inline">q</span> deux nombres premiers que je choisis al&#233;atoirement :</p>
<p><span class="math inline">p = 61</span> et <span class="math inline">q = 137</span></p>
<p>A partir de cela, on peut calculer notre module de chiffrement :</p>
<p><span class="math inline">n = p \times q</span><br />
<span class="math inline">n = 8357</span></p>
<p>Ainsi que l'indicatrice d'Euler de <span class="math inline">n</span> :</p>
<p><span class="math inline">m = (p - 1) \times (q - 1)</span><br />
<span class="math inline">m = 8160</span></p>
<p>Ensuite, il faut choisir notre exposant de chiffrement <span class="math inline">e</span> qui doit &#234;tre premier avec <span class="math inline">m</span> et strictement inf&#233;rieur &#224; ce dernier, je choisis donc 7 :</p>
<p><span class="math inline">e = 7</span></p>
<p>D&#233;sormais nous devons trouver notre exposant de d&#233;chiffrement. Cette partie est un peu plus compliqu&#233;e, car elle n&#233;cessite quelques notions de maths.</p>
<p>On cherche donc <span class="math inline">d</span> qui est l'inverse modulaire de <span class="math inline">e \mod m</span>, on a :</p>
<p><span class="math inline">d \equiv e^{-1} \pmod m</span></p>
<p>Ce qui est &#233;quivalent &#224; :</p>
<p><span class="math inline">de \equiv 1 \pmod m</span></p>
<p>Par d&#233;finition de la <a href="https://en.wikipedia.org/wiki/Congruence_relation">congruence</a>, <span class="math inline">m</span> est un diviseur de <span class="math inline">d e - 1</span>, ce qu'on peut &#233;crire comme ceci :</p>
<p><span class="math inline">de - 1 = qm</span> avec <span class="math inline">q</span> le quotient de <span class="math inline">\frac{(de - 1)}{m}</span></p>
<p>On a finalement :</p>
<p><span class="math inline">de - qm = 1</span></p>
<p>On connait <span class="math inline">e</span>, <span class="math inline">m</span>, et on cherche <span class="math inline">d</span> :</p>
<p>On remarque que cette expression est de la forme de l'<a href="https://en.wikipedia.org/wiki/B%C3%A9zout&#39;s_identity">identit&#233; de B&#233;zout</a> <span class="math inline">ax + by = pgcd(a, b)</span> avec <span class="math inline">a = e</span>, <span class="math inline">b = m</span>, <span class="math inline">x = d</span>, <span class="math inline">y = -q</span>, et <span class="math inline">e</span> et <span class="math inline">m</span> sont premiers entre eux donc <span class="math inline">pgcd(a, b) = 1</span>. Or on peut trouver les coefficients <span class="math inline">x</span> et <span class="math inline">y</span> (et donc <span class="math inline">d</span>, qui nous int&#233;resse) gr&#226;ce &#224; l'<a href="https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm">algorithme d'Euclide &#233;tendu</a>. Une impl&#233;mentation de cet algorithme pour ceux que &#231;a int&#233;resse :</p>
<a href="javascript:toggle_visibility('algo_euclide_etendu.c');">algo_euclide_etendu.c</a>
<div id="algo_euclide_etendu.c" style="display: none;">
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;stdio.h&gt;</span>

<span class="dt">void</span> euclideEtendu(<span class="dt">int</span> a, <span class="dt">int</span> b)
{
   <span class="dt">int</span> r0, r1;
   <span class="dt">int</span> s0, s1;
   <span class="dt">int</span> t0, t1;
   <span class="dt">int</span> i;
   <span class="dt">int</span> q, r, s, t;

   r0 = a;
   s0 = <span class="dv">1</span>;
   t0 = <span class="dv">0</span>;

   r1 = b;
   s1 = <span class="dv">0</span>;
   t1 = <span class="dv">1</span>;

   r = <span class="dv">42</span>;
   <span class="kw">for</span>(i = <span class="dv">2</span>; r != <span class="dv">0</span>; ++i) {
      q = r0 / r1;
      r = r0 - q * r1;
      s = s0 - q * s1;
      t = t0 - q * t1;

      r0 = r1;
      r1 = r;
      s0 = s1;
      s1 = s;
      t0 = t1;
      t1 = t;
   }

   printf(<span class="st">&quot;x = %d</span><span class="ch">\n</span><span class="st">&quot;</span>, s0);
   printf(<span class="st">&quot;y = %d</span><span class="ch">\n</span><span class="st">&quot;</span>, t0);
}

<span class="dt">int</span> main(<span class="dt">void</span>)
{
   <span class="dt">int</span> a, b;
   scanf(<span class="st">&quot;%d %d</span><span class="ch">\n</span><span class="st">&quot;</span>, &amp;a, &amp;b);

   euclideEtendu(a, b);   

   <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</div>
<p>L'entr&#233;e :</p>
<pre class="nohighlight"><code>7
8160</code></pre>
<p>La sortie :</p>
<pre class="nohighlight"><code>x = -3497
y = 3</code></pre>
<p>On trouve gr&#226;ce au dernier programme :</p>
<p><span class="math inline">d = -3497</span></p>
<p>On a d&#233;sormais <span class="math inline">d</span> v&#233;rifiant l'&#233;quation <span class="math inline">de \equiv 1 \pmod m</span>. Cependant, on pr&#233;f&#232;rera travailler avec des nombres positifs, et selon Wikip&#233;dia le coefficient <span class="math inline">x</span> n'est pas unique (<span class="math inline">y</span> non plus mais c'est <span class="math inline">x</span> qui nous int&#233;resse), et on peut en trouver une infinit&#233; qui respectent la relation suivante :</p>
<p><span class="math inline">x + k\frac{b}{pgcd(a, b)}</span> avec <span class="math inline">k</span> un nombre entier relatif</p>
<p>Si on remplace par nos valeurs (<span class="math inline">x = d</span>, <span class="math inline">b = m</span>, <span class="math inline">pgcd(a, b) = 1</span>), on obtient :</p>
<p><span class="math inline">d + km</span></p>
<p>Et avec les valeurs num&#233;riques :</p>
<p><span class="math inline">-3497 + 8160k</span></p>
<p>On veut donc trouver un nombre <span class="math inline">d</span> positif :</p>
<p><span class="math inline">-3497 + 8160k &gt; 0</span><br />
<span class="math inline">k &gt; 0,429</span> (arrondi)</p>
<p>Or <span class="math inline">k</span> est un nombre entier, je vais donc arrondir &#224; l'entier sup&#233;rieur <span class="math inline">k = 1</span> pour avoir une valeur de <span class="math inline">d</span> positive :</p>
<p><span class="math inline">d = -3497 + m</span><br />
<span class="math inline">d = 4663</span></p>
<p>Notre couple de cl&#233; publique/priv&#233;e est d&#233;sormais g&#233;n&#233;r&#233; :</p>
<ul>
<li>Cl&#233; publique de la forme (<span class="math inline">n</span>, <span class="math inline">e</span>) : (8357, 7)</li>
<li>Cl&#233; priv&#233;e de la forme (<span class="math inline">n</span>, <span class="math inline">d</span>) : (8357, 4663)</li>
</ul>
<h3 id="chiffrementd&#233;chiffrement">Chiffrement/D&#233;chiffrement</h3>
<p>On peut maintenant chiffrer et d&#233;chiffrer notre message avec nos cl&#233;s en appliquant les fonctions :</p>
<p><span class="math inline">f(x) = x^e \mod n</span><br />
<span class="math inline">f&#39;(x) = x^d \mod n</span></p>
<p>Les caract&#232;res seront repr&#233;sent&#233;s par des nombres gr&#226;ce &#224; la <a href="https://en.wikipedia.org/wiki/ASCII">table ASCII</a> permettant de r&#233;soudre les relations math&#233;matiques (on imagine dans notre cas que les caract&#232;res du message sont tous pr&#233;sents dans la table ASCII pour simplifier le probl&#232;me).</p>
<p>Notre message correspond donc &#224; ceci selon la table ASCII :</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/chiffrement/rsa/exemple_message_ascii.png" alt="Transformation du message en nombre" />
<p class="caption">Transformation du message en nombre</p>
</div>
<p>Le message chiffr&#233; :</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/chiffrement/rsa/exemple_chiffrement.png" alt="Exemple de chiffrement" />
<p class="caption">Exemple de chiffrement</p>
</div>
<p>On se retrouve avec un message ressemblant &#224; ceci</p>
<pre class="nohighlight"><code>2546 824 4962 8071 2160 4962 8071 5933 4962 </code></pre>
<p>Que l'on peut d&#233;chiffrer :</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/chiffrement/rsa/exemple_dechiffrement.png" alt="Exemple de d&#233;chiffrement" />
<p class="caption">Exemple de d&#233;chiffrement</p>
</div>
<p>On retrouve bien nos valeurs num&#233;riques que l'on peut facilement transformer en caract&#232;res pour former notre message original.</p>
<h2 id="pseudo-code">Pseudo-code</h2>
<p>Le pseudo-code de l'algorithme RSA :</p>
<pre class="nohighlight"><code>cl&#233;Publique(p, q) :

   Choisir al&#233;atoirement p et q, deux nombres premiers distincts
   n = p * q
   m = (p - 1) * (q - 1)
   Choisir e strictement inf&#233;rieur &#224; m et premier avec lui

   Retourner couple (n, e)

cl&#233;Priv&#233;e(e, m, n) :

   Algorithme d&#39;Euclide &#233;tendu pour calculer d (l&#39;inverse de la multiplication
   de e mod m)

   Retourner couple (n, d)

chiffrer :

   Pour chaque caract&#232;re du message
      lettreChiffr&#233;e = lettreClaire ^ e mod n 

d&#233;chiffrer :

   Pour chaque caract&#232;re du message
      lettreClaire = lettreChiffr&#233;e ^ d mod n </code></pre>
<p>Une derni&#232;re question se pose cependant face &#224; ce pseudo-code : comment calculer des nombres avec des puissances aussi &#233;normes ? En effet, <span class="math inline">d = 4663</span> dans notre exemple et &#233;lever un nombre &#224; la puissance 4663 est tout simplement fou (surtout qu'en situation r&#233;elle, notre <span class="math inline">e</span> et <span class="math inline">d</span> peuvent comporter plusieurs centaines de chiffres chacun). Si on calcule s&#233;par&#233;ment <span class="math inline">a^b</span> puis on applique le modulo <span class="math inline">c</span> sur le r&#233;sultat on sera confront&#233; &#224; un probl&#232;me de stockage car quand <span class="math inline">b</span> est grand le r&#233;sultat <span class="math inline">a^b</span> sera tellement gigantesque que notre programme ne pourra pas stocker ce nombre. Heureusement un algorithme nous permet de calculer facilement le r&#233;sultat d'une op&#233;ration du style <span class="math inline">a^b \mod c</span>, c'est l'<a href="https://en.wikipedia.org/wiki/Modular_exponentiation">exponentiation modulaire</a>.</p>
<p>Soit <span class="math inline">x = a^b \mod c</span>, on peut trouver <span class="math inline">x</span> facilement gr&#226;ce &#224; notre nouvel algorithme :</p>
<pre class="nohighlight"><code>x = 1
Pour chaque exposant allant de 1 &#224; b inclus
   x = (x * a) mod c</code></pre>
<p>Cet algorithme nous permet donc de travailler avec des nombres bien plus petits qui ne d&#233;passeront jamais <span class="math inline">c</span> car &#224; chaque multiplication on effectue un modulo dessus.</p>
<h2 id="impl&#233;mentation">Impl&#233;mentation</h2>
<p>Une impl&#233;mentation en C de l'algorithme de RSA :</p>
<a href="javascript:toggle_visibility('rsa.c');">rsa.c</a>
<div id="rsa.c" style="display: none;">
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;time.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>

<span class="ot">#define TAILLE_MAX 1000</span>

<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> message[TAILLE_MAX];
<span class="dt">int</span> taille;
<span class="co">// Cl&#233;</span>
<span class="dt">int</span> p, q;
<span class="dt">int</span> n;
<span class="dt">int</span> m;
<span class="dt">int</span> e, d;

<span class="dt">int</span> PGCD(<span class="dt">int</span> a, <span class="dt">int</span> b)
{
   <span class="dt">int</span> r;

   <span class="kw">while</span>(b != <span class="dv">0</span>) {
      r = a % b;
      a = b;
      b = r;
   }

   <span class="kw">return</span> a;
}

<span class="dt">int</span> euclideEtendu(<span class="dt">int</span> a, <span class="dt">int</span> b)
{
   <span class="dt">int</span> r0, r1;
   <span class="dt">int</span> s0, s1;
   <span class="dt">int</span> t0, t1;
   <span class="dt">int</span> i;
   <span class="dt">int</span> q, r, s, t;

   r0 = a;
   s0 = <span class="dv">1</span>;
   t0 = <span class="dv">0</span>;

   r1 = b;
   s1 = <span class="dv">0</span>;
   t1 = <span class="dv">1</span>;

   r = <span class="dv">42</span>;
   <span class="kw">for</span>(i = <span class="dv">2</span>; r != <span class="dv">0</span>; ++i) {
      q = r0 / r1;
      r = r0 - q * r1;
      s = s0 - q * s1;
      t = t0 - q * t1;

      r0 = r1;
      r1 = r;
      s0 = s1;
      s1 = s;
      t0 = t1;
      t1 = t;
   }

   <span class="kw">return</span> s0;
}

<span class="dt">void</span> clePublique(<span class="dt">void</span>)
{
   <span class="dt">static</span> <span class="dt">int</span> premier[] = {<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">11</span>, <span class="dv">13</span>, <span class="dv">17</span>, <span class="dv">19</span>, <span class="dv">23</span>, <span class="dv">29</span>, <span class="dv">31</span>, <span class="dv">37</span>, <span class="dv">41</span>, <span class="dv">43</span>, 
      <span class="dv">47</span>, <span class="dv">53</span>, <span class="dv">59</span>, <span class="dv">61</span>, <span class="dv">67</span>, <span class="dv">71</span>, <span class="dv">73</span>, <span class="dv">79</span>, <span class="dv">83</span>, <span class="dv">89</span>, <span class="dv">97</span>, <span class="dv">101</span>, <span class="dv">103</span>, <span class="dv">107</span>, <span class="dv">109</span>, <span class="dv">113</span>, <span class="dv">127</span>, 
      <span class="dv">131</span>, <span class="dv">137</span>, <span class="dv">139</span>, <span class="dv">149</span>, <span class="dv">151</span>, <span class="dv">157</span>, <span class="dv">163</span>, <span class="dv">167</span>, <span class="dv">173</span>, <span class="dv">179</span>, <span class="dv">181</span>, <span class="dv">191</span>, <span class="dv">193</span>, <span class="dv">197</span>, <span class="dv">199</span>,
      <span class="dv">211</span>, <span class="dv">223</span>, <span class="dv">227</span>, <span class="dv">229</span>, <span class="dv">233</span>, <span class="dv">239</span>, <span class="dv">241</span>, <span class="dv">251</span>, <span class="dv">257</span>, <span class="dv">263</span>, <span class="dv">269</span>, <span class="dv">271</span>, <span class="dv">277</span>, <span class="dv">281</span>, <span class="dv">283</span>,
      <span class="dv">293</span>, <span class="dv">307</span>, <span class="dv">311</span>, <span class="dv">313</span>, <span class="dv">317</span>, <span class="dv">331</span>, <span class="dv">337</span>, <span class="dv">347</span>, <span class="dv">349</span>, <span class="dv">353</span>, <span class="dv">359</span>, <span class="dv">367</span>, <span class="dv">373</span>, <span class="dv">379</span>, <span class="dv">383</span>,
      <span class="dv">389</span>, <span class="dv">397</span>, <span class="dv">401</span>, <span class="dv">409</span>, <span class="dv">419</span>, <span class="dv">421</span>, <span class="dv">431</span>, <span class="dv">433</span>, <span class="dv">439</span>, <span class="dv">443</span>, <span class="dv">449</span>, <span class="dv">457</span>, <span class="dv">461</span>, <span class="dv">463</span>, <span class="dv">467</span>,
      <span class="dv">479</span>, <span class="dv">487</span>, <span class="dv">491</span>, <span class="dv">499</span>, <span class="dv">503</span>, <span class="dv">509</span>, <span class="dv">521</span>, <span class="dv">523</span>, <span class="dv">541</span>};

   <span class="co">/*do</span>
<span class="co">     {</span>
<span class="co">     p = premier[rand() % 100];</span>
<span class="co">     q = premier[rand() % 100];</span>

<span class="co">     } while(p == q);*/</span>

   p = <span class="dv">61</span>;
   q = <span class="dv">137</span>;

   n = p * q;
   m = (p - <span class="dv">1</span>) * (q - <span class="dv">1</span>);

   <span class="kw">for</span>(e = <span class="dv">2</span>; PGCD(e, m) != <span class="dv">1</span>; ++e)
      ;
}

<span class="dt">void</span> clePrivee(<span class="dt">void</span>)
{
   d = euclideEtendu(e, m);
   <span class="kw">while</span>(d &lt; <span class="dv">0</span>)
      d += m;
}

<span class="dt">void</span> chiffrement(<span class="dt">void</span>)
{
   <span class="dt">int</span> iMessage, iExp;
   <span class="dt">int</span> lettre;

   <span class="kw">for</span>(iMessage = <span class="dv">0</span>; iMessage &lt; taille; ++iMessage) {
      <span class="co">// Exponentiation modulaire</span>
      lettre = message[iMessage];
      message[iMessage] = <span class="dv">1</span>;
      <span class="kw">for</span>(iExp = <span class="dv">1</span>; iExp &lt;= e; ++iExp)
         message[iMessage] = (message[iMessage] * lettre) % n;
   }
}

<span class="dt">void</span> dechiffrement(<span class="dt">void</span>)
{
   <span class="dt">int</span> iMessage, iExp;
   <span class="dt">int</span> lettre;

   <span class="kw">for</span>(iMessage = <span class="dv">0</span>; iMessage &lt; taille; ++iMessage) {
      <span class="co">// Exponentiation modulaire</span>
      lettre = message[iMessage];
      message[iMessage] = <span class="dv">1</span>;
      <span class="kw">for</span>(iExp = <span class="dv">1</span>; iExp &lt;= d; ++iExp)
         message[iMessage] = (message[iMessage] * lettre) % n;
   }
}

<span class="dt">int</span> main(<span class="dt">void</span>)
{
   <span class="dt">char</span> iCar;
   <span class="dt">int</span> iMessage;

   <span class="co">// Lit le message et le transforme en nombre </span>
   iMessage = <span class="dv">0</span>;
   <span class="kw">do</span>
   {
      scanf(<span class="st">&quot;%c&quot;</span>, &amp;iCar);
      <span class="kw">if</span>(iCar != <span class="ch">&#39;\n&#39;</span>) {
         message[iMessage] = (<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span>)iCar;
         ++iMessage;
      }
   } <span class="kw">while</span>(iCar != <span class="ch">&#39;\n&#39;</span>);
   taille = iMessage;

   <span class="co">// G&#233;n&#232;re le couple de cl&#233;</span>
   srand(time(NULL));
   clePublique();
   clePrivee();

   printf(<span class="st">&quot;Cle publique : %d %d</span><span class="ch">\n</span><span class="st">&quot;</span>, n, e);
   printf(<span class="st">&quot;Cle privee : %d %d</span><span class="ch">\n</span><span class="st">&quot;</span>, n, d);

   <span class="co">// Chiffre le message et l&#39;affiche comme une suite de nombre</span>
   chiffrement();
   <span class="kw">for</span>(iMessage = <span class="dv">0</span>; iMessage &lt; taille; ++iMessage)
      printf(<span class="st">&quot;%llu &quot;</span>, message[iMessage]);
   printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);

   <span class="co">// D&#233;chiffre le message et l&#39;affiche comme une cha&#238;ne</span>
   dechiffrement();
   <span class="kw">for</span>(iMessage = <span class="dv">0</span>; iMessage &lt; taille; ++iMessage)
      printf(<span class="st">&quot;%c&quot;</span>, (<span class="dt">char</span>)message[iMessage]);
   printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);

   <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</div>
<p>Le message d'entr&#233;e :</p>
<pre class="nohighlight"><code>Bienvenue</code></pre>
<p>La sortie :</p>
<pre class="nohighlight"><code>Cle publique : 8357 7
Cle privee : 8357 4663
2546 824 4962 8071 2160 4962 8071 5933 4962 
Bienvenue</code></pre>
<p>Quelques remarques sur le code :</p>
<ul>
<li>Le type du message est <code>unsigned long long</code> qui est le type le plus grand en C (il stocke des nombres allant de <span class="math inline">0</span> &#224; <span class="math inline">2^{64} - 1</span>), car un <code>int</code> ne sera pas toujours suffisant, on prend donc des pr&#233;cautions en utilisant un type de donn&#233;es tr&#232;s grand pour ne pas avoir de probl&#232;mes.</li>
<li>Dans la fonction <code>clePublique</code>, j'utilise un tableau statique contenant tous les nombres premiers de 1 &#224; 100 et je tire au sort pour d&#233;terminer <span class="math inline">p</span> et <span class="math inline">q</span> (j'ai rentr&#233; directement <code>p = 61</code> et <code>q = 137</code> pour que les r&#233;sultats concordent avec notre exemple, mais la partie tirage au sort est comment&#233;e).</li>
<li>Pour lire notre message, on va directement stocker les caract&#232;res sous forme de nombre pour que le reste du programme soit plus simple, et pour la sortie on convertit en <code>char</code> apr&#232;s le d&#233;chiffrement pour afficher une cha&#238;ne de caract&#232;res.</li>
</ul>
<p>Sachez qu'en C, il existe la biblioth&#232;que <a href="https://gmplib.org/">GMP</a> pour manipuler de <strong>tr&#232;s</strong> grands nombres. Cependant, recr&#233;er sa propre impl&#233;mentation de RSA (ou m&#234;me de n'importe quel algorithme de chiffrement) dans le but de l'utiliser dans une application concr&#232;te est une mauvaise id&#233;e, et il est conseill&#233; d'utiliser des impl&#233;mentations d&#233;j&#224; existantes, libres, accessibles &#224; tous et qui sont utilis&#233;es par des milliers d'autres personnes comme : <a href="https://www.openssl.org/">OpenSSL</a>, <a href="https://gnupg.org/">GnuPG</a>, etc. L'avantage d'utiliser ce genre d'outils est que de nombreuses personnes travaillent dessus chaque jour, et des recherches sont effectu&#233;es r&#233;guli&#232;rement pour d&#233;couvrir les potentielles failles afin de rendre le syst&#232;me encore plus robuste.</p>
<h2 id="d&#233;monstration">D&#233;monstration</h2>
<p><em>Cette partie n'est pas essentielle pour comprendre le fonctionnement de l'algorithme, mais permet aux curieux de voir comment d&#233;montrer que notre syst&#232;me marche. Plusieurs notions math&#233;matiques sont n&#233;cessaires pour la compr&#233;hension de la d&#233;monstration, mais sachez que j'ai appris au fur et &#224; mesure en r&#233;digeant cette partie sans connaitre &#224; l'avance les outils math&#233;matiques utilis&#233;s, donc il est tout &#224; fait possible qu'un lecteur fasse de m&#234;me s'il est vraiment int&#233;ress&#233; par le sujet.</em></p>
<p>C'est bien beau toutes ces explications, mais math&#233;matiquement comme &#234;tre s&#251;r que notre algorithme marche &#224; tous les coups ? Comment savoir si notre message original une fois chiffr&#233; sera le m&#234;me quand il est d&#233;chiffr&#233; ?</p>
<p>Pour cela il faut prouver que l'algorithme RSA est valide, on part donc des deux fonctions de chiffrement et de d&#233;chiffrement :</p>
<p><span class="math inline">f(x) = x^e \mod n</span><br />
<span class="math inline">f&#39;(x) = x^d \mod n</span></p>
<p>Dire que notre algorithme est valide revient &#224; prouver que :</p>
<p><span class="math inline">f(f&#39;(x)) = f&#39;(f(x)) = x \mod n</span></p>
<p>Cependant on remarque que :</p>
<p><span class="math inline">f(f&#39;(x)) = (x^d \mod n)^e \mod n</span><br />
<span class="math inline">f(f&#39;(x)) = x^{ed} \mod n</span></p>
<p>Et :</p>
<p><span class="math inline">f&#39;(f(x)) = (x^e \mod n)^d \mod n</span><br />
<span class="math inline">f&#39;(f(x)) = x^{ed} \mod n</span></p>
<p>On a <span class="math inline">f(f&#39;(x)) = f&#39;(f(x)) = x^{ed} \mod n</span>, et on cherche donc &#224; d&#233;montrer que <span class="math inline">x^{ed} \equiv x \pmod{pq}</span> (car <span class="math inline">n = pq</span>). Or d'apr&#232;s le <a href="https://en.wikipedia.org/wiki/Chinese_remainder_theorem">th&#233;or&#232;me des restes chinois</a>, pour d&#233;montrer la congruence <span class="math inline">pq</span>, il suffit de d&#233;montrer les congruences <span class="math inline">p</span> et <span class="math inline">q</span> s&#233;par&#233;ment. D&#233;montrons d'abord que <span class="math inline">x^{ed} \equiv x \pmod p</span> :</p>
<p>On va diviser le probl&#232;me en deux cas, soit <span class="math inline">x</span> est divisible par <span class="math inline">p</span>, soit il ne l'est pas, donc soit <span class="math inline">x \equiv 0 \pmod p</span>, soit <span class="math inline">x \not\equiv 0 \pmod p</span>, commen&#231;ons par le premier cas (qui est le plus simple) :</p>
<p><span class="math inline">x</span> est un multiple de <span class="math inline">p</span>, donc <span class="math inline">x^{ed} \equiv 0 \pmod p</span>, or <span class="math inline">x \equiv 0 \pmod p</span>, donc <span class="math inline">x^{ed} \equiv x \pmod p</span>.</p>
<p>On continue avec notre deuxi&#232;me cas o&#249; <span class="math inline">x</span> n'est pas divisible par <span class="math inline">p</span> :</p>
<p>Tout d'abord, par d&#233;finition de <span class="math inline">e</span>, <span class="math inline">d</span> et <span class="math inline">m</span> :</p>
<p><span class="math inline">ed \equiv 1 \pmod m</span><br />
<span class="math inline">ed \equiv 1 \pmod{(p - 1)(q - 1)}</span></p>
<p>Ceci signifie que <span class="math inline">(p - 1)(q - 1)</span> est un diviseur de <span class="math inline">ed - 1</span>, on a :</p>
<p><span class="math inline">ed = 1 + k(p - 1)(q - 1)</span> avec <span class="math inline">k</span> un nombre entier repr&#233;sentant le quotient de <span class="math inline">\frac{(ed - 1)}{(p - 1)(q - 1)}</span></p>
<p>Donc :</p>
<p><span class="math inline">x^{ed} = x^{1 + k(p - 1)(q -1)}</span><br />
<span class="math inline">x^{ed} = x(x^{p - 1})^{k(q -1)}</span></p>
<p>Et d'apr&#232;s le <a href="https://en.wikipedia.org/wiki/Fermat&#39;s_little_theorem">th&#233;or&#232;me de Fermat</a> <span class="math inline">x^{p - 1} \equiv 1 \pmod p</span> :</p>
<p><span class="math inline">x^{ed} \equiv x(1)^{k(q - 1)} \pmod p</span><br />
<span class="math inline">x^{ed} \equiv x \pmod p</span></p>
<p>Donc pour tout <span class="math inline">x</span>, on a <span class="math inline">x^{ed} \equiv x \pmod p</span>. La d&#233;monstration pour la congruence de <span class="math inline">q</span> est exactement la m&#234;me. On a d&#233;montr&#233; que <span class="math inline">x^{eq} \equiv x \pmod{pq}</span>, et donc que <span class="math inline">x^{eq} \equiv x \pmod n</span>, donc notre algorithme v&#233;rifie l'&#233;quation au d&#233;part confirmant la validit&#233; de RSA.</p>
<h2 id="s&#233;curit&#233;">S&#233;curit&#233;</h2>
<h3 id="le-message">Le message</h3>
<p>Si vous &#234;tes observateur, vous avez peut-&#234;tre remarqu&#233; que finalement le message chiffr&#233; obtenu est le r&#233;sultat d'une simple <a href="https://en.wikipedia.org/wiki/Substitution_cipher">substitution mono-alphab&#233;tique</a> et que par cons&#233;quent chaque lettre sera toujours chiffr&#233;e de la m&#234;me fa&#231;on. Ceci est grave car notre message ne va pas r&#233;sister longtemps &#224; une cryptanalyse basique. Prenons l'exemple du message &quot;Bienvenue&quot;, on a obtenu le r&#233;sultat suivant <code>2546 824 4962 8071 2160 4962 8071 5933 4962</code>, cependant ce message a &#233;t&#233; chiffr&#233; avec une cl&#233; publique, et donc comme n'importe qui peut acc&#233;der &#224; cette cl&#233;, il est facile d'&#233;tablir un tableau de correspondance en chiffrant chaque lettre de l'alphabet avec la cl&#233; publique afin de d&#233;duire &#224; quelle lettre de l'alphabet correspond notre lettre du message chiffr&#233;. Ce probl&#232;me est d&#251; au fait que l'on peut distinguer les diff&#233;rentes lettres dans notre message chiffr&#233;, si ce n'&#233;tait pas le cas on aurait aucunes informations sur la cl&#233; priv&#233;e utilis&#233;e ou encore sur le message d&#233;chiffr&#233;.</p>
<p>Il est donc n&#233;cessaire de proc&#233;der autrement afin de s&#233;curiser le message en lui-m&#234;me et en rendant impossible tout cryptanalyse dessus. Si vous utilisez l'algorithme RSA, il y a de fortes chances que vous &#234;tes sur un ordinateur, cependant sur un ordinateur tout est stock&#233; &#224; l'aide de <a href="https://en.wikipedia.org/wiki/Bit">bit</a> (une simple unit&#233; valant soit 0 soit 1, permettant de compter en <a href="https://en.wikipedia.org/wiki/Binary_number">base binaire</a>), un groupe de 8 bits est appel&#233; un <a href="https://en.wikipedia.org/wiki/Octet_%28computing%29">octet</a>. Quand votre ordinateur stocke une cha&#238;ne de caract&#232;res, il stocke en r&#233;alit&#233; une succession d'octets formant chaque lettre, par exemple dans la table ASCII on peut utiliser un seul octet pour repr&#233;senter les 128 valeurs car elles ne n&#233;cessitent que 7 bits pour &#234;tre stock&#233;es. En sachant cela, on sait qu'une suite d'octet peut &#234;tre interpr&#233;t&#233;e comme une cha&#238;ne car pour notre ordinateur tout est un nombre, c'est nous qui lui disons que tel caract&#232;re correspond &#224; tel octet (et inversement) avec des tables comme celle ASCII. On pourrait donc repr&#233;senter notre message non plus comme une suite d'octet mais comme un <strong>groupe d'octet uni</strong>, ce qui fait qu'au lieu de chiffrer chaque octet un par un, on chiffre le tout d'un seul coup, rendant alors la cryptanalyse impossible (avec l'ancien syst&#232;me un octet pouvait valoir une des 128 valeurs, mais d&#233;sormais notre groupe d'octet r&#233;uni peut prendre un nombre consid&#233;rable de valeurs diff&#233;rentes qui augmente avec la taille du message). Il n'y a aucun moyen de trouver des informations &#224; cause de ce groupement, et la seule solution est d'essayer toutes les combinaisons, mais vu le nombre de possibilit&#233;s, on se rend vite compte que c'est impossible. Prenons par exemple le message &quot;Code&quot; :</p>
<table>
<thead>
<tr class="header">
<th>Lettre</th>
<th>C</th>
<th>o</th>
<th>d</th>
<th>e</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Hexad&#233;cimale</td>
<td>0x43</td>
<td>0x6F</td>
<td>0x64</td>
<td>0x65</td>
</tr>
<tr class="even">
<td>D&#233;cimale</td>
<td>67</td>
<td>111</td>
<td>100</td>
<td>101</td>
</tr>
</tbody>
</table>
<p>J'utilise la notation <a href="https://en.wikipedia.org/wiki/Hexadecimal">hexad&#233;cimale</a> car cette derni&#232;re permet de stocker un octet plus simplement qu'en notation d&#233;cimale. Notre message devient alors la suite d'octet <code>0x436F6465</code> (ce nombre correspond &#224; 1131373669 en d&#233;cimal) que notre ordinateur peut tout &#224; fait comprendre si on lui indique d'afficher cette suite comme une cha&#238;ne. Donc au lieu de chiffrer les nombres <code>0x43</code>, <code>0x6F</code>, <code>0x64</code>, <code>0x65</code> s&#233;par&#233;ment on va plut&#244;t chiffrer <code>0x436F6465</code> uniquement. Puisqu'on sait que notre message utilise la table ASCII et que cette derni&#232;re n'a besoin que d'un octet pour repr&#233;senter toutes les valeurs possibles, on sait qu'une lettre en notation hexad&#233;cimale ne prendra pas plus de deux caract&#232;res (si on exclut le <code>0x</code> qui est juste l&#224; pour indiquer que c'est de l'hexad&#233;cimal). On peut donc une fois notre nombre d&#233;chiffr&#233;, le d&#233;couper en plusieurs nombres (toujours repr&#233;sent&#233;s en notation hexad&#233;cimale) que l'on va convertir en caract&#232;re gr&#226;ce &#224; la table ASCII.</p>
<p>En C par exemple, il est facile de convertir une cha&#238;ne en un nombre hexad&#233;cimal et inversement :</p>
<a href="javascript:toggle_visibility('hexadecimal.c');">hexadecimal.c</a>
<div id="hexadecimal.c" style="display: none;">
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>

<span class="ot">#define TAILLE_MAX 1000</span>

<span class="dt">int</span> main(<span class="dt">void</span>)
{
   <span class="dt">char</span> message[TAILLE_MAX];
   <span class="dt">char</span> hexa[TAILLE_MAX * <span class="dv">2</span>];
   <span class="dt">char</span> caractere[<span class="dv">8</span>];
   <span class="dt">int</span> iMessage, ihexa;

   scanf(<span class="st">&quot;%[^</span><span class="ch">\n</span><span class="st">]s</span><span class="ch">\n</span><span class="st">&quot;</span>, message);

   <span class="co">// Transformation du message en une cha&#238;ne repr&#233;sentant notre nombre hexad&#233;cimal</span>
   <span class="kw">for</span>(iMessage = <span class="dv">0</span>; message[iMessage] != &#39;\<span class="dv">0</span>&#39;; ++iMessage) {
      sprintf(caractere, <span class="st">&quot;%x&quot;</span>, message[iMessage]);
      strcat(hexa, caractere);
   }
   printf(<span class="st">&quot;0x%s</span><span class="ch">\n</span><span class="st">&quot;</span>, hexa);

   <span class="co">// Transformation en une cha&#238;ne de caract&#232;re lisible</span>
   <span class="kw">for</span>(ihexa = <span class="dv">0</span>; hexa[ihexa] != &#39;\<span class="dv">0</span>&#39;; ihexa += <span class="dv">2</span>) {
      <span class="dt">char</span> lettre[<span class="dv">3</span>];
      lettre[<span class="dv">0</span>] = hexa[ihexa];
      lettre[<span class="dv">1</span>] = hexa[ihexa + <span class="dv">1</span>];
      lettre[<span class="dv">2</span>] = &#39;\<span class="dv">0</span>&#39;;

      printf(<span class="st">&quot;%c&quot;</span>, (<span class="dt">int</span>)strtoul(lettre, NULL, <span class="dv">16</span>));
   }
   printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);

   <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</div>
<p>On peut utiliser le sp&#233;cificateur <code>x</code> dans <a href="http://www.cplusplus.com/reference/cstdio/printf/"><code>printf</code></a> afin de convertir notre lettre en nombre hexad&#233;cimal. De m&#234;me, on peut utiliser <a href="http://www.cplusplus.com/reference/cstdlib/strtoul/"><code>stroul</code></a> afin de convertir notre nombre hexad&#233;cimal en base 10 et de l'afficher comme un caract&#232;re.</p>
<p>En entr&#233;e par exemple du programme :</p>
<pre class="nohighlight"><code>Code</code></pre>
<p>On obtient bien en sortie notre message sous forme d'un nombre hexad&#233;cimal :</p>
<pre class="nohighlight"><code>0x436f6465
Code</code></pre>
<p>Cependant quand notre message est important, le nombre obtenu est beaucoup trop grand pour &#234;tre chiffr&#233;, il faut alors d&#233;couper notre message en plusieurs sous nombres hexad&#233;cimaux au lieu d'un seul et appliquer le m&#234;me principe de chiffrement/d&#233;chiffrement.</p>
<h3 id="les-cl&#233;s">Les cl&#233;s</h3>
<p>D&#233;sormais qu'on sait que notre message peut &#234;tre s&#233;curis&#233;, il ne nous reste plus qu'&#224; prouver que notre syst&#232;me de cl&#233; asym&#233;trique est fiable car si l'ennemi arrive &#224; calculer la cl&#233; priv&#233;e, il peut d&#233;chiffrer le message simplement sans avoir &#224; le casser.</p>
<p>Tout le monde peut th&#233;oriquement acc&#233;der &#224; la cl&#233; publique d'une personne et donc peut conna&#238;tre <span class="math inline">n</span> et <span class="math inline">e</span>, mais cela est-il r&#233;ellement un probl&#232;me ? Car pour avoir la cl&#233; priv&#233;e il faut trouver <span class="math inline">d</span> puisqu'on connait d&#233;j&#224; <span class="math inline">n</span>, or pour trouver <span class="math inline">d</span>, il nous faut <span class="math inline">e</span> (que l'on a), mais surtout <span class="math inline">m</span>. Pour rappel <span class="math inline">m = (p - 1) \times (q - 1)</span>, et les seules informations qu'on pourrait avoir sur <span class="math inline">p</span> et <span class="math inline">q</span> peuvent venir de <span class="math inline">n</span> car <span class="math inline">n = p \times q</span>. Il faudrait donc <strong>factoriser</strong> <span class="math inline">n</span> en ses deux <strong>facteurs premiers</strong> <span class="math inline">p</span> et <span class="math inline">q</span>. Et c'est l&#224; que l'histoire se complique, car s'il est facile de trouver et de multiplier deux nombres premiers entre eux, il l'est beaucoup moins pour <a href="https://en.wikipedia.org/wiki/Integer_factorization">d&#233;composer en produit de facteurs premiers</a>. Aujourd'hui, personne n'a encore trouv&#233; d'algorithme qui s'ex&#233;cute en <a href="https://en.wikipedia.org/wiki/Time_complexity#Polynomial_time">temps polynomial</a>, et le meilleur algorithme qu'on connaisse a une complexit&#233; exponentielle (et qui ressemble &#224; &#231;a pour les curieux : <span class="math inline">O(\exp((\frac{64b}{9})^{\frac{1}{3}}(\log b)^{\frac{2}{3}}))</span> avec <span class="math inline">b</span> le nombre de bit de notre nombre <span class="math inline">n</span>). Cependant, la question de l'existence d'un algorithme efficace de d&#233;composition d'un nombre en ses facteurs premiers reste encore ouverte et pourrait jouer un r&#244;le majeur en cryptographie si la r&#233;ponse &#233;tait d&#233;couverte. En attendant, on peut jouer sur le fait qu'il est donc tr&#232;s long de d&#233;composer <span class="math inline">n</span>, et qu'il faudrait beaucoup de moyens pour trouver une cl&#233; de chiffrement priv&#233;e en un temps raisonnable. C'est pourquoi il faut choisir la taille de ses cl&#233;s avec attention et les renouveler si possible r&#233;guli&#232;rement.</p>
<p>Aujourd'hui une cl&#233; est &quot;s&#233;curis&#233;e&quot; si elle contient entre 2048 et 4096 bits, mais &quot;s&#233;curis&#233;&quot; n'est pas entre guillemets pour rien car certes votre voisin sera incapable de casser votre cl&#233;, certes votre groupe de hacker pr&#233;f&#233;r&#233; non plus (&#224; part s'ils ont des moyens colossaux &#224; leur disposition), mais par contre une agence gouvernementale pourrait &#233;ventuellement y arriver. En effet des agences comme la <a href="https://en.wikipedia.org/wiki/National_Security_Agency">NSA</a> ont d'&#233;normes moyens techniques mis en &#339;uvre (qui &#233;voluent, mais dont on a une petite id&#233;e gr&#226;ce aux r&#233;v&#233;lations de <a href="https://en.wikipedia.org/wiki/Edward_Snowden">Snowden</a> en 2013), et m&#234;me si sur une grande &#233;chelle ils ne peuvent pas casser toutes les cl&#233;s aussi importantes que cela, il est possible pour eux de casser quelques-unes en particulier si elles sont d'un tr&#232;s haut niveau d'importance. Pour cela, l'agence utilise des <a href="https://en.wikipedia.org/wiki/Supercomputer">superordinateurs</a> qui souvent sont construits et optimis&#233;s sp&#233;cifiquement dans le but de casser telle ou telle cl&#233;, et ils investissent des millions (voir des milliards selon leur budget annuel) dans la recherche afin de trouver une factorisation en un temps raisonnable (d'environ un an en g&#233;n&#233;ral). En plus de cela, l'agence peut faire des pressions sur des organisations contenant des donn&#233;es sensibles, on retiendra notamment l'affaire <a href="https://en.wikipedia.org/wiki/Lavabit">lavabit</a> o&#249; la NSA a oblig&#233; le cr&#233;ateur de ce service de mail chiffr&#233; &#224; divulguer des informations secr&#232;tes &#224; propos d'Edward Snowden. Le cr&#233;ateur ne pouvait en aucun cas parler de cette affaire au grand public sous peine d'emprisonnement et d'amende consid&#233;rable, et fut finalement forc&#233; de fermer son syst&#232;me de communication afin de ne pas coop&#233;rer avec la NSA. De nombreuses autres affaires de pression de la part de la NSA ou de gouvernements en g&#233;n&#233;ral existent, et elles montrent bien la d&#233;termination de certaines agences dans le but de trouver les cl&#233;s priv&#233;es de certains individus.</p>
<p>Ce qu'il faut retenir de cela, est qu'il est n&#233;cessaire pour avoir un syst&#232;me s&#233;curis&#233; d'utiliser des <strong>cl&#233;s importantes en taille</strong> et que l'on <strong>renouvelle r&#233;guli&#232;rement</strong>.</p>
<h3 id="identification">Identification</h3>
<p>A moins que vous ayez de gros probl&#232;mes avec la NSA, votre cl&#233; devrait normalement &#234;tre s&#233;curis&#233;e si elle est assez longue. Mais il reste encore une faille dans notre syst&#232;me c'est la transmission de la cl&#233; publique. En effet, cette communication peut &#234;tre compromise si quelqu'un se fait passer pour vous, et l'usurpation d'identit&#233; est r&#233;solue gr&#226;ce &#224; une <strong>signature num&#233;rique</strong> (comme lorsque vous signez un papier administratif dans la vraie vie pour vous identifier).</p>
<p>Le principe est plut&#244;t simple, on a vu que pour un message <span class="math inline">x</span>, on a <span class="math inline">f(f&#39;(x)) = f&#39;(f(x)) = x \mod n</span>. Lorsqu'on veut signer notre message et certifier que c'est nous qui l'avons envoy&#233;, on va dans un premier temps chiffrer notre message avec notre cl&#233; priv&#233;e, puis on le chiffre de nouveau avec la cl&#233; publique de la personne &#224; qui on souhaite envoyer le message. Une fois que la personne le re&#231;oit, elle va d&#233;chiffrer avec sa cl&#233; priv&#233;e le message puis, elle va le d&#233;chiffrer de nouveau avec votre cl&#233; publique (car on a chiffr&#233; dans un premier temps avec notre propre cl&#233; priv&#233;e). Si le message a un sens, cela confirme que c'est bien vous qui l'avais envoy&#233; car vous &#234;tes le seul &#224; conna&#238;tre votre cl&#233; priv&#233;e.</p>
<p>Malheureusement, sur de grands messages, cela prend beaucoup de temps de chiffrer et d&#233;chiffrer deux fois au lieu d'une. On a donc eu l'id&#233;e d'utiliser une <a href="https://en.wikipedia.org/wiki/Hash_function">fonction de hachage</a>, cette fonction prend en entr&#233;e un message, un nombre, une image, etc. et lui associe une <strong>empreinte unique</strong> de taille fixe (il suffit de changer une partie minime du message pour avoir une empreinte totalement diff&#233;rente), et cette empreinte ne permet en aucun cas de retrouver l'entr&#233;e de la fonction de hachage. Il est possible que vous en ayez d&#233;j&#224; entendu parler ou m&#234;me utiliser si par exemple vous utilisez Linux car lorsque vous t&#233;l&#233;chargez l'image d'une distribution, il est souvent possible de v&#233;rifier l'int&#233;grit&#233; et la validit&#233; de l'image gr&#226;ce &#224; un programme utilisant une fonction de hachage comme <a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1</a> ou encore <a href="https://en.wikipedia.org/wiki/MD5">MD5</a>. On va donc donner &#224; notre fonction de hachage notre message en clair, et on va chiffrer une premi&#232;re fois l'empreinte avec notre cl&#233; priv&#233;e, puis on la joint au message que l'on veut transmettre, et on chiffre le tout comme un message normal avec la cl&#233; publique du destinataire avant de l'envoyer. Une fois que la personne re&#231;oit le message, elle le d&#233;chiffre avec sa cl&#233; priv&#233;e et d&#233;chiffre l'empreinte jointe avec la cl&#233; publique de l'&#233;metteur, elle va ensuite v&#233;rifier l'empreinte en r&#233;alisant une de son c&#244;t&#233; (avec la m&#234;me fonction de hachage que celle utilis&#233;e par l'&#233;metteur). Si l'empreinte est la m&#234;me alors on est s&#251;r que le message est complet, non modifi&#233; et provient bien du destinataire, sinon c'est qu'il a &#233;t&#233; corrompu. Cette m&#233;thode est bien plus courte et rapide car on chiffre/d&#233;chiffre uniquement deux fois l'empreinte et non pas le message entier.</p>
<h2 id="cassage">Cassage</h2>
<p>Notre syst&#232;me est donc th&#233;oriquement s&#233;curis&#233;, et le seul moyen que l'on connait pour le moment est d'investir beaucoup d'argent et de temps pour factoriser <span class="math inline">n</span>. Cependant, tout le monde n'utilise pas RSA &#224; la perfection, et on peut trouver certaines failles dans des utilisations de cet algorithme qui permettent d'autres types d'attaques.</p>
<h3 id="lattaque-de-lhomme-du-milieu">L'attaque de l'homme du milieu</h3>
<p>Imaginons qu'Alice souhaite communiquer avec Bob, pour cela ils s'&#233;changent leurs cl&#233;s publiques. Cependant, Carole qui est une m&#233;chante personne, intercepte la cl&#233; publique de Bob qu'il a envoy&#233;e &#224; Alice, et Carole va envoyer sa propre cl&#233; publique. D&#233;sormais, lorsqu'Alice va chiffrer son message avec la soi-disant cl&#233; de Bob, elle le chiffre en r&#233;alit&#233; avec celle de Carole, ce qui signifie que lorsque Alice envoie un message chiffr&#233; &#224; Bob, si Carole l'intercepte elle va d&#233;chiffrer le message, le lire, potentiellement le modifier, et le chiffrer avec la cl&#233; publique de Bob avant de lui renvoyer. Ainsi, Alice et Bob ne se doutent de rien et pensent que leur communication est s&#233;curis&#233;e, mais Carole a pu lire et modifier leurs messages.</p>
<p>Cette attaque peut &#234;tre extr&#234;mement g&#234;nante, et avec Internet c'est encore plus simple de la r&#233;aliser car vous n'&#234;tes jamais r&#233;ellement s&#251;r que votre communication va directement au serveur sans passer par un autre ordinateur ennemi. Mais on peut contrer cette attaque gr&#226;ce &#224; plusieurs techniques, tout d'abord l'utilisation d'un annuaire contenant toutes les cl&#233;s publiques de chaque personne ne n&#233;cessiterait plus la communication de cl&#233;s. Cependant, il est possible que Carole soit tr&#232;s puissante et soit capable de modifier cet annuaire, on pourrait alors penser &#224; plusieurs solutions comme un syst&#232;me d'identification physique (empreinte digitale, reconnaissance faciale, reconnaissance de l'iris, authentification par biom&#233;trie, etc.), ou encore une transmission manuelle dans une valise diplomatique par exemple. Mais toutes ces propositions ne sont pas applicables dans tous les domaines, sur Internet encore une fois on ne peut pas se permettre de se baser sur une identification physique d'un serveur, c'est alors qu'apparait les <a href="https://en.wikipedia.org/wiki/Certificate_authority"><strong>autorit&#233;s de certifications</strong></a>. L'id&#233;e est d'utiliser une <strong>personne interm&#233;diaire</strong> que l'&#233;metteur et le destinataire font <strong>confiance</strong>, qui se chargera de la transmission des cl&#233;s, mais pour &#234;tre s&#251;r de la s&#233;curit&#233; on va en utiliser plusieurs qui &#224; la cha&#238;ne se transmettent les cl&#233;s et se font confiance. On cr&#233;e alors plusieurs <strong>couches de s&#233;curit&#233;</strong> lors de la transmission de la cl&#233; publique aux autorit&#233;s de certification, et c'est d'ailleurs sur quoi sont bas&#233;s les protocoles de s&#233;curit&#233; <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">SSL/TLS</a> largement utilis&#233;s sur Internet et qui ont permis la cr&#233;ation du protocole <a href="https://en.wikipedia.org/wiki/HTTPS">HTTPS</a>. Malheureusement, des organisations gouvernementales (oui encore la NSA), peuvent faire pression sur certaines autorit&#233;s de certifications afin d'utiliser l'attaque de l'homme du milieu, et l'une des seules solutions &#224; ce probl&#232;me est d'utiliser un <strong>service d&#233;centralis&#233;</strong> (l&#224; o&#249; les autorit&#233;s doivent certifier une autre autorit&#233;, notre syst&#232;me d&#233;centralis&#233; demande que les deux autorit&#233;s se <strong>certifient mutuellement</strong>). Le fait que le syst&#232;me soit d&#233;centralis&#233; rend bien plus compliqu&#233; les attaques de ce genre, car chaque autorit&#233; peut classer une autre comme &#233;tant totalement de confiance, peu de confiance ou encore frauduleuse. Plus le niveau de classification de la confiance est bas, plus l'autorit&#233; doit avoir de retours positifs de la part d'autres autorit&#233;s de confiance afin de valider la transmission des cl&#233;s. Si une autorit&#233; de certification est corrompue, les autres ne lui feront plus confiance et vu qu'une confiance mutuelle est n&#233;cessaire, cette autorit&#233; sera mise de c&#244;t&#233; voir plus du tout utilis&#233;e. On a donc un r&#233;seau totalement d&#233;centralis&#233; permettant plus de s&#233;curit&#233;, et &#233;vitant un syst&#232;me de pression de la part d'organisations ayant beaucoup d'influence.</p>
<h3 id="attaque-dh&#229;stad">Attaque d'H&#229;stad</h3>
<p>A la cr&#233;ation du syst&#232;me RSA, les ordinateurs &#233;taient loin d'&#234;tre aussi rapides qu'aujourd'hui et ce probl&#232;me d'efficacit&#233; &#233;tait r&#233;ellement compromettant. Pour permettre un algorithme plus rapide, on utilisait souvent des valeurs de <span class="math inline">e</span> petites (3, 7, 17, etc.) afin d'am&#233;liorer le temps n&#233;cessaire &#224; l'algorithme pour g&#233;n&#233;rer des paires de cl&#233;s et de chiffrer le message. Cependant, Johan H&#229;stad d&#233;montra en 1985, que si on envoyait un <strong>m&#234;me message</strong> &#224; au moins <span class="math inline">e</span> personnes avec le <strong>m&#234;me exposant</strong>, alors on pouvait d&#233;chiffrer le texte facilement. Vu qu'en g&#233;n&#233;ral on utilisait des exposants comme <span class="math inline">e = 3</span>, il suffisait alors d'intercepter 3 m&#234;mes messages qu'une personne a envoy&#233; &#224; diff&#233;rents destinataires, pour en trouver le contenu d&#233;chiffr&#233;. Pour effectuer cette attaque, le math&#233;maticien a utilis&#233; le <a href="https://en.wikipedia.org/wiki/Chinese_remainder_theorem">th&#233;or&#232;me des restes chinois</a> :</p>
<p>Imaginons, qu'Alice envoie &#224; au moins 3 personnes un m&#234;me message chiffr&#233;, avec le m&#234;me exposant <span class="math inline">e = 3</span>. Soit les trois messages chiffr&#233;s <span class="math inline">c_1</span>, <span class="math inline">c_2</span>, <span class="math inline">c_3</span>, leurs modules de chiffrement respectifs <span class="math inline">n_1</span>, <span class="math inline">n_2</span>, <span class="math inline">n_3</span>, et le message d&#233;chiffr&#233; <span class="math inline">d</span>. On a d&#233;montr&#233; que <span class="math inline">f&#39;(f(d)) = d \mod n</span>, ce qui signifie que d&#233;chiffrer un message chiffr&#233; revient &#224; exprimer <span class="math inline">d \mod n</span>. On a donc <span class="math inline">c_i \equiv d^3 \mod n_i</span> avec <span class="math inline">i</span> allant de 1 &#224; 3. Gr&#226;ce au th&#233;or&#232;me des restes chinois, on peut trouver un nombre <span class="math inline">c</span> tel que <span class="math inline">c_i \equiv c \mod n</span>, ce qui nous donne <span class="math inline">c \equiv d^3 \mod{n_1 n_2 n_3}</span>. Or par d&#233;finition, <span class="math inline">d &lt; n_i</span>, et donc <span class="math inline">d^3 &lt; n_1 n_2 n_3</span>. Alors on peut &#233;crire <span class="math inline">c = d^3</span>, et calculer <span class="math inline">d</span> facilement <span class="math inline">d = \sqrt[3]{c}</span>. On peut g&#233;n&#233;raliser cette attaque en rempla&#231;ant 3 par <span class="math inline">e</span>, mais plus <span class="math inline">e</span> est grand plus l'attaque est difficile &#224; mettre en place.</p>
<p>Cette attaque sera ensuite reprise par plusieurs autres math&#233;maticiens pour cr&#233;er diff&#233;rentes variantes et am&#233;liorations : <a href="https://en.wikipedia.org/wiki/Coppersmith&#39;s_Attack#Franklin-Reiter_Related_Message_Attack">Franklin-Reiter</a>, <a href="https://en.wikipedia.org/wiki/Coppersmith&#39;s_Attack#Coppersmith.E2.80.99s_Short_Pad_Attack">Coppersmith</a>.</p>
<p>Ceci nous montre bien que dans ce cas, &#224; d&#233;faut de vouloir utiliser l'algorithme plus rapidement, on perd &#233;norm&#233;ment en s&#233;curit&#233;, il faut donc faire attention lors d'am&#233;lioration de ce type &#224; ne pas affaiblir le syst&#232;me de chiffrement. Un petit exposant <span class="math inline">e</span> facilite donc cette attaque, car plus il est petit plus le nombre de messages &#224; r&#233;cup&#233;rer est faible, et plus le temps n&#233;cessaire &#224; trouver le message d&#233;chiffr&#233; est court. Pour se prot&#233;ger face &#224; cette attaque, il suffit d'utiliser un exposant <span class="math inline">e</span> assez important.</p>
<h3 id="attaque-de-wiener">Attaque de Wiener</h3>
<p>Dans le m&#234;me style qu'attaquer des messages avec des <span class="math inline">e</span> petits, en 1990 Michael Wiener a trouv&#233; une attaque similaire mais sur des petits <span class="math inline">d</span>. Il d&#233;montra que si <span class="math inline">d &lt; \frac{1}{3}n^{\frac{1}{4}}</span>, on peut retrouver <span class="math inline">d</span>, gr&#226;ce &#224; l'algorithme des <a href="https://en.wikipedia.org/wiki/Continued_fraction">fractions continues</a>.</p>
<p>On part de l'&#233;quivalence suivante :</p>
<p><span class="math inline">ed \equiv 1 \mod m</span></p>
<p>Par d&#233;finition <span class="math inline">m = (p - 1) \times (q - 1)</span>, et <span class="math inline">ppcm(a, b) = \frac{| ab |}{pgcd(a, b)}</span> (plus d'infos sur le <a href="https://en.wikipedia.org/wiki/Least_common_multiple">ppcm</a>), or <span class="math inline">p</span> et <span class="math inline">q</span> sont premiers entre eux, donc <span class="math inline">pgcd(p, q) = 1</span>, et on peut alors &#233;crire :</p>
<p><span class="math inline">ed \equiv 1 \mod ppcm(p - 1, q - 1)</span></p>
<p>Cela signifie qu'il existe un nombre entier <span class="math inline">K</span>, tel que :</p>
<p><span class="math inline">ed = K \times ppcm(p - 1, q - 1) + 1</span></p>
<p>Soit <span class="math inline">G = pgcd(p - 1, q - 1)</span>, <span class="math inline">k = \frac{K}{pgcd(K, G)}</span> et <span class="math inline">g = \frac{G}{pgcd(K, G)}</span>, on a la relation suivante :</p>
<p><span class="math inline">ed = \frac{k}{g}(p - 1)(q - 1) + 1</span></p>
<p>Que l'on peut arranger en divisant le tout par <span class="math inline">dpq</span> :</p>
<p><span class="math inline">\frac{e}{pq} = \frac{k}{dg}(1 - \delta)</span> avec <span class="math inline">\delta = \frac{p + q - 1 - \frac{g}{k}}{pq}</span></p>
<p>A partir de l&#224;, si on arrive &#224; d&#233;terminer <span class="math inline">\frac{k}{dg}</span> gr&#226;ce &#224; l'algorithme des fractions continues, on peut trouver <span class="math inline">k</span> mais surtout <span class="math inline">dg</span> qui nous permet de casser le syst&#232;me RSA.</p>
<p>Un article sp&#233;cialement sur l'attaque de Wiener (et en fran&#231;ais), montre comment utiliser l'algorithme des fractions continues : <a href="http://www.jannaud.fr/static/download/Travail/rapportwiener.pdf">Attaque de cl&#233;s RSA par la m&#233;thode de Wiener</a>.</p>
<h3 id="module-de-chiffrement-commun">Module de chiffrement commun</h3>
<p>Cr&#233;er un module de chiffrement &#224; chaque g&#233;n&#233;ration de paires de cl&#233;s peut &#234;tre une op&#233;ration lourde, et certaines personnes utilisaient un m&#234;me <span class="math inline">n</span> pour toutes les paires (avec bien entendu des <span class="math inline">e</span> et <span class="math inline">d</span> diff&#233;rents). A premi&#232;re vue, il n'y a pas de raison que &#231;a ne fonctionne pas, cependant il a &#233;t&#233; d&#233;montr&#233; qu'une personne poss&#233;dant une paire de cl&#233; de ce genre, peut factoriser assez facilement <span class="math inline">n</span> avec son propre <span class="math inline">e</span> et <span class="math inline">d</span> et ainsi d&#233;duire les cl&#233;s priv&#233;es des autres personnes du syst&#232;me.</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/chiffrement/rsa/demonstration_facto_n.png" alt="D&#233;monstration de cette propri&#233;t&#233;" />
<p class="caption">D&#233;monstration de cette propri&#233;t&#233;</p>
</div>
<p>La d&#233;monstration vient de <em>Twenty Years of Attacks on the RSA Cryptosystem</em> de Dan Boneh, que vous pouvez retrouver en pdf sur Internet.</p>
<p>Et voici un exemple concret de l'utilisation de cette propri&#233;t&#233; pour factoriser <span class="math inline">n</span> : <a href="http://www.di-mgt.com.au/rsa_factorize_n.html">How to factorize N given d</a>.</p>
<h3 id="attaque-sur-les-impl&#233;mentations">Attaque sur les impl&#233;mentations</h3>
<p>En pratique, il est difficile de toujours faire une impl&#233;mentation parfaite d'un syst&#232;me de chiffrement, et des &#233;tudes/audits r&#233;v&#232;lent r&#233;guli&#232;rement des failles dans certains syst&#232;mes de s&#233;curit&#233;. Il est donc possible de se focaliser sur des attaques d'impl&#233;mentations au lieu d'essayer de casser un syst&#232;me de chiffrement th&#233;orique.</p>
<h4 id="attaque-par-chronom&#233;trage">Attaque par chronom&#233;trage</h4>
<p>L'id&#233;e consiste &#224; &#233;tudier le temps n&#233;cessaire &#224; l'ordinateur, stockant la cl&#233; priv&#233;e, de d&#233;chiffrer (ou de signer) plusieurs messages. Cette attaque se base sur le fait que la plupart des impl&#233;mentations utilisent un m&#234;me algorithme (ou alors un algorithme connu) afin d'effectuer le d&#233;chiffrement, et on peut donc en d&#233;duire le nombre d'op&#233;rations effectu&#233;es et ainsi petit &#224; petit r&#233;cup&#233;rer des informations sur <span class="math inline">d</span>. Par exemple, il est courant d'utiliser l'exponentiation modulaire pour impl&#233;menter notre fonction de d&#233;chiffrement, comme nous avons vu pr&#233;c&#233;demment, cependant une am&#233;lioration de cette derni&#232;re se base sur la repr&#233;sentation binaire de la cl&#233; (et donc de <span class="math inline">d</span>), ce qui nous permet apr&#232;s plusieurs op&#233;rations de d&#233;chiffrement de faire des analyses statistiques sur les informations recueillies pour d&#233;terminer <span class="math inline">d</span>. Or, en g&#233;n&#233;ral, une am&#233;lioration en temps est souvent cruciale en cryptographie, ceci est donc largement utilis&#233;.</p>
<p>Tout d'abord, regardons l'am&#233;lioration de l'exponentiation modulaire :</p>
<p>Soit <span class="math inline">d</span> notre exposant dans l'expression <span class="math inline">f&#39;(x) = x^d \mod n</span> avec <span class="math inline">x</span> notre message chiffr&#233;. On peut &#233;crire <span class="math inline">d</span>, sous forme de repr&#233;sentation binaire :</p>
<p><span class="math inline">d = \displaystyle\sum_{i=0}^{b-1} a_i2^i</span> avec <span class="math inline">a</span> repr&#233;sentant un bit (soit 0 soit 1), et <span class="math inline">b</span> le nombre de bit pour repr&#233;senter <span class="math inline">d</span>.</p>
<p>On a donc <span class="math inline">x^d</span> qu'on repr&#233;sente ainsi :</p>
<p><span class="math inline">x^d = \displaystyle\prod_{i=0}^{b-1} (x^{2^i})^{a_i}</span></p>
<p>Cette repr&#233;sentation binaire permet de faire des op&#233;rations extr&#234;mement rapides dans la plupart des langages de programmation gr&#226;ce aux <strong>op&#233;rateurs bit &#224; bit</strong>, en C par exemple on a les op&#233;rateurs <code>&gt;&gt;</code> et <code>&lt;&lt;</code> pour effectuer des d&#233;calages (ou <em>shift</em> en anglais) sur des nombres binaires (ceci offre notamment un gain &#233;norme de temps sur des op&#233;rations comme les puissances).</p>
<p>L'attaque par chronom&#233;trage consistera dans notre cas, &#224; observer le temps que met l'ordinateur pour d&#233;chiffrer un certain message afin de trouver petit &#224; petit chaque bit de <span class="math inline">d</span>. Tout d'abord, <span class="math inline">d</span> par d&#233;finition est forc&#233;ment impair, on conclut donc que le bit 0 de <span class="math inline">d</span> sera <span class="math inline">d_0 = 1</span> (plus d'infos : <a href="https://en.wikipedia.org/wiki/Least_significant_bit">bit de poids faible</a>). Pour trouver les autres bits, on va &#233;mettre des hypoth&#232;ses sur la valeur de <span class="math inline">a_i</span>, qui peut &#234;tre soit 1, soit 0 (<span class="math inline">a_i</span> n'est autre que le bit <span class="math inline">i</span> de <span class="math inline">d</span>). S'il est &#233;gal &#224; 0, le r&#233;sultat de <span class="math inline">(b^{2^i})^{a_i}</span> sera forc&#233;ment 1, et l'op&#233;ration sera alors bien plus rapide et diff&#233;rente en termes de temps qu'avec <span class="math inline">a_i = 1</span>, ce qui nous donne des informations sur des bits de <span class="math inline">d</span>. Il est possible d'utiliser ce principe afin de d&#233;couvrir <span class="math inline">d</span> en entier, simplement en demandant &#224; l'ordinateur de d&#233;chiffrer des messages bien sp&#233;cifiques.</p>
<p>Cette attaque ne s'applique pas uniquement &#224; RSA, et peut &#234;tre un aspect important de la s&#233;curit&#233; d'une impl&#233;mentation. Pour s'en prot&#233;ger, on peut par exemple effectuer des d&#233;lais dans le programme afin d'avoir un temps fixe pour chaque op&#233;ration n&#233;cessaire, ou encore utiliser une technique d'<a href="https://en.wikipedia.org/wiki/Blinding_%28cryptography%29">aveuglement</a>. Pour cette technique, avant de d&#233;chiffrer le message <span class="math inline">x</span>, l'ordinateur va prendre au hasard un nombre entier <span class="math inline">r</span> et calculer <span class="math inline">x&#39; = x \times r^e \mod n</span>, puis faire <span class="math inline">y&#39; = x&#39;^d \mod n</span>, et enfin <span class="math inline">y = \frac{y&#39;}{r} \mod n</span>. Ces op&#233;rations sont en r&#233;alit&#233; un simple chiffrement/d&#233;chiffrement, mais en utilisant une variable interm&#233;diaire <span class="math inline">r</span> qui rend alors impossible l'attaque par chronom&#233;trage car <span class="math inline">r</span> est choisi al&#233;atoirement par l'ordinateur.</p>
<p>Sachez qu'il y a des attaques dans la m&#234;me id&#233;e, mais se basant cette fois sur la consommation &#233;lectrique de l'ordinateur qui peut varier en fonction des op&#233;rations effectu&#233;es lors du d&#233;chiffrement.</p>
<h4 id="exemples-de-failles-dans-des-impl&#233;mentations">Exemples de failles dans des impl&#233;mentations</h4>
<p>La derni&#232;re attaque traite un type d'exploitation de mani&#232;re assez large car cela ne s'applique pas uniquement pour RSA. Mais de mani&#232;re bien plus g&#233;n&#233;ral, on trouve dans tous types de codes sources, et dans tous les domaines, des failles permettant de r&#233;aliser des attaques dessus. La cryptographie est loin d'&#234;tre une exception et il y a &#233;norm&#233;ment d'exemples d'attaques faites sur des syst&#232;mes apr&#232;s avoir trouv&#233; des failles de s&#233;curit&#233; importantes :</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Heartbleed">Heartbleed</a> : en 2014, une d&#233;couverte majeure dans la biblioth&#232;que <a href="https://www.openssl.org/">OpenSSL</a> permettait de r&#233;cup&#233;rer des informations secr&#232;tes &#224; cause d'une erreur d'impl&#233;mentation. La raison de cette attaque est que la librairie utilise une option appel&#233;e <em>heartbeat</em> qui permet de s'assurer que le client et le serveur sont toujours connect&#233;s, et elle fonctionne tr&#232;s simplement : le client envoie une requ&#234;te au serveur avec une cha&#238;ne de caract&#232;res al&#233;atoire, le serveur r&#233;cup&#232;re la requ&#234;te et renvoie la cha&#238;ne afin de montrer qu'il est toujours pr&#233;sent. Le probl&#232;me &#233;tait que la partie du code s'occupant de cette option ne v&#233;rifiait pas la taille indiqu&#233;e dans la requ&#234;te au sujet de la cha&#238;ne, c'est-&#224;-dire que je pouvais envoyer cette cha&#238;ne au serveur &quot;jIO91mq0x/&quot; et dire qu'elle fait 42 caract&#232;res, le serveur va alors me renvoyer les 42 derniers caract&#232;res qu'il a en m&#233;moire (dont la cha&#238;ne que je lui ai envoy&#233;e), ce qui peut rendre public des donn&#233;es sensibles comme des cl&#233;s priv&#233;es de chiffrement.</li>
<li>En d&#233;but d'ann&#233;e 2016, une faille critique dans <a href="http://www.openssh.com/">OpenSSH</a> donnait acc&#232;s aux cl&#233;s priv&#233;es SSH d'un utilisateur et donc d&#233;truisait toutes s&#233;curit&#233;s du syst&#232;me de chiffrement. Une option datant de 2010 (qui n'&#233;tait m&#234;me pas document&#233;e) &#233;tait activ&#233;e par d&#233;faut sur un client OpenSSH et permettait de se reconnecter automatiquement &#224; un serveur en cas de d&#233;connexion soudaine. Cette option exp&#233;rimentale pr&#233;sentait deux failles dont une permettait de r&#233;cup&#233;rer les cl&#233;s priv&#233;es SSH d'un utilisateur : <a href="https://www.qualys.com/2016/01/14/cve-2016-0777-cve-2016-0778/openssh-cve-2016-0777-cve-2016-0778.txt">Exemple concret d'exploitation de cette faille</a></li>
<li><p>En 2015, une faille &#233;norme dans le code des protocoles SSL/TLS d'Apple est d&#233;couverte avec notamment ce fameux code qui a beaucoup circul&#233; &#224; ce propos :</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">if</span> ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;signedParams)) != <span class="dv">0</span>)
    <span class="kw">goto</span> fail;
    <span class="kw">goto</span> fail;</code></pre></div>
O&#249; la ligne <code>goto fail;</code> est r&#233;p&#233;t&#233;e deux fois ce qui signifie qu'importe le r&#233;sultat du test pr&#233;c&#233;dent, la fonction ira de toute fa&#231;on au label <code>fail</code> sautant alors tous les tests de s&#233;curit&#233; qui sont situ&#233;s apr&#232;s. Ceci permettait &#224; une personne malveillante d'utiliser un certificat qui semblait &#234;tre correct, mais qui en r&#233;alit&#233; n'avait pas une bonne cl&#233; priv&#233;e associ&#233;e, afin d'avoir une connexion s&#233;curis&#233;e https qui paraissait authentique pour l'utilisateur alors que ce n'&#233;tait pas le cas.</li>
<li><p>Une recherche r&#233;cente a &#233;t&#233; rendue public fin 2015 lors de la conf&#233;rence 32 du <a href="https://en.wikipedia.org/wiki/Chaos_Computer_Club">Chaos Computer Club</a> dans laquelle Alex Halderman et Nadia Heninger exposent une attaque consistant &#224; forcer le serveur &#224; utiliser d'anciens protocoles moins s&#233;curis&#233;s que ceux de nos jours. La vid&#233;o de la conf&#233;rence (la partie concernant l'attaque commence &#224; 18min13) : <a href="http://www.youtube.com/watch?v=TfK5tf3ScR4" title="Logjam: Diffie-Hellman, discrete logs, the NSA, and you [32c3]"><img src="http://img.youtube.com/vi/TfK5tf3ScR4/0.jpg" alt="Logjam: Diffie-Hellman, discrete logs, the NSA, and you [32c3]" /></a></p></li>
</ul>
<p>M&#234;me si peu apr&#232;s la d&#233;couverte de ces failles, un patch a &#233;t&#233; rapidement propos&#233;, certaines exploitations sont pr&#233;sentes et possibles depuis plusieurs ann&#233;es dans des syst&#232;mes et n&#233;cessitent bien plus de mises &#224; jour de la part des utilisateurs. De nos jours, c'est une pratique r&#233;guli&#232;re d'organiser des concours o&#249; le but est de d&#233;couvrir le plus de failles et exploitations possibles dans une impl&#233;mentation en &#233;change d'argent pour la d&#233;couverte. Cela permet de maintenir des syst&#232;mes importants en termes de s&#233;curit&#233;, afin d'&#233;viter toutes failles critiques dans l'impl&#233;mentation.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Le syst&#232;me de chiffrement RSA est donc l'un des premiers algorithmes asym&#233;triques garantissant une s&#233;curit&#233; lors du chiffrement, mais surtout dans la transmission de la cl&#233;, en mettant en place des paires de cl&#233;s publiques et priv&#233;es. Sa s&#233;curit&#233; est bas&#233;e sur le fait qu'il est long et difficile de factoriser un nombre premier, et l'algorithme utilise plusieurs fonctions &#224; sens unique afin de garantir la s&#233;curit&#233; du message. Cependant s'il est mal utilis&#233; ou que la s&#233;curit&#233; est n&#233;glig&#233;e (pour gagner du temps par exemple), quelques exploitations sont envisageables et m&#234;me si aucunes n'est d'une importance majeure, elles ne sont pas &#224; sous-estimer. De plus les impl&#233;mentations d'un tel syst&#232;me sont parfois complexes &#224; mettre en place, et ont bien plus de chance d'&#234;tre vuln&#233;rable &#224; des attaques que l'algorithme en lui-m&#234;me. On d&#233;couvre chaque ann&#233;e de nombreuses failles dans des syst&#232;mes utilis&#233;s mondialement, mais bien plus rarement des attaques cassant compl&#232;tement un algorithme de chiffrement largement employ&#233;.</p>
<p>Aujourd'hui, les algorithmes de chiffrement asym&#233;triques ne sont pas forc&#233;ment le type d'algorithme le plus utilis&#233; car chiffrer/d&#233;chiffrer un long message peut &#234;tre tr&#232;s lent &#224; cause des fonctions utilis&#233;es. En revanche, on utilisera plut&#244;t un m&#233;lange entre les algorithmes sym&#233;triques et asym&#233;triques afin de garder les avantages des deux types de chiffrement (<strong>op&#233;rations rapides</strong> de chiffrement/d&#233;chiffrement pour un algorithme sym&#233;trique, et <strong>transmission s&#233;curis&#233;e</strong> de la cl&#233; pour un algorithme asym&#233;trique). On appelle ce principe, la <strong>cryptographie hybride</strong>, et l'un des premiers syst&#232;mes de ce genre fut l'<a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">&#233;change de cl&#233;s Diffie-Hellman</a> imagin&#233; par Diffie et Hellman, qui sont &#224; l'origine de l'utilisation d'algorithme de chiffrement asym&#233;trique. Actuellement, la base d'un syst&#232;me de cryptographie hybride est souvent l'algorithme sym&#233;trique <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> qui est tr&#232;s courant et fiable. Le gouvernement am&#233;ricain l'utilise comme standard et m&#234;me jusqu'&#224; des niveaux de classification top secrets, notamment gr&#226;ce &#224; sa rapidit&#233; et &#224; sa robustesse (aucunes r&#233;elles attaques ne sont connues pour le moment sur ce syst&#232;me de chiffrement). L'algorithme RSA ne sera donc que rarement utilis&#233; enti&#232;rement, mais plut&#244;t partiellement gr&#226;ce &#224; la cryptographie hybride, utilis&#233;e par exemple dans <a href="http://openpgp.org/">OpenPGP</a> ou encore <a href="https://gnupg.org/">GnuPG</a>.</p>
<p>Cependant, une nouvelle &#232;re dans le domaine de la cryptographie arrive : la <a href="https://en.wikipedia.org/wiki/Quantum_cryptography"><strong>cryptographie quantique</strong></a>. Cette derni&#232;re permettrait une transmission de la cl&#233; de mani&#232;re totalement s&#233;curis&#233;e et assurerait une protection garantie contre toutes techniques de cassage reposant sur des ph&#233;nom&#232;nes physiques classiques (c'est-&#224;-dire tous les ph&#233;nom&#232;nes non quantiques). Un excellent talk &#224; ce propos lors de la 32c3 :</p>
<p><a href="http://www.youtube.com/watch?v=424LHQQB2DE"><img src="http://img.youtube.com/vi/424LHQQB2DE/0.jpg" alt="Quantum Cryptography [32c3]" /></a></p>
<p>Mais avec cette nouvelle technologie, se d&#233;veloppe aussi les <a href="https://en.wikipedia.org/wiki/Quantum_computing"><strong>ordinateurs quantiques</strong></a>, bas&#233;s sur les lois de la <a href="https://en.wikipedia.org/wiki/Quantum_mechanics">physique quantique</a> et qui pourrait permettre th&#233;oriquement de casser n'importe quel syst&#232;me cryptographique moderne en tr&#232;s peu de temps. En effet, nos ordinateurs utilisent des ph&#233;nom&#232;nes physiques dit classiques, poss&#233;dant un seul <em>&#233;tat physique</em> &#224; la fois (0 ou 1 dans le cas des bits), mais les ordinateurs quantiques sont capables de prendre plusieurs &#233;tats diff&#233;rents <strong>en m&#234;me temps</strong>, gr&#226;ce aux propri&#233;t&#233;s de la <a href="https://en.wikipedia.org/wiki/Quantum_superposition">superposition</a> ou encore de l'<a href="https://en.wikipedia.org/wiki/Quantum_entanglement">intrication</a>. Ceci permettrait notamment de faire un nombre d'op&#233;rations consid&#233;rables en une fraction de seconde car au lieu de les faire une par une, on pourrait th&#233;oriquement toutes les faire en m&#234;me temps. Cette id&#233;e est loin d'&#234;tre nouvelle, et en 1994, Peter Shor pr&#233;senta l'<a href="https://en.wikipedia.org/wiki/Shor&#39;s_algorithm">algorithme de Shor</a> qui permet de factoriser un nombre entier en un temps polynomial sur un ordinateur quantique. Pour le moment, nous sommes encore <strong>loin</strong> d'utiliser l'algorithme de Shor sur un ordinateur quantique pour casser des cl&#233;s de chiffrement modernes, et m&#234;me encore loin d'avoir un ordinateur quantique fiable et assez stable. Mais il faut savoir que cette technologie se d&#233;veloppe rapidement, on entend beaucoup parler du fameux ordinateur quantique de <a href="https://en.wikipedia.org/wiki/D-Wave_Systems">D-Wave</a>, et m&#234;me si certains tests de rapidit&#233; sont assez <a href="http://news.mit.edu/2015/3q-scott-aaronson-google-quantum-computing-paper-1211">controvers&#233;s</a>, ce domaine reste extr&#234;mement int&#233;ressant et plein de potentiel pour de futures applications. Les ordinateurs quantiques nous permettraient de r&#233;soudre une quantit&#233; &#233;norme de probl&#232;mes dont la solution n&#233;cessite trop de temps pour de simples ordinateurs non quantiques. Mais dans le domaine de la cryptographie, ce genre de technologie pose probl&#232;me en termes de s&#233;curit&#233; car nos syst&#232;mes de chiffrement actuels reposent sur des probl&#232;mes math&#233;matiques que l'on ne sait pas r&#233;soudre rapidement avec des ordinateurs normaux (factorisation, <a href="https://en.wikipedia.org/wiki/Discrete_logarithm">logarithme discret</a>, <a href="https://en.wikipedia.org/wiki/Elliptic_curve_cryptography">courbes elliptiques</a>), et des chercheurs commencent donc d&#233;j&#224; &#224; chercher des algorithmes capables de r&#233;sister &#224; des attaques faites sur un ordinateur quantique pour se pr&#233;parer au mieux &#224; l'arriv&#233;e de ce genre d'ordinateur et &#224; la cryptographie <strong>post-quantique</strong>. Si le sujet vous int&#233;resse, voici une petite introduction &#224; la mati&#232;re lors d'une conf&#233;rence :</p>
<p><a href="http://www.youtube.com/watch?v=6XeBvdm8vao"><img src="http://img.youtube.com/vi/6XeBvdm8vao/0.jpg" alt="Post-quantum cryptography [32c3]" /></a></p>
 
      <!-- ------------ -->

      <footer>
         <br>
         <hr>
         <p>Une question ? Une suggestion ? N'h&#233;sitez pas &#224; me <a href="/a_propos.html">contacter</a> pour me communiquer vos remarques.
         <br>
      </footer>

      <!-- Automatically render all of the math inside the page with KaTeX -->
      <script>
         renderMathInElement(document.body);
      </script>

   </body>
</html>
