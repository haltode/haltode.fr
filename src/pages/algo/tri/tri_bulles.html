<!DOCTYPE html>
<html>
   <head>
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato&#38;subset=latin,latin-ext" type="text/css" />
      <link rel="icon" type="image/x-icon" href="//static.napnac.ga/img/favicon.ico">
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/github-gist.min.css">

      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script>

      <!-- CSS -->
<style>
body {
   font-family: "Helvetica Neue", 'Lato', Helvetica, sans-serif;
   max-width: 1000px;
   margin: 0 auto;
   position: relative;
   width: 95%;
   line-height: 1.5;
}

/* ---- Titles ---- */

h1 {
   padding-top: 2%;
   padding-bottom: 2%;
   color: #DE4834;
}

h2, h3, h4, h5, h6 {
   padding-top: 1%;
   padding-bottom: 1%;
   color: #DE4834;
}

/* ---- Link ---- */

a {
   text-decoration: none;
   color: #2E64FE;
}

/* ---- List (+ main menu list) ---- */

ul {
   padding-left: 30px;
}

#main_menu {
   list-style: none;
   margin: 0;
   padding: 0;
   text-align: center;
}
#main_menu li {
   display: inline;
   margin-right: 1px;
}
#main_menu li a {
   line-height: 1em;
   padding: 4px 20px;
   text-align: center;
}
#main_menu li a:hover, #main_menu li a:active {
   text-decoration: underline;
}

/* ---- Tables (same look as from github markdown layout) ---- */

table {
   display: block;
   width: 100%;
   overflow: auto;
   word-break: normal;
   word-break: keep-all;
   border-collapse: collapse;
   border-spacing: 0;
   margin-top: 0;
   margin-bottom: 16px;
}

table th {
   font-weight: bold;
}

table th,
table td {
   padding: 6px 13px;
   border: 1px solid #ddd;
}

table tr {
   background-color: #fff;
   border-top: 1px solid #ccc;
}

table tr:nth-child(2n) {
   background-color: #f8f8f8;
}

/* ---- Image and caption ---- */

.figure {
   text-align: center;
}

.caption {
   font-style: italic;
   text-align: center;
}

/* ---- Summary ---- */

#summary {
   width: 70%;
   text-align: justify;
   line-height: 1.6;
}

/* ---- Temporary css ---- */

.pret {
   background-color: #00CC00;
   display: inline;
}

.relire {
   background-color: #FF9900;
   display: inline;
}

.encours {
   background-color: #3366CC;
   display: inline;
}

.faire {
   background-color: #FF0000;
   display: inline;
}
</style>
      <!---- ---->

      <title>Tri à bulles - NapNac</title>
   </head>

   <body>

      <!-- Javascript -->
<script type="text/javascript">
function toggle_visibility(id) {
   var element = document.getElementById(id);
   if(element.style.display == 'block')
      element.style.display = 'none';
   else
      element.style.display = 'block';
}
</script>
      <!---- ---->

      <header>
         <a href="/">
            <img src="//static.napnac.ga/img/logo.png" alt="Logo du site" height="100" width="300">
         </a>

      </header>

      <nav>
         <ul id="main_menu">
            <li><a href="/">Accueil</a></li>
            <li><a href="/articles.html">Articles</a></li>
            <li><a href="/projets.html">Projets</a></li>
            <li><a href="/a_propos.html">A propos</a></li>
         </ul>
      </nav>

      <!-- Page/Article -->

<a href=""><h1 id="tri-&#224;-bulles">Tri &#224; bulles</h1></a>
<p>Publi&#233; le : 29/04/2014<br />
<em>Modifi&#233; le : 13/11/2015</em></p>
<ul id="summary">
<li><a href="#introduction">Introduction</a></li>
<li><a href="#principe-de-lalgorithme">Principe de l&#8217;algorithme</a></li>
<li><a href="#exemple">Exemple</a></li>
<li><a href="#pseudo-code">Pseudo-code</a></li>
<li><a href="#complexit&#233;">Complexit&#233;</a></li>
<li><a href="#impl&#233;mentation">Impl&#233;mentation</a></li>
<li><a href="#am&#233;liorations-et-variantes">Am&#233;liorations et variantes</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>Le tri &#224; bulles (<em>bubble sort</em> en anglais) est un algorithme de tri par comparaison tr&#232;s simple &#224; comprendre et &#224; impl&#233;menter, cependant c&#8217;est l&#8217;un des algorithmes de tri les plus inefficaces. En effet, il a une complexit&#233; quadratique : <em>O(N&#178;)</em>. Cet algorithme est tr&#232;s peu utilis&#233; &#224; cause de sa complexit&#233; en temps trop lente, mais c&#8217;est un bon exemple pour commencer &#224; travailler sur des algorithmes de tri. Il faut noter que le tri &#224; bulles est un algorithme de tri <a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability">stable</a> et <a href="https://en.wikipedia.org/wiki/In-place_algorithm">sur place</a>.</p>
<h2 id="principe-de-lalgorithme">Principe de l&#8217;algorithme</h2>
<p>Le tri &#224; bulles consiste &#224; <em>remonter</em> les &#233;l&#233;ments du tableau &#224; trier jusqu&#8217;&#224; leurs places d&#233;finitives, comme des bulles qui remontent dans un liquide (d&#8217;o&#249; son nom de tri &#224; bulles). L&#8217;algorithme compare chaque paire d&#8217;&#233;l&#233;ment du tableau, et les &#233;change si besoin en fonction du tri (croissant ou d&#233;croissant).</p>
<h2 id="exemple">Exemple</h2>
<p>Si l&#8217;on prend 8, 7, 1, 4, 6 comme suite de nombres, et que l&#8217;on utilise l&#8217;algorithme du tri &#224; bulles pour trier cette suite dans l&#8217;ordre croissant, voici comment l&#8217;algorithme fonctionne :</p>
<p><em>1er tour</em> :</p>
<p><strong>8</strong>, <strong>7</strong>, 1, 4, 6<br />
8 &gt; 7 donc on &#233;change<br />
7, <strong>8</strong>, <strong>1</strong>, 4, 6<br />
8 &gt; 1 donc on &#233;change<br />
7, 1, <strong>8</strong>, <strong>4</strong>, 6<br />
8 &gt; 4 donc on &#233;change<br />
7, 1, 4, <strong>8</strong>, <strong>6</strong><br />
8 &gt; 6 donc on &#233;change</p>
<p>7, 1, 4, 6, 8</p>
<p><em>2&#232;me tour</em> :</p>
<p><strong>7</strong>, <strong>1</strong>, 4, 6, 8<br />
7 &gt; 1 donc on &#233;change<br />
1, <strong>7</strong>, <strong>4</strong>, 6, 8<br />
7 &gt; 4 donc on &#233;change<br />
1, 4, <strong>7</strong>, <strong>6</strong>, 8<br />
7 &gt; 6 donc on &#233;change<br />
1, 4, 6, <strong>7</strong>, <strong>8</strong><br />
7 &lt; 8 donc on laisse</p>
<p>1, 4, 6, 7, 8</p>
<p>Notre algorithme va en r&#233;alit&#233; effectuer <em>N</em> tours de boucle (avec <em>N</em> &#233;tant la taille du tableau), sauf qu'ici au bout de deux tours notre tableau est d&#233;j&#224; tri&#233;, l'algorithme va donc continuer de parcourir mais en ne changeant rien puisque chaque paire de nombre est bien plac&#233;e.</p>
<p>Pour r&#233;sumer l'id&#233;e de l'algorithme :</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/tri/tri_bulles/exemple_tri.png" alt="Exemple de tri &#224; bulles" />
<p class="caption">Exemple de tri &#224; bulles</p>
</div>
<p>Les &#233;l&#233;ments en bleu sont ceux qu'on compare &#224; chaque it&#233;ration, la partie verte repr&#233;sente la partie du tableau dont on est s&#251;r qu'elle est tri&#233;e. A chaque tour, on compare chaque paire dans la partie non tri&#233;e du tableau, si la paire ne respecte pas l'ordre de tri (dans notre cas croissant), on &#233;change les &#233;l&#233;ments et on continue.</p>
<h2 id="pseudo-code">Pseudo-code</h2>
<p>Voici le pseudo-code tr&#232;s simple de l&#8217;algorithme du tri &#224; bulles :</p>
<pre class="nohighlight"><code>triBulles :

   Pour chaque &#233;l&#233;ment
      Parcourir le tableau
         Echanger les paires adjacentes si n&#233;cessaire</code></pre>
<h2 id="complexit&#233;">Complexit&#233;</h2>
<p>Comme dit dans l&#8217;introduction, la complexit&#233; en temps de l&#8217;algorithme du tri &#224; bulles est de <em>O(N&#178;)</em>, et on peut le d&#233;montrer simplement par le fait qu&#8217;il y a deux boucles imbriqu&#233;es dans le pseudo-code :</p>
<ul>
<li>La premi&#232;re boucle parcourt <em>N</em> tours.</li>
<li>La deuxi&#232;me boucle parcourt <em>N</em> tours aussi.</li>
</ul>
<p>On se retrouve donc avec <em>N * N</em> tours, soit une complexit&#233; finale en <em>O(N&#178;)</em>.</p>
<h2 id="impl&#233;mentation">Impl&#233;mentation</h2>
<p>L&#8217;impl&#233;mentation est aussi simple que le pseudo-code :</p>
<p>main.c :</p>
<h2 id="am&#233;liorations-et-variantes">Am&#233;liorations et variantes</h2>
<h3 id="arr&#234;ter-le-tri-quand-cest-possible">Arr&#234;ter le tri quand c'est possible</h3>
<p>On peut am&#233;liorer le tri &#224; bulles en faisant en sorte qu&#8217;il s&#8217;arr&#234;te lorsque le tableau est tri&#233;, et qu&#8217;il ne parcourt pas d&#8217;autres tours inutilement. Pour cela, il suffit de v&#233;rifier si l&#8217;on effectue un &#233;change ou pas dans le tour de boucle actuel, si ce n&#8217;est pas le cas le tableau est donc tri&#233;, on peut alors sortir de la boucle.</p>
<pre class="nohighlight"><code>Faire
   tableauPasTri&#233; -&gt; faux

   Pour chaque &#233;l&#233;ment du tableau
      Si l&#39;&#233;l&#233;ment i est sup&#233;rieur &#224; l&#39;&#233;l&#233;ment i + 1
         &#201;changer les &#233;l&#233;ments
         tableauPasTri&#233; -&gt; vrai

Tant que tableauPasTri&#233; est vrai</code></pre>
<p>La complexit&#233; reste en <em>O(N&#178;)</em>, puisque les quelques tours de boucle que l'on a gagn&#233;s dans certains cas ne vont pas &#234;tre assez cons&#233;quents pour influer sur la complexit&#233; en temps de l'algorithme.</p>
<h3 id="tri-&#224;-bulles-bidirectionnel">Tri &#224; bulles bidirectionnel</h3>
<p>Le tri &#224; bulles bidirectionnel (<em>bidirectional bubble sort</em>) est une variante qui consiste &#224; trier dans les deux directions (d&#8217;o&#249; son nom). L&#224; o&#249; le tri &#224; bulles parcourt seulement de gauche &#224; droite (ou de droite &#224; gauche, &#231;a n&#8217;importe pas), le tri &#224; bulles bidirectionnel parcourt de gauche &#224; droite et de droite &#224; gauche. Cela permet d&#8217;optimiser le tri de certains &#233;l&#233;ments comme les petits &#233;l&#233;ments situ&#233;s en fin de tableau, le tri &#224; bulles les ram&#232;ne d&#8217;un seul emplacement &#224; chaque tour de boucle, alors que le tri &#224; bulles bidirectionnel les ram&#232;ne en un seul tour.</p>
<p>Par exemple avec la suite de nombres suivante : 2, 3, 4, 5, 1. On voit que tous les &#233;l&#233;ments sont tri&#233;s sauf le dernier, on va donc se concentrer dessus pour comparer les deux tris :</p>
<p><em>Tri &#224; bulles</em></p>
<table>
<thead>
<tr class="header">
<th align="left">Tour</th>
<th align="left">Tableau</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left">2, 3, 4, 5, <strong>1</strong></td>
</tr>
<tr class="even">
<td align="left">1er</td>
<td align="left">2, 3, 4, <strong>1</strong>, 5</td>
</tr>
<tr class="odd">
<td align="left">2&#232;me</td>
<td align="left">2, 3, <strong>1</strong>, 4, 5</td>
</tr>
<tr class="even">
<td align="left">3&#232;me</td>
<td align="left">2, <strong>1</strong>, 3, 4, 5</td>
</tr>
<tr class="odd">
<td align="left">4&#232;me</td>
<td align="left"><strong>1</strong>, 2, 3, 4, 5</td>
</tr>
</tbody>
</table>
<p><em>Tri &#224; bulles bidirectionnel</em></p>
<table>
<thead>
<tr class="header">
<th align="left">Tour</th>
<th align="left">Tableau</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left">2, 3, 4, 5, <strong>1</strong></td>
</tr>
<tr class="even">
<td align="left">1er</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">de gauche &#224; droite</td>
<td align="left">2, 3, 4, <strong>1</strong>, 5</td>
</tr>
<tr class="even">
<td align="left">de droite &#224; gauche</td>
<td align="left"><strong>1</strong>, 2, 3, 4, 5</td>
</tr>
</tbody>
</table>
<p>Dans cet exemple, le tri &#224; bulles bidirectionnel n&#8217;a besoin que d'un seul tour de boucle alors que le tri &#224; bulles en a besoin de quatre.</p>
<p>Le pseudo-code du tri &#224; bulles bidirectionnel :</p>
<pre class="nohighlight"><code>Faire
   tableauPasTri&#233; -&gt; faux

   Pour chaque &#233;l&#233;ment du tableau (gauche &#224; droite)
      Si l&#39;&#233;l&#233;ment i est sup&#233;rieur &#224; l&#39;&#233;l&#233;ment i + 1
         &#201;changer les &#233;l&#233;ments
         tableauPasTri&#233; -&gt; vrai

   Pour chaque &#233;l&#233;ment du tableau (droite &#224; gauche)
      Si l&#39;&#233;l&#233;ment i est inf&#233;rieur &#224; l&#39;&#233;l&#233;ment i - 1
         &#201;changer les &#233;l&#233;ments
         tableauPasTri&#233; -&gt; vrai

Tant que tableauPasTri&#233; est vrai</code></pre>
<p>Cette variante peut &#234;tre encore optimis&#233;e, en retenant l&#8217;endroit o&#249; le dernier &#233;change s&#8217;est effectu&#233; pour ne pas aller plus loin (car c&#8217;est inutile), cependant cet algorithme a toujours pour complexit&#233; <em>O(N&#178;)</em>.</p>
<h3 id="tri-&#224;-peigne">Tri &#224; peigne</h3>
<p>Une autre variante du tri &#224; bulles appel&#233;e le tri &#224; peigne (<em>comb sort</em> en anglais), permet &#224; l&#8217;algorithme du tri &#224; bulles d&#8217;&#234;tre bien plus efficace et ainsi rivaliser avec des algorithmes plus performants comme le <a href="/algo/tri/tri_rapide.html">tri rapide</a>, le <a href="/algo/tri/tri_fusion.html">tri fusion</a>, ou encore le <a href="/algo/tri/tri_tas.html">tri par tas</a>. Cet algorithme va comparer des &#233;l&#233;ments du tableau &#224; un certain intervalle au lieu de comparer les &#233;l&#233;ments voisins. En effet, cette technique permet d&#8217;&#233;liminer le probl&#232;me du petit &#233;l&#233;ment situ&#233; &#224; la fin du tableau qui remonte lentement jusqu&#8217;&#224; sa place initiale, et souvent rend les comparaisons entre &#233;l&#233;ments plus judicieuses. Un intervalle optimal est initialis&#233; avec une valeur de <em>N / 1.3</em> (cette valeur est reconnue comme &#233;tant une des plus optimales pour ce tri), et &#224; chaque tour on divise de nouveau par 1.3 l'intervalle tant qu'il est sup&#233;rieur &#224; 1.</p>
<pre class="nohighlight"><code>Faire
   tableauPasTri&#233; -&gt; faux
   intervalle -&gt; intervalle / 1.3 (valeur enti&#232;re)

   Si intervalle est inf&#233;rieur &#224; 1
      intervalle -&gt; 1

   Pour chaque &#233;l&#233;ment du tableau
      Si l&#39;&#233;l&#233;ment i est sup&#233;rieur &#224; l&#39;&#233;l&#233;ment i + intervalle
         &#201;changer les &#233;l&#233;ments
         tableauPasTri&#233; -&gt; vrai

Tant que tableauPasTri&#233; est vrai OU intervalle est sup&#233;rieur &#224; 1</code></pre>
<p>La complexit&#233; moyenne de ce tri est <em>O(N * log N)</em>, mais peut-&#234;tre dans le pire des cas en <em>O(N&#178;)</em> bien qu&#8217;en pratique c&#8217;est peu probable.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Le tri &#224; bulles est certes un algorithme de tri assez lent (complexit&#233; en <em>O(N&#178;)</em>), mais reste une id&#233;e facile &#224; comprendre et &#224; impl&#233;menter. De plus, quelques am&#233;liorations le rendent plus rapide jusqu'&#224; m&#234;me avoir une complexit&#233; en <em>O(N log N)</em>. Cependant en pratique, ce tri est tr&#232;s peu employ&#233; &#224; cause de ses utilisations trop pr&#233;cises et qui sont uniquement sur des donn&#233;es sp&#233;cifiques, que vous ne rencontrerez sans doute jamais.</p>
 
      <!-- ------------ -->

      <footer>
         <br>
         <p style="text-align: center;"><a href="https://sous-surveillance.fr"><img style="border: 0;" 
         src="//static.napnac.ga/img/PJL_banner.png" alt="Non à la loi renseignement" 
         title="Non à la loi renseignement" height="60" width="468" /></a></p>
      </footer>
   </body>
</html>
