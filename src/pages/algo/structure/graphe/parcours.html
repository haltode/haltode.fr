<!DOCTYPE html>
<html>
   <head>
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato&#38;subset=latin,latin-ext" type="text/css" />
      <link rel="icon" type="image/x-icon" href="//static.napnac.ga/img/favicon.ico">
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/github-gist.min.css">

      <!-- Syntax highlighting -->
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script>

      <!-- Renders LaTeX expression -->
      <script type="text/x-mathjax-config">
         MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
      </script>
      <script type="text/javascript" async
         src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">
      </script>

      <!-- CSS -->
<style>
body {
   font-family: "Helvetica Neue", 'Lato', Helvetica, sans-serif;
   max-width: 1000px;
   margin: 0 auto;
   position: relative;
   width: 95%;
   line-height: 1.5;
}

/* ---- Titles ---- */

h1 {
   padding-top: 2%;
   padding-bottom: 2%;
   color: #DE4834;
}

h2, h3, h4, h5, h6 {
   padding-top: 1%;
   padding-bottom: 1%;
   color: #DE4834;
}

/* ---- Link ---- */

a {
   text-decoration: none;
   color: #2E64FE;
}

/* ---- List (+ main menu list) ---- */

ul {
   padding-left: 30px;
}

#main_menu {
   list-style: none;
   margin: 0;
   padding: 0;
   text-align: center;
}
#main_menu li {
   display: inline;
   margin-right: 1px;
}
#main_menu li a {
   line-height: 1em;
   padding: 4px 20px;
   text-align: center;
}
#main_menu li a:hover, #main_menu li a:active {
   text-decoration: underline;
}

/* ---- Tables (same look as from github markdown layout) ---- */

table {
   display: block;
   width: 100%;
   overflow: auto;
   word-break: normal;
   word-break: keep-all;
   border-collapse: collapse;
   border-spacing: 0;
   margin-top: 0;
   margin-bottom: 16px;
}

table th {
   font-weight: bold;
}

table th,
table td {
   padding: 6px 13px;
   border: 1px solid #ddd;
}

table tr {
   background-color: #fff;
   border-top: 1px solid #ccc;
}

table tr:nth-child(2n) {
   background-color: #f8f8f8;
}

/* ---- Image and caption ---- */

.figure {
   text-align: center;
}

.caption {
   font-style: italic;
   text-align: center;
}

/* ---- Summary ---- */

#summary {
   width: 70%;
   text-align: justify;
   line-height: 1.6;
}

/* ---- Code ---- */
pre {
   width: 90%;
   white-space: pre-wrap;
   word-break: break-all;
   word-wrap: break-word;
}

/* ---- Articles ---- */

.non_publie {
   font-style: italic;
   display: inline;
}

/* ---- Temporary css ---- */

.pret {
   background-color: #00CC00;
   display: inline;
}

.relire {
   background-color: #FF9900;
   display: inline;
}

.faire {
   background-color: #FF0000;
   display: inline;
}
</style>
      <!---- ---->

      <title>Parcours d'un graphe - NapNac</title>
   </head>

   <body>

      <!-- Javascript -->
<script type="text/javascript">
function toggle_visibility(id) {
   var element = document.getElementById(id);
   if(element.style.display == 'block')
      element.style.display = 'none';
   else
      element.style.display = 'block';
}
</script>
      <!---- ---->

      <header>
         <a href="/">
            <img src="//static.napnac.ga/img/logo.png" alt="Logo du site" height="100" width="300">
         </a>

      </header>

      <nav>
         <ul id="main_menu">
            <li><a href="/">Accueil</a></li>
            <li><a href="/articles.html">Articles</a></li>
            <li><a href="/projets.html">Projets</a></li>
            <li><a href="/a_propos.html">A propos</a></li>
         </ul>
      </nav>

      <!-- Page/Article -->

<a href=""><h1 id="parcours-dun-graphe">Parcours d'un graphe</h1></a>
<p>Publi&#233; le : 07/12/2015<br />
<em>Modifi&#233; le : 13/12/2015</em></p>
<ul id="summary">
<li><a href="#introduction">Introduction</a></li>
<li><a href="#le-parcours-en-profondeur">Le parcours en profondeur</a></li>
<li><a href="#le-parcours-en-largeur">Le parcours en largeur</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>Le parcours d'un <a href="/algo/structure/graphe.html">graphe</a> est une op&#233;ration essentielle &#224; conna&#238;tre &#224; propos de cette structure. Il est fondamental de maitriser les diff&#233;rents algorithmes de parcours de graphe, ainsi que leur application et surtout savoir quand les utiliser en fonction de la situation.</p>
<h2 id="le-parcours-en-profondeur">Le parcours en profondeur</h2>
<p>Vous vous trouvez dans un labyrinthe contenant de nombreux chemins possibles, et vous cherchez la sortie alors que vous ne connaissez aucunes indications sur ce labyrinthe. Tout d'abord, on peut repr&#233;senter notre labyrinthe comme un graphe dit <em>implicite</em>, qui sera non pond&#233;r&#233; (chaque arc aura alors une distance de <em>1</em> unit&#233;). En effet, chaque intersection sera repr&#233;sent&#233;e par un n&#339;ud du graphe, et chaque chemin par un arc. L'entr&#233;e et la sortie du labyrinthe sont juste de simples n&#339;uds distincts du graphe, et le fait de trouver la sortie du labyrinthe, revient &#224; trouver un chemin reliant le n&#339;ud d'entr&#233;e au n&#339;ud de sortie :</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/structure/graphe/dfs/labyrinthe_graphe.png" alt="Exemple de repr&#233;sentation d&#39;un labyrinthe sous forme de graphe" />
<p class="caption">Exemple de repr&#233;sentation d'un labyrinthe sous forme de graphe</p>
</div>
<p>Vu qu'on ne connait rien sur ce labyrinthe, il est impossible de deviner le chemin nous permettant d'arriver &#224; la sortie puisque &#231;a pourrait &#234;tre n'importe lequel du graphe. On peut donc tout simplement essayer chacun des chemins jusqu'&#224; trouver le bon. Ce parcours est alors qualifi&#233; de : parcours en profondeur.</p>
<h3 id="principe">Principe</h3>
<p>Le parcours en profondeur (ou plus commun&#233;ment <em>DFS</em> pour <em>Depth First Search</em>) permet de parcourir un graphe en utilisant le principe de la <a href="https://en.wikipedia.org/wiki/Recursion_%28computer_science%29">r&#233;cursivit&#233;</a>. Ce parcours visite les n&#339;uds du graphe les plus &quot;profonds&quot; en premier (c'est-&#224;-dire les plus &#233;loign&#233;s du n&#339;ud de d&#233;part), avant de &quot;remonter&quot; progressivement dans le graphe.</p>
<p>Dans notre cas du labyrinthe, on essaie un chemin jusqu'&#224; &#234;tre bloqu&#233;, puis on revient &#224; la derni&#232;re intersection, on continue jusqu'&#224; &#234;tre bloqu&#233;, on revient &#224; la derni&#232;re intersection, etc. jusqu'&#224; tomber sur la sortie.</p>
<h3 id="exemple">Exemple</h3>
<p>La meilleure mani&#232;re de comprendre ce type de parcours est de le visualiser :</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/structure/graphe/dfs/exemple_dfs.png" alt="Exemple de DFS sur un graphe" />
<p class="caption">Exemple de DFS sur un graphe</p>
</div>
<p>Ce graphe repr&#233;sente notre labyrinthe, et chaque n&#339;ud correspond &#224; l'ordre de parcours du DFS (la fl&#232;che montre uniquement comment agit un parcours en profondeur en entier sur notre graphe).</p>
<p>Si par exemple notre entr&#233;e de labyrinthe est le n&#339;ud 1, et que notre sortie est le n&#339;ud 6, on parcourra avant de trouver la sortie, les n&#339;uds 2, 3, 4, et 5.</p>
<p>Cependant sur un graphe, on peut effectuer un DFS de diff&#233;rentes fa&#231;ons en fonction de l'ordre de visite des voisins. Par exemple, on aurait pu apr&#232;s le n&#339;ud 1 visiter le n&#339;ud 7, puis le 9, puis le 8, puis le 6, le 2, le 4, le 5, et enfin le 3. Ce parcours est bien un DFS, mais il est juste diff&#233;rent car on a choisi un autre ordre pour parcourir les voisins des n&#339;uds rencontr&#233;s.</p>
<h3 id="pseudo-code">Pseudo-code</h3>
<p>On utilise le principe de la r&#233;cursivit&#233; pour d&#233;finir notre parcours en profondeur :</p>
<pre class="nohighlight"><code>DFS (noeud) :
  
   Marquer le n&#339;ud comme visit&#233;

   Pour chaque voisin du n&#339;ud pass&#233; en param&#232;tre
      Si le voisin n&#39;est pas marqu&#233; visit&#233;
         DFS(voisin)</code></pre>
<p>Si par exemple on cherche un n&#339;ud de sortie dans notre graphe, on pourrait rajouter une condition qui arr&#234;tera le DFS lorsqu'on a visit&#233; ce n&#339;ud. Cependant ici, le DFS parcourt tout le graphe &#224; titre d'exemple.</p>
<h3 id="complexit&#233;">Complexit&#233;</h3>
<p>Dans le pire des cas, si notre sortie est le dernier n&#339;ud que l'on visite, notre algorithme va devoir parcourir les <span class="math inline">\(M\)</span> arcs du graphe, on a donc une complexit&#233; en temps lin&#233;aire de <span class="math inline">\(O(M)\)</span>.</p>
<h3 id="impl&#233;mentation">Impl&#233;mentation</h3>
<p>On peut impl&#233;menter un DFS de deux mani&#232;res diff&#233;rentes, m&#234;me si on a plut&#244;t tendance &#224; le coder de mani&#232;re r&#233;cursive car le code est plus court et plus intuitif.</p>
<h4 id="r&#233;cursif">R&#233;cursif</h4>
<p>Une impl&#233;mentation r&#233;cursive en C++ (j'utilise le C++ afin d'avoir les <code>vector</code> pour repr&#233;senter notre graphe) :</p>
<a href="javascript:toggle_visibility('dfs_recursif.cpp');">dfs_recursif.cpp</a>
<div id="dfs_recursif.cpp" style="display: none;">
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> NB_NOEUD_MAX = <span class="dv">1000</span>;

vector &lt;<span class="dt">int</span>&gt; graphe[NB_NOEUD_MAX];
<span class="dt">bool</span> dejaVu[NB_NOEUD_MAX];

<span class="dt">void</span> DFS(<span class="dt">int</span> noeud)
{
   printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, noeud);

   dejaVu[noeud] = <span class="kw">true</span>;

   <span class="dt">int</span> iVoisin;
   <span class="kw">for</span>(iVoisin = <span class="dv">0</span>; iVoisin &lt; graphe[noeud].size(); ++iVoisin)
      <span class="kw">if</span>(!dejaVu[graphe[noeud][iVoisin]])
         DFS(graphe[noeud][iVoisin]);
}

<span class="dt">int</span> main(<span class="dt">void</span>)
{
   <span class="dt">int</span> nbArc;
   <span class="dt">int</span> iArc;

   scanf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, &amp;nbArc);
   <span class="kw">for</span>(iArc = <span class="dv">0</span>; iArc &lt; nbArc; ++iArc) {
      <span class="dt">int</span> noeud1, noeud2;       
      scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d\n</span><span class="st">&quot;</span>, &amp;noeud1, &amp;noeud2);
      graphe[noeud1].push_back(noeud2);
   }
   
   DFS(<span class="dv">1</span>);

   <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</div>
<p>Si en entr&#233;e on donne notre graphe (celui de l'exemple et sous forme d'une liste d'arcs) :</p>
<pre class="nohighlight"><code>8
1 2
1 6
1 7
2 3
2 4
4 5
7 8
7 9</code></pre>
<p>On obtient bien en sortie :</p>
<pre class="nohighlight"><code>1 2 3 4 5 6 7 8 9</code></pre>
<p>Et pour vous montrer que l'ordre d'un parcours en profondeur peut changer selon l'ordre des voisins visit&#233;s, prenons le m&#234;me graphe mais avec un ordre diff&#233;rent dans sa description (l'ordre inverse) :</p>
<pre class="nohighlight"><code>8
1 7
1 6
1 2
7 9
7 8
2 4
2 3
4 5</code></pre>
<p>En sortie cette fois on a :</p>
<pre class="nohighlight"><code>1 7 9 8 6 2 4 5 3</code></pre>
<h4 id="it&#233;ratif">It&#233;ratif</h4>
<p>Il est rare d'impl&#233;menter de fa&#231;on it&#233;rative un parcours en profondeur, mais cela peut &#234;tre utile pour ne pas faire exploser la <a href="https://en.wikipedia.org/wiki/Call_stack">pile d'appels</a> &#224; cause des nombreux appels r&#233;cursifs imbriqu&#233;s provoqu&#233;s par notre derni&#232;re impl&#233;mentation.</p>
<p>Pour passer de la version r&#233;cursive &#224; la version it&#233;rative, on utilise simplement une <a href="/algo/structure/pile.html">pile</a> afin de &quot;simuler&quot; la pile d'appel. En effet lorsqu'on visite un n&#339;ud, on veut visiter tout de suite ses voisins, il faut donc les placer dans l'ordre de visite avant les autres n&#339;uds, on va donc les empiler afin de les parcourir d'abord.</p>
<a href="javascript:toggle_visibility('dfs_iteratif.cpp');">dfs_iteratif.cpp</a>
<div id="dfs_iteratif.cpp" style="display: none;">
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;stack&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> NB_NOEUD_MAX = <span class="dv">1000</span>;

vector &lt;<span class="dt">int</span>&gt; graphe[NB_NOEUD_MAX];
<span class="dt">bool</span> dejaVu[NB_NOEUD_MAX];

<span class="dt">void</span> DFS(<span class="dt">int</span> debut)
{
   stack &lt;<span class="dt">int</span>&gt; pile;
   <span class="dt">int</span> actuel;
   <span class="dt">int</span> iVoisin;

   pile.push(debut);

   <span class="kw">while</span>(!pile.empty()) {
      actuel = pile.top();
      pile.pop();

      printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, actuel);

      dejaVu[actuel] = <span class="kw">true</span>;

      <span class="kw">for</span>(iVoisin = <span class="dv">0</span>; iVoisin &lt; graphe[actuel].size(); ++iVoisin)
         <span class="kw">if</span>(!dejaVu[graphe[actuel][iVoisin]])
            pile.push(graphe[actuel][iVoisin]);
   }
}

<span class="dt">int</span> main(<span class="dt">void</span>)
{
   <span class="dt">int</span> nbArc;
   <span class="dt">int</span> iArc;

   scanf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, &amp;nbArc);
   <span class="kw">for</span>(iArc = <span class="dv">0</span>; iArc &lt; nbArc; ++iArc) {
      <span class="dt">int</span> noeud1, noeud2;       
      scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d\n</span><span class="st">&quot;</span>, &amp;noeud1, &amp;noeud2);
      graphe[noeud1].push_back(noeud2);
   }
   
   DFS(<span class="dv">1</span>);

   <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</div>
<p>En entr&#233;e :</p>
<pre class="nohighlight"><code>8
1 2
1 6
1 7
2 3
2 4
4 5
7 8
7 9</code></pre>
<p>Et la sortie affich&#233;e :</p>
<pre class="nohighlight"><code>1 7 9 8 6 2 4 5 3</code></pre>
<p>Et si on donne notre entr&#233;e modifi&#233;e (&#224; l'envers) :</p>
<pre class="nohighlight"><code>8
1 7
1 6
1 2
7 9
7 8
2 4
2 3
4 5</code></pre>
<p>On a en sortie cette fois :</p>
<pre class="nohighlight"><code>1 2 3 4 5 6 7 8 9</code></pre>
<p>Vous constatez donc que la pile &quot;inverse&quot; l'ordre, tout simplement car lorsqu'on parcourt la liste des voisins, on ne visite pas le voisin d&#232;s qu'on en a trouv&#233; un non visit&#233; (comme le fait la version r&#233;cursive), mais on les empile tous, et ils vont donc se superposer (ce qui va &quot;inverser&quot; l'ordre car c'est le principe d'une pile : le dernier arriv&#233;, le premier sorti).</p>
<h2 id="le-parcours-en-largeur">Le parcours en largeur</h2>
<p>Vous vous retrouvez face &#224; l'entr&#233;e du labyrinthe, mais cette fois ci vous cherchez le nombre de pas minimum que vous devez faire pour atteindre la sortie. Ce probl&#232;me peut &#234;tre vu comme un plus court chemin, mais notre graphe implicite est <strong>non pond&#233;r&#233;</strong> contrairement aux autres algorithmes &quot;classiques&quot; de <a href="/algo/structure/graphe/plus_court_chemin.html">plus court chemin</a> o&#249; le graphe est pond&#233;r&#233; (positivement ou n&#233;gativement). Cela revient donc &#224; trouver un chemin entre l'entr&#233;e et la sortie comportant un minimum de n&#339;uds possible (vu que les arcs ont chacun une distance de <em>1</em> unit&#233;). Mais de nouveau nous n'avons aucunes informations sur le labyrinthe, et la sortie pourrait se trouver n'importe o&#249;.</p>
<p>Essayons tout d'abord de voir si on peut r&#233;utiliser un algorithme de parcours en profondeur pour r&#233;soudre notre probl&#232;me :</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/structure/graphe/bfs/dfs_vs_bfs.png" alt="Exemple de labyrinthe" />
<p class="caption">Exemple de labyrinthe</p>
</div>
<p>Dans cet exemple, on fait un DFS sur notre graphe et &#224; cause de l'ordre de parcours des voisins on arrive &#224; la sortie (le n&#339;ud vert) en passant par les n&#339;uds 2, 3 et 4 alors qu'on peut y acc&#233;der en passant uniquement par le n&#339;ud 6. Bien s&#251;r notre DFS aurait pu passer par le n&#339;ud 6 en premier et ainsi atteindre la sortie le plus rapidement possible, mais cet exemple montre l'un des probl&#232;mes du DFS pour ce genre d'exercice, c'est que le r&#233;sultat de l'algorithme d&#233;pend de l'ordre de parcours des voisins qui peut totalement changer en fonction de l'impl&#233;mentation mais aussi en fonction du graphe. Il nous faut donc un algorithme de parcours qui ne d&#233;pend d'aucuns de ces facteurs, et qui nous permet de trouver le chemin le plus court sur un graphe non pond&#233;r&#233; : le parcours en largeur.</p>
<h3 id="principe-1">Principe</h3>
<p>Le parcours en largeur (ou <em>BFS</em> pour <em>Breadth First Search</em>), visite les n&#339;uds du graphe par ordre de profondeur. C'est-&#224;-dire que l'algorithme va d'abord visiter les n&#339;uds &#224; une profondeur de 1 par rapport au n&#339;ud de d&#233;part, puis &#224; une profondeur de 2, de 3, etc. On parcourt le graphe &quot;couche par couche&quot; contrairement au parcours en profondeur qui lui va chercher &#224; aller le plus loin possible d'abord pour ensuite remonter.</p>
<p>Cela permet donc de trouver le plus court chemin sur un graphe <strong>non pond&#233;r&#233;</strong>, car l'algorithme va regarder si on peut atteindre la sortie en parcourant un n&#339;ud de distance par rapport &#224; l'entr&#233;e, puis deux n&#339;uds, puis trois, etc. jusqu'&#224; trouver la sortie. Finalement, on est s&#251;r d'avoir trouv&#233; le plus court chemin car il n'y a pas d'autres chemins comportant moins de n&#339;uds pour acc&#233;der &#224; la sortie.</p>
<h3 id="exemple-1">Exemple</h3>
<p>Avec le m&#234;me graphe que pour le DFS, mais en appliquant un BFS dessus :</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/structure/graphe/bfs/exemple_bfs.png" alt="Exemple de BFS sur un graphe" />
<p class="caption">Exemple de BFS sur un graphe</p>
</div>
<p>De m&#234;me, chaque n&#339;ud repr&#233;sente l'ordre de parcours dans le graphe, et on retrouve bien cette id&#233;e de parcours par couche.</p>
<h3 id="pseudo-code-1">Pseudo-code</h3>
<p>Pour impl&#233;menter ce syst&#232;me de parcours par niveau, on va utiliser une <a href="/algo/structure/file.html">file</a>. En effet, quand on est sur une couche <span class="math inline">\(N\)</span>, on veut que les voisins qu'on va parcourir lors de la couche <span class="math inline">\(N + 1\)</span> soient tous situ&#233;s apr&#232;s les n&#339;uds de la couche <span class="math inline">\(N\)</span> que l'on visite actuellement, on veut donc qu'ils arrivent &#224; la fin et ce principe respecte l'ordre du premier entr&#233;, premier sorti qu'on appelle aussi une file.</p>
<pre class="nohighlight"><code>BFS (depart) :

   Enfiler le n&#339;ud de d&#233;part
   
   Tant que la file n&#39;est pas vide
      D&#233;filer le n&#339;ud au d&#233;but de la file

      Marquer le n&#339;ud comme visit&#233;
      Pour chaque voisin du n&#339;ud
         Si le voisin n&#39;est pas visit&#233;
            Enfiler le voisin</code></pre>
<h3 id="complexit&#233;-1">Complexit&#233;</h3>
<p>Comme pour le parcours en profondeur, si notre sortie est le dernier n&#339;ud que l'on visite on aura une complexit&#233; en <span class="math inline">\(O(M)\)</span> avec <span class="math inline">\(M\)</span> le nombre d'arcs du graphe.</p>
<h3 id="impl&#233;mentation-1">Impl&#233;mentation</h3>
<p>L'impl&#233;mentation du parcours en largeur en C++ (afin d'avoir le type <code>queue</code> et <code>vector</code>) :</p>
<a href="javascript:toggle_visibility('bfs.cpp');">bfs.cpp</a>
<div id="bfs.cpp" style="display: none;">
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;queue&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> NB_NOEUD_MAX = <span class="dv">1000</span>;

vector &lt;<span class="dt">int</span>&gt; graphe[NB_NOEUD_MAX];
<span class="dt">bool</span> dejaVu[NB_NOEUD_MAX];

<span class="dt">void</span> BFS(<span class="dt">int</span> debut)
{
   queue &lt;<span class="dt">int</span>&gt; file;
   <span class="dt">int</span> actuel;
   <span class="dt">int</span> iVoisin;

   file.push(debut);

   <span class="kw">while</span>(!file.empty()) {
      actuel = file.front();
      file.pop();

      printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, actuel);

      dejaVu[actuel] = <span class="kw">true</span>;

      <span class="kw">for</span>(iVoisin = <span class="dv">0</span>; iVoisin &lt; graphe[actuel].size(); ++iVoisin)
         <span class="kw">if</span>(!dejaVu[graphe[actuel][iVoisin]])
            file.push(graphe[actuel][iVoisin]);
   }
}

<span class="dt">int</span> main(<span class="dt">void</span>)
{
   <span class="dt">int</span> nbArc;
   <span class="dt">int</span> iArc;

   scanf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, &amp;nbArc);
   <span class="kw">for</span>(iArc = <span class="dv">0</span>; iArc &lt; nbArc; ++iArc) {
      <span class="dt">int</span> noeud1, noeud2;       
      scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d\n</span><span class="st">&quot;</span>, &amp;noeud1, &amp;noeud2);
      graphe[noeud1].push_back(noeud2);
   }

   BFS(<span class="dv">1</span>);

   <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</div>
<p>Notre graphe :</p>
<pre class="nohighlight"><code>8
1 2
1 3
1 4
2 5
2 6
4 7
4 8
6 9</code></pre>
<p>La sortie :</p>
<pre class="nohighlight"><code>1 2 3 4 5 6 7 8 9</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>Savoir parcourir un graphe est fondamental pour utiliser d'autres algorithmes de graphe plus complexes, et il existe deux types de parcours qu'il faut conna&#238;tre et maitriser pour les utiliser au bon moment :</p>
<ul>
<li><strong>Parcours en profondeur</strong> : on l'utilisera pour trouver un chemin quelconque entre deux n&#339;uds du graphe (par exemple entre l'entr&#233;e et la sortie d'un labyrinthe), pour d&#233;tecter des cycles dans un graphe, pour en trouver ses composantes fortement connexes, afin de cr&#233;er un tri topologique, ou encore un circuit eul&#233;rien, mais cette id&#233;e de parcourir en profondeur sert aussi pour le backtracking.</li>
<li><strong>Parcours en largeur</strong> : comme nous l'avons vu, le BFS sert &#224; trouver le plus court chemin dans un graphe non pond&#233;r&#233;, mais on l'utilise aussi pour l'algorithme de flot maximum d'un graphe, et pour tester si un graphe est biparti ou non.</li>
</ul>
<p>Toutes ces applications des deux algorithmes ne sont que des exemples, et le parcours choisi d&#233;pendra &#233;norm&#233;ment du graphe en entr&#233;e. Il faut toujours r&#233;fl&#233;chir au probl&#232;me donn&#233; avant d'utiliser un parcours (par exemple si on cherche un n&#339;ud pr&#233;cis et que ce dernier se situe proche du n&#339;ud de d&#233;part, un DFS sera un mauvais choix face au BFS). Il n'y a pas de mani&#232;re de savoir quand utiliser l'un pas rapport &#224; l'autre, &#224; part en pratiquant le plus possible les deux types de parcours pour maitriser les avantages/d&#233;savantages et leurs utilisations.</p>
 
      <!-- ------------ -->

      <footer>
         <br>
      </footer>

   </body>
</html>
