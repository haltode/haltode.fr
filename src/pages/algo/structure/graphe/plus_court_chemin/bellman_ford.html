<!DOCTYPE html>
<html>
   <head>
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato&#38;subset=latin,latin-ext" type="text/css" />
      <link rel="icon" type="image/x-icon" href="//static.napnac.ga/img/favicon.ico">
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/github-gist.min.css">

      <!-- Syntax highlighting -->
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script>

      <!-- Renders LaTeX expression with KaTeX -->
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/contrib/auto-render.min.js"></script>

      <!-- CSS -->
<style>
body {
   font-family: "Helvetica Neue", 'Lato', Helvetica, sans-serif;
   max-width: 1000px;
   margin: 0 auto;
   position: relative;
   width: 95%;
   line-height: 1.5;
}

/* ---- Titles ---- */

h1 {
   padding-top: 2%;
   padding-bottom: 2%;
   color: #DE4834;
}

h2, h3, h4, h5, h6 {
   padding-top: 1%;
   padding-bottom: 1%;
   color: #DE4834;
}

/* ---- Link ---- */

a {
   text-decoration: none;
   color: #2E64FE;
}

/* ---- List (+ main menu list) ---- */

ul {
   padding-left: 30px;
}

#main_menu {
   list-style: none;
   margin: 0;
   padding: 0;
   text-align: center;
}
#main_menu li {
   display: inline;
   margin-right: 1px;
}
#main_menu li a {
   line-height: 1em;
   padding: 4px 20px;
   text-align: center;
}
#main_menu li a:hover, #main_menu li a:active {
   text-decoration: underline;
}

/* ---- Tables (same look as from github markdown layout) ---- */

table {
   display: block;
   width: 100%;
   overflow: auto;
   word-break: normal;
   word-break: keep-all;
   border-collapse: collapse;
   border-spacing: 0;
   margin-top: 0;
   margin-bottom: 16px;
}

table th {
   font-weight: bold;
}

table th,
table td {
   padding: 6px 13px;
   border: 1px solid #ddd;
}

table tr {
   background-color: #fff;
   border-top: 1px solid #ccc;
}

table tr:nth-child(2n) {
   background-color: #f8f8f8;
}

/* ---- Image and caption ---- */

.figure {
   text-align: center;
}

.caption {
   font-style: italic;
   text-align: center;
}

/* ---- Summary ---- */

#summary {
   width: 70%;
   text-align: justify;
   line-height: 1.6;
}

/* ---- Code ---- */
pre {
   width: 90%;
   white-space: pre-wrap;
   word-break: break-all;
   word-wrap: break-word;
}
</style>
      <!---- ---->

      <title>Algorithme de Bellman-Ford - napnac</title>
   </head>

   <body>

      <!-- Javascript -->
<script type="text/javascript">
function toggle_visibility(id) {
   var element = document.getElementById(id);
   if(element.style.display == 'block')
      element.style.display = 'none';
   else
      element.style.display = 'block';
}
</script>
      <!---- ---->

      <header>
         <a href="/">
            <img src="//static.napnac.ga/img/logo.png" alt="Logo du site" height="100" width="300">
         </a>

      </header>

      <nav>
         <ul id="main_menu">
            <li><a href="/">Accueil</a></li>
            <li><a href="/articles.html">Articles</a></li>
            <li><a href="/projets.html">Projets</a></li>
            <li><a href="/a_propos.html">A propos</a></li>
         </ul>
      </nav>

      <!-- Page/Article -->

<a href=""><h1 id="algorithme-de-bellman-ford">Algorithme de Bellman-Ford</h1></a>
<p>Publi&#233; le : 26/06/2016<br />
<em>Modifi&#233; le : 26/06/2016</em></p>
<ul id="summary">
<li><a href="#introduction">Introduction</a></li>
<li><a href="#principe">Principe</a></li>
<li><a href="#exemple">Exemple</a></li>
<li><a href="#pseudo-code">Pseudo-code</a></li>
<li><a href="#complexit&#233;">Complexit&#233;</a></li>
<li><a href="#impl&#233;mentation">Impl&#233;mentation</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>L'approche gloutonne de l'<a href="/algo/structure/graphe/plus_court_chemin/dijkstra.html">algorithme de Dijkstra</a> est excellente car elle permet d'aborder le probl&#232;me du plus court chemin de mani&#232;re intelligente, ce qui lui donne une complexit&#233; en temps int&#233;ressante, tout en &#233;tant optimale. Cependant, elle ne s'applique pas &#224; toutes les configurations de graphes (par exemple ceux avec des pond&#233;rations n&#233;gatives), et il nous faut donc un nouvel algorithme pour g&#233;rer ces cas.</p>
<h2 id="principe">Principe</h2>
<p>Reprenons depuis le d&#233;but. On a un graphe pond&#233;r&#233; (positivement ou n&#233;gativement), et on cherche le plus court chemin entre deux n&#339;uds distincts. Une approche <strong>na&#239;ve</strong> serait d'explorer toutes les combinaisons possibles de chemin et de choisir celle qui obtient une pond&#233;ration totale minimale. Le probl&#232;me ici est &#233;videmment la complexit&#233; en temps exponentielle. Dans ce genre de situation, il est fondamental de se poser cette question : qu'est-ce qui rend notre algorithme si lent ? Lorsqu'on explore toutes les possibilit&#233;s de chemins, on repasse tr&#232;s souvent sur d'anciens n&#339;uds et arcs, ce qui nous fait parcourir notre graphe plusieurs fois inutilement.</p>
<p>D&#233;sormais, on conna&#238;t la raison de la lenteur de notre pr&#233;c&#233;dent algorithme, et il faut alors chercher &#224; am&#233;liorer ce point, si possible, ou bien &#224; changer de concept. L'algorithme de Bellman-Ford va am&#233;liorer l'algorithme na&#239;f, en utilisant une approche diff&#233;rente du probl&#232;me : la <a href="/algo/general/approche/dynamique.html"><strong>programmation dynamique</strong></a>. L'id&#233;e est justement de ne pas repasser plusieurs fois sur des parties du graphe, mais plut&#244;t de garder les informations utiles en m&#233;moire &#224; l'aide d'un algorithme dynamique.</p>
<p><em>Il est int&#233;ressant de noter que <a href="https://en.wikipedia.org/wiki/Richard_E._Bellman">Richard Bellman</a>, l'un des inventeurs de cet algorithme, est le p&#232;re fondateur de la programmation dynamique.</em></p>
<h2 id="exemple">Exemple</h2>
<p>Un exemple de l'algorithme de Bellman-Ford serait assez peu int&#233;ressant car il n'adopte pas de strat&#233;gie particuli&#232;re au niveau du parcours du graphe (contrairement &#224; l'algorithme de Dijkstra). Il se contente uniquement de tester chaque possibilit&#233; de chemin avec une <strong>impl&#233;mentation dynamique</strong> le rendant plus rapide qu'une impl&#233;mentation na&#239;ve.</p>
<h2 id="pseudo-code">Pseudo-code</h2>
<p><em>Pour appr&#233;hender au mieux cette partie, il est n&#233;cessaire d'&#234;tre familier &#224; la programmation dynamique (ou au moins d'en conna&#238;tre la base). Si ce n'est pas le cas, je vous renvoie vers mon article sur le sujet dont le lien est situ&#233; au-dessus.</em></p>
<p>Pour mettre en place un algorithme dynamique correctement, il est essentiel de r&#233;diger la version r&#233;cursive d'abord afin d'&#233;tablir explicitement la r&#233;cursion pour bien comprendre ce que cherche &#224; r&#233;aliser l'algorithme. Nous allons donc proc&#233;der par &#233;tape pour ce pseudo-code, en commen&#231;ant par la version r&#233;cursive na&#239;ve, puis nous l'am&#233;liorerons petit &#224; petit gr&#226;ce &#224; un algorithme dynamique.</p>
<h3 id="cycle-am&#233;liorant">Cycle am&#233;liorant</h3>
<p>Avant de se plonger dans le pseudo-code, il faut noter que le probl&#232;me du plus court chemin sur un graphe pond&#233;r&#233; positivement et n&#233;gativement introduit un nouveau souci : les <strong>cycles am&#233;liorants</strong> (ou <em>negative cycle</em> en anglais). En effet, vu qu'une pond&#233;ration peut d&#233;sormais &#234;tre n&#233;gative, il est possible de tomber dans une boucle infinie (qu'on appelle plus pr&#233;cis&#233;ment un cycle am&#233;liorant) qui va sans cesse diminuer la distance parcourue. Ceci pose un r&#233;el probl&#232;me puisqu'on peut am&#233;liorer la distance &#224; chaque fois qu'on passe dans ce cycle, et il existera toujours un meilleur chemin &#224; emprunter. Lorsqu'un graphe contient ce genre de cycle, il n'y a pas de solution &#224; cause de cette boucle infinie, il faut donc pouvoir le d&#233;tecter.</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/structure/graphe/plus_court_chemin/bellman_ford/exemple_cycle_ameliorant.png" alt="Exemple de cycle am&#233;liorant" />
<p class="caption">Exemple de cycle am&#233;liorant</p>
</div>
<p>Sur cet exemple de graphe (avec le n&#339;ud de d&#233;part en bleu, et celui d'arriv&#233;e en vert), on remarque que le chemin surlign&#233; en rouge est un cycle am&#233;liorant. En effet, d&#232;s qu'on parcourt ce cycle, la distance parcourue en sortie sera toujours inf&#233;rieure &#224; celle en entr&#233;e, d'o&#249; l'int&#233;r&#234;t de le visiter &#224; nouveau afin de diminuer encore la distance, et ainsi de suite, ce qui entraine une boucle infinie. Il est impossible de trouver le plus court chemin entre le n&#339;ud 1 et 4 dans ce graphe, car on peut am&#233;liorer la distance parcourue &#224; l'infini sans jamais arriver au n&#339;ud en vert.</p>
<p>Pour contrer cela, on va imposer une limite de recherche &#224; notre r&#233;cursion qui ne pourra pas d&#233;passer l'exploration de <span class="math inline">\(K\)</span> n&#339;uds. Une limite de <span class="math inline">\(N\)</span> n&#339;uds maximum &#224; explorer permet &#224; notre algorithme de ne jamais tomber dans une boucle infinie (avec <span class="math inline">\(N\)</span> le nombre de n&#339;uds du graphe), puisqu'un plus court chemin, qui ne contient pas de cycle am&#233;liorant, ne passe jamais plus de deux fois par un m&#234;me n&#339;ud. On peut d&#233;sormais reformuler clairement notre probl&#232;me de plus court chemin entre un n&#339;ud A et B, en un probl&#232;me cherchant &#224; minimiser la distance entre A et B en r&#233;alisant <span class="math inline">\(K\)</span> &#233;tapes au maximum. La reformulation est importante puisqu'elle limite la recherche afin de ne pas tomber dans une boucle infinie.</p>
<h3 id="version-r&#233;cursive">Version r&#233;cursive</h3>
<p>Voici un premier pseudo-code simplifi&#233; de la r&#233;cursion (on suppose que le graphe en entr&#233;e est orient&#233; et ne poss&#232;de pas de cycles am&#233;liorantes pour &#233;tablir une premi&#232;re id&#233;e de l'algorithme g&#233;n&#233;ral).</p>
<pre class="nohighlight"><code>Bellman-Ford (nbEtape, n&#339;ud) :

   Si nbEtape = 0
      Si c&#39;est le n&#339;ud d&#39;arriv&#233;e
         Retourner 0
      Sinon
         Retourner INFINI car le chemin est invalide

   cheminMin = Bellman-Ford(nbEtape - 1, n&#339;ud)
   Pour chaque voisin du n&#339;ud
      cheminVoisin = pond&#233;rationArc + Bellman-Ford(nbEtape - 1, voisin)
      cheminMin = min(cheminMin, cheminVoisin)

   Retourner cheminMin</code></pre>
<p>Ce pseudo-code traduit une simple r&#233;cursion permettant d'explorer tous les chemins en moins de <code>nbEtape</code> jusqu'&#224; l'arriv&#233;e, tout en s&#233;lectionnant le plus court d'entre eux. Pour cela, l'algorithme utilise une simple boucle sur tous les voisins d'un n&#339;ud ainsi qu'une variable <code>cheminMin</code> qu'on actualise pour toujours avoir le chemin avec la pond&#233;ration minimale entre tous les choix possibles.</p>
<h3 id="version-dynamique-r&#233;cursive">Version dynamique r&#233;cursive</h3>
<p>Maintenant, on passe &#224; l'&#233;tape de dynamisation de cet algorithme puisque ce dernier est terriblement lent et poss&#232;de une complexit&#233; en temps exponentielle car il ne fait que r&#233;p&#233;ter des appels r&#233;cursifs inutilement. On va donc cr&#233;er un tableau 2D stockant le plus court chemin pour tous les param&#232;tres possibles de notre fonction, afin de ne jamais avoir &#224; recalculer le r&#233;sultat d'un m&#234;me appel.</p>
<pre class="nohighlight"><code>plusCourtChemin[NB_ETAPE_MAX][NB_NOEUD_MAX] (initialis&#233; &#224; -1)

Bellman-Ford (nbEtape, n&#339;ud) :

   Si nbEtape = 0
      Si c&#39;est le n&#339;ud d&#39;arriv&#233;e
         Retourner 0
      Sinon
         Retourner INFINI car le chemin est invalide
   Si plusCourtChemin[nbEtape][n&#339;ud] != -1
      Retourner plusCourtChemin[nbEtape][n&#339;ud]

   cheminMin = Bellman-Ford(nbEtape - 1, n&#339;ud)
   Pour chaque voisin du n&#339;ud
      cheminVoisin = pond&#233;rationArc + Bellman-Ford(nbEtape - 1, voisin)
      cheminMin = min(cheminMin, cheminVoisin)

   plusCourtChemin[nbEtape][n&#339;ud] = cheminMin
   Retourner cheminMin</code></pre>
<p>On a seulement ajout&#233; les trois points fondamentaux qu'on retrouve dans un processus de dynamisation d'un algorithme :</p>
<ul>
<li>L'<strong>initialisation</strong> du tableau <code>plusCourtChemin</code> &#224; -1 pour marquer toutes les valeurs comme non calcul&#233;es.</li>
<li>Une <strong>condition</strong> au d&#233;but de notre r&#233;cursion afin de v&#233;rifier si la valeur n'a pas d&#233;j&#224; &#233;t&#233; calcul&#233;e (et si c'est le cas, on la retourne directement).</li>
<li>Une <strong>mise &#224; jour</strong> du tableau apr&#232;s avoir trouv&#233; une nouvelle valeur.</li>
</ul>
<h3 id="version-dynamique-it&#233;rative">Version dynamique it&#233;rative</h3>
<p>Une fois qu'on a r&#233;ussi &#224; obtenir une complexit&#233; en temps non exponentielle (puisque d&#233;sormais on ne parcourt pas inutilement des parties du graphe), il est toujours int&#233;ressant de tenter de r&#233;duire notre complexit&#233; en m&#233;moire si possible. Actuellement, dans notre dernier pseudo-code, on a une complexit&#233; m&#233;moire de l'ordre de <span class="math inline">\(O(KN)\)</span>, ce qui est &#233;quivalent &#224; du <span class="math inline">\(O(N^2)\)</span>, car on choisit la limite <span class="math inline">\(K\)</span>, tel que <span class="math inline">\(K = N\)</span> pour &#233;viter les cycles am&#233;liorants. Cet ordre de grandeur est tout &#224; fait correct en termes d'espace m&#233;moire, surtout vu le gain de temps qu'on acquiert gr&#226;ce au tableau, mais il peut &#234;tre encore largement am&#233;lior&#233;.</p>
<p>Le passage &#224; la version it&#233;rative de l'algorithme dynamique est essentiel &#224; cette r&#233;duction de l'espace m&#233;moire utilis&#233;, et c'est ce qu'on va r&#233;aliser dans un premier temps :</p>
<pre class="nohighlight"><code>Bellman-Ford :

   plusCourtChemin[NB_ETAPE_MAX][NB_NOEUD_MAX] (initialis&#233; &#224; INFINI)
   plusCourtChemin[0][arriv&#233;e] = 0

   Pour chaque &#233;tape
      Pour chaque n&#339;ud
         cheminMin = plusCourtChemin[&#233;tape - 1][n&#339;ud]
         Pour chaque voisin du n&#339;ud
            cheminVoisin = pond&#233;rationArc + plusCourtChemin[&#233;tape - 1][voisin]
            cheminMin = min(cheminMin, cheminVoisin)
         plusCourtChemin[&#233;tape][n&#339;ud] = cheminMin

   Retourner plusCourtChemin[nbEtapeMax - 1][d&#233;part]</code></pre>
<p>Plusieurs points importants &#224; comprendre dans cette version it&#233;rative de l'algorithme :</p>
<ul>
<li>Le tableau <code>plusCourtChemin</code> est initialis&#233; &#224; <code>INFINI</code> car on n'a plus besoin de d&#233;tecter le cas o&#249; l'on retombe sur un appel de fonction d&#233;j&#224; rencontr&#233; auparavant, puisque d&#233;sormais on utilise des boucles (passage de la version r&#233;cursive &#224; it&#233;rative). On choisit donc la valeur <code>INFINI</code> pour noter qu'on ne conna&#238;t pas de plus court chemin pour un n&#339;ud donn&#233; &#224; une &#233;tape pr&#233;cise.</li>
<li>On a transform&#233; les appels r&#233;cursifs en deux boucles imbriqu&#233;es, une sur les &#233;tapes, et l'autre sur les n&#339;uds. En r&#233;alit&#233;, on parcourt simplement notre tableau <code>plusCourtChemin</code>, et c'est exactement ce que r&#233;alisait implicitement notre fonction r&#233;cursive puisqu'on retrouve la premi&#232;re boucle gr&#226;ce au param&#232;tre de la fonction <code>nbEtape</code> (que l'on diminuait &#224; chaque fois de 1, et qui nous permettait d'arr&#234;ter la r&#233;cursion lorsqu'elle atteignait 0), et la boucle sur les n&#339;uds lors des appels r&#233;cursifs sur les n&#339;uds voisins.</li>
<li>Notre structure au niveau de la boucle des voisins n'a pas chang&#233;, et on cherche toujours &#224; garder le minimum dans notre tableau <code>plusCourtChemin</code>.</li>
</ul>
<p>Avant de r&#233;aliser l'&#233;conomie de m&#233;moire, attardons-nous l&#233;g&#232;rement sur ce dernier pseudo-code afin de bien comprendre comment effectuer cette am&#233;lioration. Prenons l'exemple de ce graphe (ne contenant pas de cycle am&#233;liorant pour simplifier la chose), et appliquons notre nouveau pseudo-code it&#233;ratif dessus pour bien l'appr&#233;hender :</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/structure/graphe/plus_court_chemin/bellman_ford/exemple_graphe_pseudo_code_iteratif.png" alt="Exemple de graphe orient&#233; et pond&#233;r&#233;" />
<p class="caption">Exemple de graphe orient&#233; et pond&#233;r&#233;</p>
</div>
<p>On cherche le plus court chemin entre le n&#339;ud 1 (en bleu) et le n&#339;ud 5 (en vert), et notre tableau <code>plusCourtChemin</code> initial ressemble donc &#224; cela :</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/structure/graphe/plus_court_chemin/bellman_ford/etat_init_pseudo_code_iteratif.png" alt="Etat initial du tableau plusCourtChemin" />
<p class="caption">Etat initial du tableau <code>plusCourtChemin</code></p>
</div>
<p>Maintenant qu'on a initialis&#233; notre tableau, on peut commencer &#224; le remplir. Pour rappel, chaque case de ce tableau repr&#233;sente la longueur du plus court chemin reliant un n&#339;ud au n&#339;ud d'arriv&#233;e :</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/structure/graphe/plus_court_chemin/bellman_ford/pseudo_code_iteratif_etape_0.png" alt="Etape 0" />
<p class="caption">Etape 0</p>
</div>
<p>La partie du pseudo-code nous concernant ici est la suivante :</p>
<pre class="nohighlight"><code>Pour chaque &#233;tape
   Pour chaque n&#339;ud
      cheminMin = plusCourtChemin[&#233;tape - 1][n&#339;ud]
      Pour chaque voisin du n&#339;ud
         cheminVoisin = pond&#233;rationArc + plusCourtChemin[&#233;tape - 1][voisin]
         cheminMin = min(cheminMin, cheminVoisin)
      plusCourtChemin[&#233;tape][n&#339;ud] = cheminMin</code></pre>
<p>On va donc d&#233;composer l'explication de l'&#233;tape 0, afin de traiter s&#233;par&#233;ment le cas de chaque n&#339;ud.</p>
<p>Pour le n&#339;ud 1, dans notre pseudo-code la ligne <code>cheminMin = plusCourtChemin[&#233;tape - 1][n&#339;ud]</code> permet de prendre en compte le dernier chemin trouv&#233; pour un n&#339;ud, or ici c'est le premier tour donc on n'a aucunes informations qu'on peut r&#233;utiliser. On parcourt les voisins du n&#339;ud 1, soit les n&#339;uds 2 et 3, et on calcule la pond&#233;ration du chemin reliant 1 au meilleur chemin qu'on a trouv&#233; avec ses voisins (cela correspond &#224; la ligne <code>cheminVoisin = pond&#233;rationArc + plusCourtChemin[&#233;tape - 1][voisin]</code>). Encore une fois, on a aucunes informations sur des chemins pour aucun de ses voisins, donc la case du n&#339;ud 1 reste inchang&#233;e dans notre tableau.</p>
<p>De m&#234;me, le n&#339;ud 2 se retrouve dans cette situation. En effet, on ne poss&#232;de aucunes informations ant&#233;rieures (puisque c'est l'&#233;tape 0), et aucun de ses voisins (n&#339;uds 3 et 4) n'en poss&#232;dent non plus.</p>
<p>Le n&#339;ud 3 n'a aucunes pr&#233;c&#233;dentes informations, mais poss&#232;de cependant comme voisin le n&#339;ud 5 (notre n&#339;ud d'arriv&#233;e). On peut donc trouver un chemin simple et direct entre le n&#339;ud 3 et 5, de pond&#233;ration 2. Le n&#339;ud 4 est aussi voisin du n&#339;ud 3 mais ne poss&#232;de encore aucunes donn&#233;es sur un &#233;ventuel chemin avec le n&#339;ud 5.</p>
<p>On arrive enfin au n&#339;ud 4 et lui aussi est reli&#233; directement &#224; notre n&#339;ud d'arriv&#233;e, on peut donc mettre &#224; jour sa case dans le tableau.</p>
<p>Au final, le premier tour de boucle ne va uniquement calculer des chemins (on n'est pas encore s&#251;r qu'ils sont les plus courts) des voisins directs du n&#339;ud d'arriv&#233;e, puisque les autres n&#339;uds n'ont aucunes informations &#224; ce sujet.</p>
<p>On recommence notre proc&#233;d&#233; sur les diff&#233;rents n&#339;uds, mais cette fois on peut r&#233;utiliser les anciennes valeurs :</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/structure/graphe/plus_court_chemin/bellman_ford/pseudo_code_iteratif_etape_1.png" alt="Etape 1" />
<p class="caption">Etape 1</p>
</div>
<p>Pour le n&#339;ud 1, le seul de ses deux voisins &#224; poss&#233;der des informations est le n&#339;ud 3. On a donc pas d'autres choix de chemin reliant le n&#339;ud 1 et 5 que celui-ci pour le moment.</p>
<p>Le n&#339;ud 2 en revanche peut utiliser les informations de ses deux voisins. On calcule donc le chemin qui minimise la pond&#233;ration en choisissant le meilleur (ici, le chemin reliant 2, 3 et 5 a un co&#251;t total de 5 unit&#233;s, et le chemin reliant 2, 4 et 5 a un co&#251;t de -6 unit&#233;s, c'est donc ce dernier qu'on choisit).</p>
<p>Pour le n&#339;ud 3, on conna&#238;t maintenant des informations au sujet du n&#339;ud 4 et on peut alors les exploiter &#224; notre avantage. En effet, emprunter le chemin reliant le n&#339;ud 4 et 5 nous avantage par rapport &#224; un chemin direct entre 3 et 5.</p>
<p>Enfin le n&#339;ud 4 n'a pas d'autres voisins que le n&#339;ud 5 donc aucuns autres choix de chemin.</p>
<p>On continue comme ceci jusqu'&#224; avoir rempli tout notre tableau :</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/structure/graphe/plus_court_chemin/bellman_ford/etat_final_pseudo_code_iteratif.png" alt="Etat final du tableau" />
<p class="caption">Etat final du tableau</p>
</div>
<p>D&#233;sormais on connait le plus court chemin du graphe reliant le n&#339;ud 1 &#224; 5, soit -4, et au passage on a aussi gr&#226;ce &#224; ce tableau les plus court chemins de tous les n&#339;uds allant &#224; 5.</p>
<p><em>On remarque qu'&#224; partir de l'&#233;tape 2 on n'effectue plus aucun changement sur le tableau, cela nous montre alors qu'on a trouv&#233; notre solution d&#232;s l'&#233;tape 2 et il est tout &#224; fait possible d'arr&#234;ter l'algorithme ici. Cependant, vu que la complexit&#233; en temps reste inchang&#233; (dans le cas o&#249; le tableau est mis &#224; jour &#224; chaque &#233;tape), on n'impl&#233;mentera pas cette am&#233;lioration afin de garder un code simple et concis.</em></p>
<p>Cette explication du pseudo-code nous permet d'introduire notre &#233;conomie de m&#233;moire qu'on cherchait &#224; r&#233;aliser. En effet, dans ce tableau chaque ligne d&#233;pend de la pr&#233;c&#233;dente pour &#234;tre calcul&#233;e. Cela signifie que pour trouver la ligne 3, on a uniquement besoin de l'&#233;tape 2, et on peut donc se d&#233;barrasser de l'&#233;tape 0 et 1. Au final, on se rend compte qu'on peut garder une ligne unique que l'on va mettre &#224; jour &#224; chaque &#233;tape puisqu'on a pas besoin de conserver plus que cela dans notre tableau. On a alors r&#233;ussi &#224; supprimer une dimension enti&#232;re, et cela nous donne une complexit&#233; en m&#233;moire de <span class="math inline">\(O(N)\)</span>. Cette am&#233;lioration n&#233;cessite quelques modifications dans notre pseudo-code, mais on va en profiter pour simplifier ce dernier :</p>
<pre class="nohighlight"><code>Bellman-Ford :

   plusCourtChemin[NB_NOEUD_MAX] (initialis&#233; &#224; -1)
   plusCourtChemin[arriv&#233;e] = 0

   Pour chaque &#233;tape
      Pour chaque arc
         cheminVoisin = pond&#233;rationArc + plusCourtChemin[n&#339;ud2arc]
         plusCourtChemin[n&#339;ud1arc] = min(plusCourtChemin[n&#339;ud1arc], cheminVoisin)

   Retourner plusCourtChemin[d&#233;part]</code></pre>
<p>En plus de r&#233;aliser une optimisation de l'espace m&#233;moire, on facilite la lecture du pseudo-code en utilisant plus que deux boucles imbriqu&#233;es &#224; la place de trois. En effet, au lieu de parcourir les n&#339;uds puis leurs voisins respectifs dans deux boucles imbriqu&#233;es, on peut se contenter de visiter les arcs du graphe pour effectuer la m&#234;me op&#233;ration. Il ne faut pas oublier de lire le graphe en entr&#233;e comme une <a href="/algo/structure/graphe.html#liste-darcs">liste d'arcs</a> pour permettre de parcourir tous les arcs en une seule boucle.</p>
<h3 id="d&#233;tection-de-cycles-am&#233;liorants">D&#233;tection de cycles am&#233;liorants</h3>
<p>Notre pseudo-code n'est pas termin&#233;, il nous reste encore la d&#233;tection de cycles am&#233;liorants dans notre graphe, mais vu qu'on a simplifi&#233; et am&#233;lior&#233; grandement notre pseudo-code, ce probl&#232;me de cycles va &#234;tre simple &#224; g&#233;rer.</p>
<p>Pour d&#233;tecter un cycle am&#233;liorant, il suffit de d&#233;tecter si un chemin emprunte plus de <span class="math inline">\(N\)</span> n&#339;uds, et on peut tr&#232;s facilement r&#233;aliser ce test en regardant si le tableau <code>plusCourtChemin</code> a &#233;t&#233; modifi&#233; une fois la limite atteinte (on va donc r&#233;aliser un tour de boucle en plus). Si c'est le cas, on sait que le graphe contient un cycle am&#233;liorant :</p>
<pre class="nohighlight"><code>Bellman-Ford :

   plusCourtChemin[NB_NOEUD_MAX] (initialis&#233; &#224; -1)
   plusCourtChemin[arriv&#233;e] = 0

   modification = faux
   Pour chaque &#233;tape (avec un dernier tour de boucle en plus)
      modification = faux
      Pour chaque arc
         cheminVoisin = pond&#233;rationArc + plusCourtChemin[n&#339;ud2arc]
         Si cheminVoisin &lt; plusCourtChemin[n&#339;ud1arc]
            plusCourtChemin[n&#339;ud1arc] = cheminVoisin
            modification = vrai

   Si modification
      Le graphe contient un cycle am&#233;liorant
   Sinon
      Retourner plusCourtChemin[d&#233;part]</code></pre>
<p>On a d&#233;sormais le pseudo-code d&#233;finitif de l'algorithme de Bellman-Ford.</p>
<h2 id="complexit&#233;">Complexit&#233;</h2>
<p>L'avantage de passer de l'approche r&#233;cursive &#224; l'approche it&#233;rative dans un algorithme dynamique, est qu'on peut simplement trouver la complexit&#233; en temps de ce dernier. En effet, les deux boucles imbriqu&#233;es nous permettent de calculer une complexit&#233; en temps de <span class="math inline">\(O(N * M)\)</span> avec <span class="math inline">\(N\)</span> le nombre de n&#339;uds du graphe, et <span class="math inline">\(M\)</span> le nombre d'arcs (puisqu'on sait que pour &#233;viter un cycle am&#233;liorant il suffit que <span class="math inline">\(K = N\)</span>).</p>
<p>Cette complexit&#233; en temps est l&#233;g&#232;rement moins efficace que celle de l'algorithme de Dijkstra, mais reste tr&#232;s raisonnable vu la complexit&#233; exponentielle de l'algorithme na&#239;f. Surtout que l'algorithme de Dijkstra ne permet pas de r&#233;aliser le calcul du plus court chemin sur des graphes pond&#233;r&#233;s n&#233;gativement, et que l'algorithme de Bellman-Ford g&#232;re le cas des cycles am&#233;liorants de mani&#232;re tr&#232;s simple et &#233;l&#233;gante.</p>
<h2 id="impl&#233;mentation">Impl&#233;mentation</h2>
<p>L'impl&#233;mentation en C++ de l'algorithme de Bellman-Ford :</p>
<a href="javascript:toggle_visibility('bellman_ford.cpp');">bellman_ford.cpp</a>
<div id="bellman_ford.cpp" style="display: none;">
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">struct</span> Arc
{
   <span class="dt">int</span> noeud1;
   <span class="dt">int</span> noeud2;
   <span class="dt">int</span> poids;
};

<span class="dt">const</span> <span class="dt">int</span> NB_NOEUD_MAX = <span class="dv">1000</span>;
<span class="dt">const</span> <span class="dt">int</span> INFINI       = <span class="dv">1000000000</span>;

vector &lt;Arc&gt; arcs;
<span class="dt">int</span> nbNoeud, nbArc;

<span class="dt">void</span> bellmanFord(<span class="dt">int</span> depart, <span class="dt">int</span> arrivee)
{
   <span class="dt">int</span> plusCourtChemin[NB_NOEUD_MAX];
   <span class="dt">int</span> iEtape, iArc;
   <span class="dt">int</span> iNoeud;
   <span class="dt">bool</span> modification;

   <span class="kw">for</span>(iNoeud = <span class="dv">0</span>; iNoeud &lt; NB_NOEUD_MAX; ++iNoeud)
      plusCourtChemin[iNoeud] = INFINI;
   plusCourtChemin[arrivee] = <span class="dv">0</span>;

   modification = <span class="kw">false</span>;
   <span class="kw">for</span>(iEtape = <span class="dv">0</span>; iEtape &lt;= nbNoeud; ++iEtape) {
      modification = <span class="kw">false</span>;
      <span class="kw">for</span>(iArc = <span class="dv">0</span>; iArc &lt; arcs.size(); ++iArc) {
         <span class="dt">int</span> noeud1, noeud2;
         <span class="dt">int</span> cheminVoisin;
         noeud1 = arcs[iArc].noeud1;
         noeud2 = arcs[iArc].noeud2;
         cheminVoisin = arcs[iArc].poids + plusCourtChemin[noeud2];
         <span class="kw">if</span>(cheminVoisin &lt; plusCourtChemin[noeud1]) {
            plusCourtChemin[noeud1] = cheminVoisin;
            modification = <span class="kw">true</span>;
         }
      }
   }

   <span class="kw">if</span>(modification)
      printf(<span class="st">&quot;Cycle ameliorant !</span><span class="ch">\n</span><span class="st">&quot;</span>);
   <span class="kw">else</span>
      printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, plusCourtChemin[depart]);
}

<span class="dt">int</span> main(<span class="dt">void</span>)
{
   <span class="dt">int</span> depart, arrivee;
   <span class="dt">int</span> iArc;

   scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d\n</span><span class="st">&quot;</span>, &amp;depart, &amp;arrivee);
   scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d\n</span><span class="st">&quot;</span>, &amp;nbNoeud, &amp;nbArc);

   <span class="kw">for</span>(iArc = <span class="dv">0</span>; iArc &lt; nbArc; ++iArc) {
      Arc nouveau;
      scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d\n</span><span class="st">&quot;</span>, &amp;nouveau.noeud1, &amp;nouveau.noeud2, &amp;nouveau.poids);
      arcs.push_back(nouveau);
   }

   bellmanFord(depart, arrivee);
   <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</div>
<p>En entr&#233;e, on donne sur la premi&#232;re ligne le n&#339;ud de d&#233;part et d'arriv&#233;e pour le plus court chemin, puis sur la seconde ligne le nombre de n&#339;uds et d'arcs du graphe, avant de terminer sur la liste d'arcs :</p>
<pre class="nohighlight"><code>1 5
5 7
1 2 2
1 3 -1
2 3 3
2 4 -2
3 4 2
3 5 2
4 5 -4</code></pre>
<p>La sortie attendue sur le graphe pr&#233;c&#233;demment &#233;tudi&#233; :</p>
<pre class="nohighlight"><code>-4</code></pre>
<p>On teste avec notre exemple de graphe contenant un cycle am&#233;liorant :</p>
<pre class="nohighlight"><code>1 4
4 5
1 2 -2
2 3 1
2 4 3
3 1 -2
3 4 -4</code></pre>
<p>Le cycle est bien d&#233;tect&#233; par l'algorithme :</p>
<pre class="nohighlight"><code>Cycle ameliorant !</code></pre>
<h2 id="conclusion">Conclusion</h2>
 
      <!-- ------------ -->

      <footer>
         <br>
         <hr>
         <p>Une question ? Une suggestion ? N'h&#233;sitez pas &#224; me <a href="/a_propos.html">contacter</a> pour me communiquer vos remarques.
         <br>
      </footer>

      <!-- Automatically render all of the math inside the page with KaTeX -->
      <script>
         renderMathInElement(
            document.body,
            {
               delimiters: [
                  {left: "$$", right: "$$", display: true},
                  {left: "$", right: "$", display: false},
               ]
            }
         );
      </script>

   </body>
</html>
