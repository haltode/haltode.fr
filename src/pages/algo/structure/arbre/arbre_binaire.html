<!DOCTYPE html>
<html>
   <head>
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato&#38;subset=latin,latin-ext" type="text/css" />
      <link rel="icon" type="image/x-icon" href="//static.napnac.ga/img/favicon.ico">
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/github-gist.min.css">

      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script>

      <!-- CSS -->
<style>
body {
   font-family: "Helvetica Neue", 'Lato', Helvetica, sans-serif;
   max-width: 1000px;
   margin: 0 auto;
   position: relative;
   width: 95%;
   line-height: 1.5;
}

/* ---- Titles ---- */

h1 {
   padding-top: 2%;
   padding-bottom: 2%;
   color: #DE4834;
}

h2, h3, h4, h5, h6 {
   padding-top: 1%;
   padding-bottom: 1%;
   color: #DE4834;
}

/* ---- Link ---- */

a {
   text-decoration: none;
   color: #2E64FE;
}

/* ---- List (+ main menu list) ---- */

ul {
   padding-left: 30px;
}

#main_menu {
   list-style: none;
   margin: 0;
   padding: 0;
   text-align: center;
}
#main_menu li {
   display: inline;
   margin-right: 1px;
}
#main_menu li a {
   line-height: 1em;
   padding: 4px 20px;
   text-align: center;
}
#main_menu li a:hover, #main_menu li a:active {
   text-decoration: underline;
}

/* ---- Tables (same look as from github markdown layout) ---- */

table {
   display: block;
   width: 100%;
   overflow: auto;
   word-break: normal;
   word-break: keep-all;
   border-collapse: collapse;
   border-spacing: 0;
   margin-top: 0;
   margin-bottom: 16px;
}

table th {
   font-weight: bold;
}

table th,
table td {
   padding: 6px 13px;
   border: 1px solid #ddd;
}

table tr {
   background-color: #fff;
   border-top: 1px solid #ccc;
}

table tr:nth-child(2n) {
   background-color: #f8f8f8;
}

/* ---- Image and caption ---- */

.figure {
   text-align: center;
}

.caption {
   font-style: italic;
   text-align: center;
}

/* ---- Summary ---- */

#summary {
   width: 70%;
   text-align: justify;
   line-height: 1.6;
}

/* ---- Code ---- */
pre {
   width: 90%;
   white-space: pre-wrap;
   word-break: break-all;
   word-wrap: break-word;
}

/* ---- Articles ---- */

.non_publie {
   font-style: italic;
   display: inline;
}

/* ---- Temporary css ---- */

.pret {
   background-color: #00CC00;
   display: inline;
}

.relire {
   background-color: #FF9900;
   display: inline;
}

.faire {
   background-color: #FF0000;
   display: inline;
}
</style>
      <!---- ---->

      <title>Arbre binaire - NapNac</title>
   </head>

   <body>

      <!-- Javascript -->
<script type="text/javascript">
function toggle_visibility(id) {
   var element = document.getElementById(id);
   if(element.style.display == 'block')
      element.style.display = 'none';
   else
      element.style.display = 'block';
}
</script>
      <!---- ---->

      <header>
         <a href="/">
            <img src="//static.napnac.ga/img/logo.png" alt="Logo du site" height="100" width="300">
         </a>

      </header>

      <nav>
         <ul id="main_menu">
            <li><a href="/">Accueil</a></li>
            <li><a href="/articles.html">Articles</a></li>
            <li><a href="/projets.html">Projets</a></li>
            <li><a href="/a_propos.html">A propos</a></li>
         </ul>
      </nav>

      <!-- Page/Article -->

<a href=""><h1 id="arbre-binaire">Arbre binaire</h1></a>
<p>Publi&#233; le : 27/12/2015<br />
<em>Modifi&#233; le : 29/12/2015</em></p>
<ul id="summary">
<li><a href="#introduction">Introduction</a></li>
<li><a href="#d&#233;finition">D&#233;finition</a></li>
<li><a href="#impl&#233;mentation">Impl&#233;mentation</a></li>
<li><a href="#application">Application</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>Je vous donne un tableau contenant des nombres entiers, et je vous pose une simple question : Quelle est la valeur maximale de ce tableau ? Naturellement, on peut parcourir notre tableau et comparer chaque &#233;l&#233;ment afin de trouver le maximum, cet algorithme a une complexit&#233; lin&#233;aire en <em>O(N)</em> avec <em>N</em> la taille du tableau. Mais maintenant, je d&#233;cide de changer quelques valeurs dans le tableau et je vous repose la question. On peut &#224; nouveau parcourir tout le tableau, et comparer nos <em>N</em> &#233;l&#233;ments pour chercher le maximum, mais peut-on faire mieux ? Comment trouver rapidement le maximum d'un tableau dynamique ?</p>
<p>Une id&#233;e serait de diviser notre gros probl&#232;me en plus petits sous probl&#232;mes. Au lieu de se demander quel est le maximum de tout le tableau, on peut commencer par se demander quel est le maximum entre les deux premiers &#233;l&#233;ments du tableau, puis entre les deux suivants, etc. Une fois qu'on a tous ces maximum, on a divis&#233; le nombre d'&#233;l&#233;ments &#224; visiter par deux pour r&#233;pondre &#224; notre probl&#232;me initial puisque d&#233;sormais on peut simplement parcourir les maximums locaux pour trouver le maximum du tableau. Mais on peut continuer de diviser notre probl&#232;me, en trouvant les maximums des maximums, etc. jusqu'&#224; arriver &#224; la valeur maximale contenue dans le tableau.</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/structure/arbre/arbre_binaire/representation_probleme_intro.png" alt="Repr&#233;sentation des sous probl&#232;mes" />
<p class="caption">Repr&#233;sentation des sous probl&#232;mes</p>
</div>
<p>Les &#233;l&#233;ments en bleus repr&#233;sentent notre tableau initial, et l'&#233;l&#233;ment en vert est le maximum du tableau trouv&#233; gr&#226;ce &#224; notre m&#233;thode. On commence en bas avec notre tableau, et on monte progressivement en prenant &#224; chaque fois les maximums deux &#224; deux. Cette structure s'apparente &#224; un <a href="/algo/structure/arbre.html">arbre</a>, mais a la particularit&#233; de ne pas poss&#233;der plus de deux fils par n&#339;ud (car on compare les &#233;l&#233;ments deux &#224; deux &#224; chaque fois). Cette propri&#233;t&#233; nous permet de d&#233;montrer qu'il suffit dans le pire des cas <em>log N</em> changements pour modifier le maximum du tableau (et donc la racine de l'arbre). C'est-&#224;-dire que lorsqu'on modifie des valeurs, il suffit uniquement de modifier les p&#232;res des n&#339;uds affect&#233;s, et de simplement remonter petit &#224; petit &#224; la racine en recalculant uniquement les maximums locaux n&#233;cessaires. Or, la hauteur de cet arbre est dans le pire des cas de <em>log N</em>, notre algorithme a donc une complexit&#233; en <em>O(log N)</em> pour trouver le maximum d'un tableau dynamique.</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/structure/arbre/arbre_binaire/changement_valeur_intro.png" alt="Changement d&#39;une valeur dans notre tableau" />
<p class="caption">Changement d'une valeur dans notre tableau</p>
</div>
<p>Pour changer une valeur dans notre tableau (ici le 1 devient un 11), on change aussi les n&#339;uds de l'arbre en remontant tant que le maximum local a chang&#233;.</p>
<p>Cette structure de donn&#233;es porte un nom : un arbre binaire (et plus particuli&#232;rement un arbre binaire maximal dans notre cas), et elle est tr&#232;s utile dans le domaine de la recherche, mais nous verrons que son utilisation ne se limite pas &#224; cette cat&#233;gorie d'algorithme et qu'elle est pr&#233;sente dans de nombreux autres structures de donn&#233;es plus complexes.</p>
<h2 id="d&#233;finition">D&#233;finition</h2>
<p>Un arbre binaire (ou <em>binary tree</em> en anglais) est un type d'<a href="/algo/structure/arbre.html">arbre</a> sp&#233;cifique avec comme contrainte de ne pas avoir plus de deux fils par n&#339;uds. On appelle alors les deux fils d'un n&#339;ud le <em>fils gauche</em> et le <em>fils droit</em>.</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/structure/arbre/arbre_binaire/exemple_arbre_binaire.png" alt="Exemple d&#39;arbre binaire" />
<p class="caption">Exemple d'arbre binaire</p>
</div>
<p>Notre arbre binaire ici n'a aucune propri&#233;t&#233; sp&#233;cifique, mais sachez qu'il peut &#234;tre <strong>maximal</strong> (comme dans l'exemple de l'introduction), ou bien <strong>minimal</strong>.</p>
<h2 id="impl&#233;mentation">Impl&#233;mentation</h2>
<p>Un arbre binaire reste un arbre, on peut donc l'impl&#233;menter de la m&#234;me fa&#231;on que ce dernier, mais vu les propri&#233;t&#233;s de cette structure de donn&#233;es, il est possible de l'impl&#233;menter de diff&#233;rentes fa&#231;ons.</p>
<h3 id="recoder-&#224;-la-main">Recoder &#224; la main</h3>
<p>Les possibilit&#233;s d'impl&#233;mentation d'un arbre ne s'applique pas forc&#233;ment bien pour un arbre binaire, en effet, on sait qu'il n'aura qu'au maximum deux fils, on peut donc simplement utiliser une structure auto r&#233;f&#233;rentielle :</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="kw">struct</span> Noeud Noeud;
<span class="kw">struct</span> Noeud 
{
   Noeud *gauche;
   Noeud *droit;
   <span class="dt">int</span> donnee;
};

<span class="kw">typedef</span> Noeud *ArbreBinaire;</code></pre></div>
<p>Chaque &#233;l&#233;ment pointe alors vers ses deux fils, reliant ainsi les n&#339;uds entre eux pour former notre arbre binaire. Cette solution permet un stockage optimal en m&#233;moire, n'occupant rien de plus que n&#233;cessaire, mais peut &#234;tre un inconv&#233;nient lorsqu'on a besoin d'acc&#233;der rapidement &#224; des &#233;l&#233;ments (en effet, il faut parcourir l'arbre jusqu'&#224; un &#233;l&#233;ment particulier pour r&#233;cup&#233;rer ses donn&#233;es).</p>
<h3 id="tableau">Tableau</h3>
<p>Une autre impl&#233;mentation consiste &#224; utiliser un simple tableau, permettant un acc&#232;s rapide (en <em>O(1)</em>) &#224; n'importe quel &#233;l&#233;ment, mais pouvant parfois &#234;tre une perte de m&#233;moire.</p>
<p>Pour stocker notre arbre binaire, on va prendre chaque &#233;l&#233;ment de l'arbre profondeur par profondeur (de gauche &#224; droite), et les placer dans le tableau dans cet ordre.</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/structure/arbre/arbre_binaire/exemple_imple_tableau.png" alt="Exemple de repr&#233;sentation d&#39;un arbre binaire dans un tableau" />
<p class="caption">Exemple de repr&#233;sentation d'un arbre binaire dans un tableau</p>
</div>
<p>Ce tableau permet notamment un acc&#232;s rapide, et un parcours facile gr&#226;ce &#224; sa mani&#232;re de stocker les n&#339;uds qui nous renseigne sur qui est le p&#232;re/fils gauche/fils droit d'un n&#339;ud :</p>
<ul>
<li>La racine sera l'&#233;l&#233;ment 1 du tableau.</li>
<li>Chaque n&#339;ud d'indice <em>N</em> a son fils gauche stock&#233; en indice <em>2 * N</em>, et son fils droit en indice <em>2 * N + 1</em>.</li>
<li>Chaque n&#339;ud d'indice <em>N</em> (except&#233; pour la racine de l'arbre) a son p&#232;re dans le tableau en indice <em>N / 2</em> (on gardera juste la partie enti&#232;re du r&#233;sultat).</li>
</ul>
<p>Ce tableau suffit donc &#224; stocker un arbre binaire :</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> arbreBinaire[NB_NOEUD_ARBRE + <span class="dv">1</span>];</code></pre></div>
<p>On n'oublie pas d'allouer une case de plus dans notre tableau car la racine doit obligatoirement &#234;tre l'&#233;l&#233;ment d'indice 1 du tableau pour satisfaire les propri&#233;t&#233;s de placement des n&#339;uds.</p>
<h2 id="application">Application</h2>
<p>Cela peut paraitre &#233;trange de penser qu'un simple arbre avec une contrainte sur le nombre de n&#339;uds de ses fils peut &#234;tre extr&#234;mement utile. Et pourtant, les arbres binaires sont pr&#233;sents dans &#233;norm&#233;ment d'algorithmes et de structures de donn&#233;es, et en voici une courte liste :</p>
<ul>
<li><p><strong>Recherche</strong> :</p>
<ul>
<li>Comme vu dans l'introduction, un arbre binaire peut &#234;tre maximal ou minimal, facilitant la recherche du maximum/minimum dans un tableau dynamique.</li>
<li>Certains <a href="/algo/structure/arbre/arbre_recherche.html">arbres de recherche</a> sont des arbres binaires, comme l'arbre rouge et noir ou encore l'arbre binaire de recherche.</li>
</ul></li>
<li><p><strong>Structure de donn&#233;es</strong> :</p>
<ul>
<li>Le <a href="/algo/structure/arbre/tas.html">tas</a> est sans doute la structure de donn&#233;es bas&#233;e sur un arbre binaire la plus utilis&#233;e. Le tas est tr&#232;s efficace pour chercher mais aussi trier des &#233;l&#233;ments, et cette structure a, comme l'arbre binaire, un champ d'application tr&#232;s large.</li>
<li>Le <a href="https://en.wikipedia.org/wiki/T-tree">T-tree</a> est un arbre binaire modifi&#233; permettant de grandes optimisations de m&#233;moire.</li>
</ul></li>
<li><p><strong>Tri</strong> :</p>
<ul>
<li>Le <a href="/algo/tri/tri_tas.html">tri par tas</a> bas&#233; donc sur un tas, est un algorithme de tri rapide avec une complexit&#233; en temps de <em>O(N * log N)</em>. De plus, son am&#233;lioration le smoothsort fond&#233;e elle aussi sur des arbres binaires, permet dans le meilleur des cas une complexit&#233; en temps lin&#233;aire.</li>
</ul></li>
<li><p><strong>Compression</strong> :</p>
<ul>
<li>Le <a href="https://en.wikipedia.org/wiki/Huffman_coding">codage de Huffman</a> est un c&#233;l&#232;bre algorithme de compression des donn&#233;es sans perte, utilisant en partie des arbres binaires pour fonctionner.</li>
</ul></li>
<li><p><strong>Syntaxe</strong> :</p>
<ul>
<li>Les <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">arbres syntaxiques</a> sont eux aussi cr&#233;&#233;s &#224; partir d'arbre binaire, et sont le c&#339;ur du fonctionnement d'un compilateur ou tout autre parseur d'expression.</li>
</ul></li>
<li><p><strong>G&#233;om&#233;trie/Graphique</strong> :</p>
<ul>
<li>La plupart des jeux 3D utilisent des <a href="https://en.wikipedia.org/wiki/Binary_space_partitioning">arbres binaires sp&#233;cifiques</a> afin de savoir quel objet a besoin d'&#234;tre affich&#233; ou non &#224; l'&#233;cran.</li>
</ul></li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>La liste des applications d'un arbre binaire peut continuer longtemps, car cette structure de donn&#233;es est fondamentale en algorithmique. Son principe est simple, et son impl&#233;mentation aussi, mais ses applications peuvent &#234;tre tr&#232;s complexes.</p>
 
      <!-- ------------ -->

      <footer>
         <br>
      </footer>

   </body>
</html>
