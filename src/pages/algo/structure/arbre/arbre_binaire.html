<!DOCTYPE html>
<html>
   <head>
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato&#38;subset=latin,latin-ext" type="text/css" />
      <link rel="icon" type="image/x-icon" href="//static.napnac.ga/img/favicon.ico">
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/github-gist.min.css">

      <!-- Syntax highlighting -->
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script>

      <!-- Renders LaTeX expression -->
      <script type="text/x-mathjax-config">
         MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
      </script>
      <script type="text/javascript" async
         src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">
      </script>

      <!-- CSS -->
<style>
body {
   font-family: "Helvetica Neue", 'Lato', Helvetica, sans-serif;
   max-width: 1000px;
   margin: 0 auto;
   position: relative;
   width: 95%;
   line-height: 1.5;
}

/* ---- Titles ---- */

h1 {
   padding-top: 2%;
   padding-bottom: 2%;
   color: #DE4834;
}

h2, h3, h4, h5, h6 {
   padding-top: 1%;
   padding-bottom: 1%;
   color: #DE4834;
}

/* ---- Link ---- */

a {
   text-decoration: none;
   color: #2E64FE;
}

/* ---- List (+ main menu list) ---- */

ul {
   padding-left: 30px;
}

#main_menu {
   list-style: none;
   margin: 0;
   padding: 0;
   text-align: center;
}
#main_menu li {
   display: inline;
   margin-right: 1px;
}
#main_menu li a {
   line-height: 1em;
   padding: 4px 20px;
   text-align: center;
}
#main_menu li a:hover, #main_menu li a:active {
   text-decoration: underline;
}

/* ---- Tables (same look as from github markdown layout) ---- */

table {
   display: block;
   width: 100%;
   overflow: auto;
   word-break: normal;
   word-break: keep-all;
   border-collapse: collapse;
   border-spacing: 0;
   margin-top: 0;
   margin-bottom: 16px;
}

table th {
   font-weight: bold;
}

table th,
table td {
   padding: 6px 13px;
   border: 1px solid #ddd;
}

table tr {
   background-color: #fff;
   border-top: 1px solid #ccc;
}

table tr:nth-child(2n) {
   background-color: #f8f8f8;
}

/* ---- Image and caption ---- */

.figure {
   text-align: center;
}

.caption {
   font-style: italic;
   text-align: center;
}

/* ---- Summary ---- */

#summary {
   width: 70%;
   text-align: justify;
   line-height: 1.6;
}

/* ---- Code ---- */
pre {
   width: 90%;
   white-space: pre-wrap;
   word-break: break-all;
   word-wrap: break-word;
}
</style>
      <!---- ---->

      <title>Arbre binaire - napnac</title>
   </head>

   <body>

      <!-- Javascript -->
<script type="text/javascript">
function toggle_visibility(id) {
   var element = document.getElementById(id);
   if(element.style.display == 'block')
      element.style.display = 'none';
   else
      element.style.display = 'block';
}
</script>
      <!---- ---->

      <header>
         <a href="/">
            <img src="//static.napnac.ga/img/logo.png" alt="Logo du site" height="100" width="300">
         </a>

      </header>

      <nav>
         <ul id="main_menu">
            <li><a href="/">Accueil</a></li>
            <li><a href="/articles.html">Articles</a></li>
            <li><a href="/projets.html">Projets</a></li>
            <li><a href="/a_propos.html">A propos</a></li>
         </ul>
      </nav>

      <!-- Page/Article -->

<a href=""><h1 id="arbre-binaire">Arbre binaire</h1></a>
<p>Publi&#233; le : 27/12/2015<br />
<em>Modifi&#233; le : 14/01/2016</em></p>
<ul id="summary">
<li><a href="#introduction">Introduction</a></li>
<li><a href="#d&#233;finition">D&#233;finition</a></li>
<li><a href="#op&#233;rations">Op&#233;rations</a></li>
<li><a href="#impl&#233;mentation">Impl&#233;mentation</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>Je vous donne un tableau contenant des nombres entiers, et je vous pose une simple question : Quelle est la valeur maximale de ce tableau ? Naturellement, on peut parcourir tous les &#233;l&#233;ments et les comparer afin de trouver le maximum, cet algorithme na&#239;f a une complexit&#233; lin&#233;aire en <span class="math inline">\(O(N)\)</span> avec <span class="math inline">\(N\)</span> la taille du tableau. Mais maintenant, je d&#233;cide de changer quelques valeurs dans le tableau et je vous repose la question. On peut &#224; nouveau parcourir tout le tableau, et comparer nos <span class="math inline">\(N\)</span> &#233;l&#233;ments pour chercher le maximum, mais peut-on faire mieux ? Une des premi&#232;res id&#233;es qui peut vous venir &#224; l'esprit serait d'utiliser une variable en plus du tableau qui contient le maximum actuel, on l'initialise avec le maximum qu'on a trouv&#233; en parcourant le tableau, et ensuite d&#232;s qu'on effectue une modification on compare cette variable aux valeurs que l'on change pour la mettre &#224; jour. Cependant cette m&#233;thode, qui peut paraitre bien au premier coup d'&#339;il, ne fonctionne pas dans tous les cas. Si la valeur que l'on change dans le tableau est l'ancien maximum (et donc la valeur de notre variable externe), alors il se peut que le nouveau maximum ne soit plus la valeur qu'on a chang&#233;e mais une autre contenue dans le reste du tableau :</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/structure/arbre/arbre_binaire/contre_exemple_intro.png" alt="Contre-exemple de l&#39;algorithme propos&#233;" />
<p class="caption">Contre-exemple de l'algorithme propos&#233;</p>
</div>
<p>Dans cet exemple, on part du tableau 8, 3, 14, 42, 2, 0 qu'on a parcouru et dont on a retenu la valeur maximale (en vert) dans notre variable &#224; part : 42. Cependant, quand on change le maximum actuel par un nombre plus petit (7 dans notre cas), la variable externe ne change pas puisque 7 &lt; 42 alors que le maximum du tableau n'est plus le m&#234;me (c'est 14 d&#233;sormais). Cet algorithme est donc invalide, et il nous en faut un nouveau pour trouver rapidement le maximum d'un tableau dynamique.</p>
<p>Une autre id&#233;e serait de diviser notre gros probl&#232;me en plus petits sous probl&#232;mes. Au lieu de se demander quel est le maximum de tout le tableau, on peut commencer par se demander quel est le maximum entre les deux premiers &#233;l&#233;ments du tableau, puis entre les deux suivants, etc. Une fois qu'on a tous ces maximums, on a divis&#233; le nombre d'&#233;l&#233;ments &#224; visiter par deux pour r&#233;pondre &#224; notre probl&#232;me initial puisque d&#233;sormais on peut simplement parcourir les maximums locaux pour trouver le maximum du tableau. Mais on peut continuer de diviser notre probl&#232;me, en trouvant les maximums des maximums, etc. jusqu'&#224; arriver &#224; la valeur maximale contenue dans le tableau.</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/structure/arbre/arbre_binaire/representation_probleme_intro.png" alt="Repr&#233;sentation des sous probl&#232;mes" />
<p class="caption">Repr&#233;sentation des sous probl&#232;mes</p>
</div>
<p>Les &#233;l&#233;ments en bleus repr&#233;sentent notre tableau initial, et l'&#233;l&#233;ment en vert est le maximum du tableau trouv&#233; gr&#226;ce &#224; notre m&#233;thode. On commence en bas avec notre tableau, et on monte progressivement en prenant &#224; chaque fois les maximums deux &#224; deux. Cette structure s'apparente &#224; un <a href="/algo/structure/arbre.html">arbre</a>, mais a la particularit&#233; de ne pas poss&#233;der plus de deux fils par n&#339;ud (car on compare les &#233;l&#233;ments deux &#224; deux &#224; chaque fois). Cette propri&#233;t&#233; nous permet de d&#233;montrer qu'il suffit dans le pire des cas <span class="math inline">\(log _2 N\)</span> changements (en savoir plus sur les <a href="https://en.wikipedia.org/wiki/Logarithm">logarithmes</a>) pour modifier le maximum du tableau (et donc la racine de l'arbre). C'est-&#224;-dire que lorsqu'on modifie des valeurs, il suffit uniquement de modifier les p&#232;res des n&#339;uds affect&#233;s, et de simplement remonter petit &#224; petit &#224; la racine en recalculant uniquement les maximums locaux n&#233;cessaires. Or, la hauteur de cet arbre est dans le pire des cas de <span class="math inline">\(log _2 N\)</span>, notre algorithme a donc une complexit&#233; en <span class="math inline">\(O(\log _2 N)\)</span> pour trouver le maximum d'un tableau dynamique.</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/structure/arbre/arbre_binaire/changement_valeur_intro.png" alt="Changement d&#39;une valeur dans notre tableau" />
<p class="caption">Changement d'une valeur dans notre tableau</p>
</div>
<p>Pour changer une valeur dans notre tableau (ici le 1 devient un 11), on change aussi les n&#339;uds de l'arbre en remontant tant que le maximum local a chang&#233;.</p>
<p>Cette structure de donn&#233;es porte un nom : un arbre binaire (et plus particuli&#232;rement un arbre binaire maximal dans notre cas), et elle est tr&#232;s utile dans le domaine de la recherche, mais nous verrons que son utilisation ne se limite pas &#224; cette cat&#233;gorie d'algorithme et qu'elle est pr&#233;sente dans de nombreux autres structures de donn&#233;es plus complexes.</p>
<h2 id="d&#233;finition">D&#233;finition</h2>
<p>Un arbre binaire (ou <em>binary tree</em> en anglais) est un type d'<a href="/algo/structure/arbre.html">arbre</a> sp&#233;cifique avec comme contrainte de ne pas avoir plus de deux fils par n&#339;uds. On appelle alors les deux fils d'un n&#339;ud le <em>fils gauche</em> et le <em>fils droit</em>.</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/structure/arbre/arbre_binaire/exemple_arbre_binaire.png" alt="Exemple d&#39;arbre binaire" />
<p class="caption">Exemple d'arbre binaire</p>
</div>
<p>Cette structure de donn&#233;es a l'avantage d'&#234;tre tr&#232;s modulable et on peut lui appliquer diff&#233;rentes propri&#233;t&#233;s afin d'en changer son comportement, en voici quelques-unes :</p>
<ul>
<li>L'arbre binaire <strong>maximal</strong> a la particularit&#233; d'avoir chaque n&#339;ud parent comme &#233;tant le maximum de ses deux fils. C'est la structure utilis&#233;e dans l'exemple de l'introduction, on part d'un tableau initial et on cr&#233;e l'arbre en prenant deux &#224; deux les maximums en remontant jusqu'&#224; avoir une racine.</li>
<li>L'arbre binaire <strong>minimal</strong> repose sur le m&#234;me principe que le pr&#233;c&#233;dent, sauf que chaque parent repr&#233;sente le minimum de ses fils.</li>
<li>Un <a href="/algo/structure/arbre/tas.html"><strong>tas</strong></a> (et plus particuli&#232;rement un tas binaire) permet un stockage plus efficace qu'avec un arbre binaire max/min en &#233;vitant de cr&#233;er des doublons des diff&#233;rents n&#339;uds dans l'arbre, et r&#233;pond rapidement &#224; des questions de maximum/minimum dynamiques.</li>
<li>Un <strong>arbre binaire de recherche</strong> attribue &#224; chaque n&#339;ud une <em>cl&#233;</em> qui va organiser l'arbre. Tous les n&#339;uds &#224; gauche d'un n&#339;ud p&#232;re auront tous des cl&#233;s inf&#233;rieures &#224; ce dernier, et tous les n&#339;uds &#224; droite auront une cl&#233; sup&#233;rieure.</li>
<li>Un <strong>arbre rouge et noir</strong> est la m&#234;me id&#233;e qu'un arbre binaire de recherche, except&#233; que chaque n&#339;ud a une <em>couleur</em> qui permet d'organiser l'arbre mais aussi de l'&#233;quilibrer pour ne pas avoir un c&#244;t&#233; bien plus grand que l'autre &#224; cause de l'ordre des cl&#233;s.</li>
</ul>
<h2 id="op&#233;rations">Op&#233;rations</h2>
<p>Dans un arbre binaire, ajouter et supprimer un &#233;l&#233;ment est relativement simple, il suffit uniquement de respecter les propri&#233;t&#233;s de l'arbre utilis&#233;. Dans notre cas, on utilise un arbre binaire normal :</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/structure/arbre/arbre_binaire/exemple_insertion_noeud.png" alt="Exemple d&#39;insertion de n&#339;uds dans un arbre binaire" />
<p class="caption">Exemple d'insertion de n&#339;uds dans un arbre binaire</p>
</div>
<p>Ajouter un n&#339;ud suit une logique, on cherche &#224; ne pas faire de &quot;trous&quot; dans notre arbre binaire, et on va donc combler tant que possible les espaces vides dans l'ordre (les n&#339;uds en verts repr&#233;sentent le nouveau n&#339;ud &#224; chaque &#233;tape).</p>
<p>Pour la suppression d'un n&#339;ud, il y a trois cas possibles :</p>
<ul>
<li>Soit le n&#339;ud &#224; supprimer est une feuille, dans ce cas rien de plus simple et on le supprime sans se soucier du reste.</li>
<li>Soit le n&#339;ud poss&#232;de un fils, on remplace alors ce n&#339;ud par son unique fils.</li>
<li>Soit le n&#339;ud a deux fils, et il faut d&#233;cider quel n&#339;ud va remplacer le p&#232;re, c'est assez ambigu car on ne peut pas r&#233;ellement choisir dans un arbre binaire normal puisque les deux fils peuvent tous les deux remplacer le n&#339;ud parent, il faut donc choisir &#224; l'avance selon ses propres crit&#232;res. Heureusement, ce n'est pas toujours le cas et lorsque notre arbre binaire a des propri&#233;t&#233;s (ce qui arrivera souvent), on peut alors d&#233;cider quel n&#339;ud choisir afin de remplacer le p&#232;re, en fonction desdites propri&#233;t&#233;s.</li>
</ul>
<div class="figure">
<img src="//static.napnac.ga/img/algo/structure/arbre/arbre_binaire/exemple_suppression_noeud.png" alt="Diff&#233;rents cas de suppression de n&#339;uds dans un arbre binaire" />
<p class="caption">Diff&#233;rents cas de suppression de n&#339;uds dans un arbre binaire</p>
</div>
<p>Dans le premier cas, <em>C</em> est une feuille, il n'y a donc aucuns soucis pour le supprimer. Dans le deuxi&#232;me cas, <em>B</em> a un fils <em>D</em>, lorsqu'on supprime <em>B</em> on le remplace donc par <em>D</em>.</p>
<h3 id="arbres-binaires-sp&#233;cifiques">Arbres binaires sp&#233;cifiques</h3>
<p>D&#232;s qu'un arbre binaire poss&#232;de des propri&#233;t&#233;s, les op&#233;rations d'insertion et de suppression sont diff&#233;rentes. Elles peuvent &#234;tre plus ou moins complexes en fonction des propri&#233;t&#233;s ajout&#233;es &#224; l'arbre binaire, mais doivent &#234;tre bien d&#233;finies pour avoir une structure op&#233;rationnelle. D'autres op&#233;rations peuvent &#234;tre utiles sur certains arbres binaires, par exemple la possibilit&#233; de changer une valeur dans un tableau (ce qui implique souvent des changements dans l'arbre en lui-m&#234;me). Le parcours d'un arbre binaire peut aussi &#233;voluer en fonction de ses caract&#233;ristiques, et m&#234;me s'il reste un arbre, parfois il faut adapter sa m&#233;thode de parcours pour utiliser le mieux possible la structure de donn&#233;es.</p>
<h2 id="impl&#233;mentation">Impl&#233;mentation</h2>
<p>M&#234;me s'il est tr&#232;s rare de devoir impl&#233;menter un simple arbre binaire sans aucunes propri&#233;t&#233;s, savoir le repr&#233;senter est important, car c'est en fonction de cette repr&#233;sentation que l'on peut ensuite construire des op&#233;rations sp&#233;cifiques &#224; la structure. Un arbre binaire n'est techniquement qu'une structure d&#233;riv&#233;e de l'arbre, on peut donc l'impl&#233;menter de la m&#234;me fa&#231;on que ce dernier, mais vu les contraintes de cette structure de donn&#233;es, il est possible d'utiliser d'autres mani&#232;res.</p>
<h3 id="recoder-&#224;-la-main">Recoder &#224; la main</h3>
<p>Les possibilit&#233;s d'impl&#233;mentation d'un arbre ne s'appliquent pas forc&#233;ment bien pour un arbre binaire, en effet, on sait qu'il n'aura qu'au maximum deux fils, on peut donc simplement utiliser une structure auto r&#233;f&#233;rentielle :</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="kw">struct</span> Noeud Noeud;
<span class="kw">struct</span> Noeud 
{
   Noeud *gauche;
   Noeud *droit;
   <span class="dt">int</span> donnee;
};

<span class="kw">typedef</span> Noeud *ArbreBinaire;</code></pre></div>
<p>Chaque n&#339;ud pointe alors vers ses deux fils, reliant ainsi les &#233;l&#233;ments entre eux pour former notre arbre binaire. Cette solution permet un stockage optimal en m&#233;moire, ainsi qu'une facilit&#233; pour ins&#233;rer et supprimer des &#233;l&#233;ments, mais elle peut &#234;tre un inconv&#233;nient lorsqu'on a besoin d'acc&#233;der rapidement &#224; des &#233;l&#233;ments (en effet, il faut parcourir l'arbre jusqu'&#224; un &#233;l&#233;ment particulier pour r&#233;cup&#233;rer ses donn&#233;es).</p>
<h3 id="tableau">Tableau</h3>
<p>Une autre impl&#233;mentation consiste &#224; utiliser un simple tableau, permettant un acc&#232;s rapide en <span class="math inline">\(O(1)\)</span> &#224; n'importe quel &#233;l&#233;ment, mais qui est moins souple que la derni&#232;re solution. On l'utilise notamment pour construire des arbres binaires min ou max, car on n'a pas besoin de modifier d'autres n&#339;uds que des feuilles dans ces derniers, et on veut souvent acc&#233;der &#224; la racine rapidement.</p>
<p>Pour stocker notre arbre binaire, on va prendre chaque &#233;l&#233;ment de l'arbre profondeur par profondeur (de gauche &#224; droite), et les placer dans le tableau dans cet ordre.</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/structure/arbre/arbre_binaire/exemple_imple_tableau.png" alt="Exemple de repr&#233;sentation d&#39;un arbre binaire dans un tableau" />
<p class="caption">Exemple de repr&#233;sentation d'un arbre binaire dans un tableau</p>
</div>
<p>Ce tableau permet notamment un acc&#232;s rapide, et un parcours facile gr&#226;ce &#224; sa mani&#232;re de stocker les n&#339;uds qui nous renseigne sur qui est le p&#232;re/fils gauche/fils droit d'un n&#339;ud :</p>
<ul>
<li>La racine sera l'&#233;l&#233;ment 1 du tableau.</li>
<li>Chaque n&#339;ud d'indice <span class="math inline">\(N\)</span> a son fils gauche stock&#233; en indice <span class="math inline">\(2N\)</span>, et son fils droit en indice <span class="math inline">\(2N + 1\)</span>.</li>
<li>Chaque n&#339;ud d'indice <span class="math inline">\(N\)</span> (except&#233; pour la racine de l'arbre) a son p&#232;re dans le tableau en indice <span class="math inline">\(N / 2\)</span> (on gardera juste la partie enti&#232;re du r&#233;sultat).</li>
</ul>
<p>Ce tableau suffit donc &#224; stocker un arbre binaire :</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> arbreBinaire[NB_NOEUD_ARBRE + <span class="dv">1</span>];</code></pre></div>
<p>On n'oublie pas d'allouer une case de plus dans notre tableau car la racine doit obligatoirement &#234;tre l'&#233;l&#233;ment d'indice 1 du tableau pour satisfaire les propri&#233;t&#233;s de placement des n&#339;uds.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Cela peut paraitre &#233;trange de penser qu'un simple arbre avec une contrainte sur le nombre de n&#339;uds de ses fils peut &#234;tre extr&#234;mement utile. Et pourtant, les arbres binaires sont pr&#233;sents dans &#233;norm&#233;ment d'algorithmes et de structures de donn&#233;es, et en voici une courte liste :</p>
<ul>
<li><p><strong>Recherche</strong> :</p>
<ul>
<li>Comme vu dans l'introduction, un arbre binaire peut &#234;tre maximal ou minimal, facilitant la recherche du maximum/minimum dans un tableau dynamique.</li>
<li>Certains <a href="/algo/structure/arbre/arbre_recherche.html">arbres de recherche</a> sont des arbres binaires, comme l'arbre rouge et noir ou encore l'arbre binaire de recherche dont nous avons parl&#233;.</li>
</ul></li>
<li><p><strong>Structure de donn&#233;es</strong> :</p>
<ul>
<li>Le <a href="/algo/structure/arbre/tas.html">tas</a> est sans doute la structure de donn&#233;es bas&#233;e sur un arbre binaire la plus utilis&#233;e. Elle est tr&#232;s efficace pour chercher mais aussi trier des &#233;l&#233;ments, et cette structure a comme l'arbre binaire, un champ d'application tr&#232;s large.</li>
<li>Le <a href="https://en.wikipedia.org/wiki/T-tree">T-tree</a> est un arbre binaire modifi&#233; permettant de grandes optimisations de m&#233;moire, souvent utilis&#233; dans de grosses bases de donn&#233;es.</li>
</ul></li>
<li><p><strong>Tri</strong> :</p>
<ul>
<li>Le <a href="/algo/tri/tri_tas.html">tri par tas</a> bas&#233; donc sur un tas, est un algorithme de tri efficace avec une complexit&#233; en temps de <span class="math inline">\(O(N \log _2 N)\)</span>. De plus, son am&#233;lioration le smoothsort fond&#233;e elle aussi sur des arbres binaires, permet dans le meilleur des cas une complexit&#233; en temps lin&#233;aire.</li>
</ul></li>
<li><p><strong>Compression</strong> :</p>
<ul>
<li>Le <a href="https://en.wikipedia.org/wiki/Huffman_coding">codage de Huffman</a> est un c&#233;l&#232;bre algorithme de compression des donn&#233;es sans perte, utilisant en partie des arbres binaires pour fonctionner.</li>
</ul></li>
<li><p><strong>Syntaxe</strong> :</p>
<ul>
<li>Les <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">arbres syntaxiques</a> sont eux aussi cr&#233;&#233;s &#224; partir d'arbres binaires, et sont le c&#339;ur du fonctionnement d'un compilateur ou tout autre parseur d'expression.</li>
</ul></li>
<li><p><strong>G&#233;om&#233;trie/Graphique</strong> :</p>
<ul>
<li>La plupart des jeux 3D utilisent des <a href="https://en.wikipedia.org/wiki/Binary_space_partitioning">arbres binaires sp&#233;cifiques</a> afin de savoir quel objet a besoin d'&#234;tre affich&#233; ou non &#224; l'&#233;cran.</li>
</ul></li>
</ul>
<p>La liste des applications d'un arbre binaire peut continuer longtemps, car cette structure de donn&#233;es est fondamentale en algorithmique. Son principe est simple, son impl&#233;mentation aussi, mais ses applications peuvent &#234;tre tr&#232;s complexes.</p>
 
      <!-- ------------ -->

      <footer>
         <hr>
         <p>Une question ? Une suggestion ? N'h&#233;sitez pas &#224; me <a href="/a_propos.html">contacter</a> pour me communiquer vos remarques.
         <br>
      </footer>

   </body>
</html>
