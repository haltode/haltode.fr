<!DOCTYPE html>
<html>
   <head>
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato&#38;subset=latin,latin-ext" type="text/css" />
      <link rel="icon" type="image/x-icon" href="//static.napnac.ga/img/favicon.ico">
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/github-gist.min.css">

      <!-- Syntax highlighting -->
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script>

      <!-- Renders LaTeX expression -->
      <script type="text/x-mathjax-config">
         MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
      </script>
      <script type="text/javascript" async
         src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">
      </script>

      <!-- CSS -->
<style>
body {
   font-family: "Helvetica Neue", 'Lato', Helvetica, sans-serif;
   max-width: 1000px;
   margin: 0 auto;
   position: relative;
   width: 95%;
   line-height: 1.5;
}

/* ---- Titles ---- */

h1 {
   padding-top: 2%;
   padding-bottom: 2%;
   color: #DE4834;
}

h2, h3, h4, h5, h6 {
   padding-top: 1%;
   padding-bottom: 1%;
   color: #DE4834;
}

/* ---- Link ---- */

a {
   text-decoration: none;
   color: #2E64FE;
}

/* ---- List (+ main menu list) ---- */

ul {
   padding-left: 30px;
}

#main_menu {
   list-style: none;
   margin: 0;
   padding: 0;
   text-align: center;
}
#main_menu li {
   display: inline;
   margin-right: 1px;
}
#main_menu li a {
   line-height: 1em;
   padding: 4px 20px;
   text-align: center;
}
#main_menu li a:hover, #main_menu li a:active {
   text-decoration: underline;
}

/* ---- Tables (same look as from github markdown layout) ---- */

table {
   display: block;
   width: 100%;
   overflow: auto;
   word-break: normal;
   word-break: keep-all;
   border-collapse: collapse;
   border-spacing: 0;
   margin-top: 0;
   margin-bottom: 16px;
}

table th {
   font-weight: bold;
}

table th,
table td {
   padding: 6px 13px;
   border: 1px solid #ddd;
}

table tr {
   background-color: #fff;
   border-top: 1px solid #ccc;
}

table tr:nth-child(2n) {
   background-color: #f8f8f8;
}

/* ---- Image and caption ---- */

.figure {
   text-align: center;
}

.caption {
   font-style: italic;
   text-align: center;
}

/* ---- Summary ---- */

#summary {
   width: 70%;
   text-align: justify;
   line-height: 1.6;
}

/* ---- Code ---- */
pre {
   width: 90%;
   white-space: pre-wrap;
   word-break: break-all;
   word-wrap: break-word;
}

/* ---- Temporary css ---- */

.pret {
   background-color: #00CC00;
   display: inline;
}

.relire {
   background-color: #FF9900;
   display: inline;
}

.faire {
   background-color: #FF0000;
   display: inline;
}
</style>
      <!---- ---->

      <title>Tas - napnac</title>
   </head>

   <body>

      <!-- Javascript -->
<script type="text/javascript">
function toggle_visibility(id) {
   var element = document.getElementById(id);
   if(element.style.display == 'block')
      element.style.display = 'none';
   else
      element.style.display = 'block';
}
</script>
      <!---- ---->

      <header>
         <a href="/">
            <img src="//static.napnac.ga/img/logo.png" alt="Logo du site" height="100" width="300">
         </a>

      </header>

      <nav>
         <ul id="main_menu">
            <li><a href="/">Accueil</a></li>
            <li><a href="/articles.html">Articles</a></li>
            <li><a href="/projets.html">Projets</a></li>
            <li><a href="/a_propos.html">A propos</a></li>
         </ul>
      </nav>

      <!-- Page/Article -->

<a href=""><h1 id="tas">Tas</h1></a>
<p>Publi&#233; le : 11/01/2016<br />
<em>Modifi&#233; le : 18/01/2016</em></p>
<ul id="summary">
<li><a href="#introduction">Introduction</a></li>
<li><a href="#principe-du-tas">Principe du tas</a></li>
<li><a href="#op&#233;rations-sur-un-tas">Op&#233;rations sur un tas</a></li>
<li><a href="#pseudo-code">Pseudo-code</a></li>
<li><a href="#complexit&#233;">Complexit&#233;</a></li>
<li><a href="#impl&#233;mentation">Impl&#233;mentation</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>TODO : refaire intro : probl&#232;me de base 2 op&#233;rations -extraire min/max -ins&#233;rer valeur<br />
TODO : changer entr&#233;e/sortie de l'impl&#233; en fonction du probl&#232;me pos&#233; en intro</p>
<p>Dans l'introduction de mon article sur les <a href="/algo/structure/arbre/arbre_binaire.html">arbres binaires</a>, on a vu une m&#233;thode permettant de trouver le maximum dans un tableau dynamique avec une complexit&#233; en temps efficace de <span class="math inline">\(O(\log _2 N)\)</span>. Cependant, qu'en est-il de la complexit&#233; en m&#233;moire ? En effet, on cr&#233;e de nombreuses fois des doublons afin d'avoir notre arbre binaire maximal final, mais peut-on faire autrement ? C'est l&#224; qu'on d&#233;couvre le <strong>tas</strong>, une structure permettant de faire des recherches rapides, des comparaisons efficaces, et qui prend peu de place. On peut comprendre qu'avec tous ces avantages, le tas est une structure de donn&#233;es &#233;norm&#233;ment utilis&#233;e, et importante &#224; conna&#238;tre.</p>
<h2 id="principe-du-tas">Principe du tas</h2>
<p>Le tas (ou <em>heap</em> en anglais), sera la plupart du temps impl&#233;ment&#233; comme un <strong>tas binaire</strong>, c'est-&#224;-dire qu'il est construit sur la forme d'un arbre binaire. C'est sur cette structure que l'on va donc se concentrer dans cet article, mais sachez qu'il est possible de cr&#233;er des tas bas&#233;s sur des arbres autres que binaires.</p>
<p>Dans notre arbre binaire maximal, le p&#232;re d'un n&#339;ud est le maximum des deux n&#339;uds (autrement dit, c'est soit l'un soit l'autre), dans un tas binaire, le p&#232;re d'un n&#339;ud n'est pas un double de ses enfants, mais au contraire un autre n&#339;ud ind&#233;pendant qui respecte une propri&#233;t&#233; sp&#233;cifique au tas (<strong>tas minimal</strong> : alors le p&#232;re a une valeur inf&#233;rieure ou &#233;gale &#224; celles de ses fils, et <strong>tas maximal</strong> : le p&#232;re a une valeur sup&#233;rieure ou &#233;gale &#224; celles de ses fils).</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/structure/arbre/tas/exemple_tas_max.png" alt="Exemple de tas maximal" />
<p class="caption">Exemple de tas maximal</p>
</div>
<p>Ce tas max peut repr&#233;senter le tableau situ&#233; en dessous, et le fait qu'il soit maximal nous permet de dire avec certitude que sa racine est l'&#233;l&#233;ment maximum du tableau (de m&#234;me un tas min aura &#224; la racine l'&#233;l&#233;ment minimum du tableau).</p>
<h2 id="op&#233;rations-sur-un-tas">Op&#233;rations sur un tas</h2>
<p>Un tas ne peut pas avoir de &quot;trous&quot; dedans, seul le dernier &#233;tage de l'arbre peut ne pas &#234;tre rempli en entier. Lorsqu'on veut ins&#233;rer un nouvel &#233;l&#233;ment, on a donc pas d'autres choix que de le placer &#224; la premi&#232;re place libre que l'on trouve dans le tas. Cependant, ce nouvel &#233;l&#233;ment ne respecte pas les propri&#233;t&#233;s du tas, et il va falloir &#233;changer des &#233;l&#233;ments afin d'avoir une structure coh&#233;rente. Pour cela, on applique le m&#234;me principe que lors d'un changement d'une valeur dans un arbre binaire maximal, c'est-&#224;-dire que l'on va modifier tous les n&#339;uds parents tant que les propri&#233;t&#233;s du tas ne sont pas respect&#233;es.</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/structure/arbre/tas/exemple_insertion_tas_max.png" alt="Exemple d&#39;insertion d&#39;un nouvel &#233;l&#233;ment dans un tas maximal" />
<p class="caption">Exemple d'insertion d'un nouvel &#233;l&#233;ment dans un tas maximal</p>
</div>
<p>On souhaite ins&#233;rer la valeur 11 (en vert) dans notre tas maximal, on le place donc sur la premi&#232;re place libre, puis on l'&#233;change avec son p&#232;re tant que ce dernier est plus petit que 11 (car c'est un tas maximal). A la fin, 11 a &#233;t&#233; ins&#233;r&#233;, et notre tas respecte bien les propri&#233;t&#233;s d'un tas max.</p>
<p>La deuxi&#232;me op&#233;ration principale d'un tas est l'extraction de son minimum/maximum (en fonction des propri&#233;t&#233;s du tas). On a vu que cette valeur se trouve forc&#233;ment &#224; la racine, mais comment reboucher le trou qu'on vient de faire ? Une solution consiste &#224; prendre le dernier &#233;l&#233;ment du tas (sur le dernier &#233;tage), et de le d&#233;placer &#224; la racine. Vu que c'est une feuille, on peut tr&#232;s bien le bouger de place sans inconv&#233;nient, cependant on ne respecte plus les propri&#233;t&#233;s du tas. On va donc <strong>entasser</strong> cet &#233;l&#233;ment pour qu'il se retrouve &#224; sa bonne place :</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/structure/arbre/tas/exemple_extraction_tas_max.png" alt="Exemple d&#39;extraction du maximum dans un tas" />
<p class="caption">Exemple d'extraction du maximum dans un tas</p>
</div>
<p>On extrait 42 qui est le maximum de notre tas, et on ins&#232;re la derni&#232;re valeur du tas &#224; la place de la racine pour boucher le trou (4 en vert). Pour entasser notre &#233;l&#233;ment et respecter les caract&#233;ristiques d'un tas max, on &#233;change le n&#339;ud avec le maximum de ses deux fils tant qu'on peut (pour un tas min, on &#233;change avec le minimum de ses deux fils). Gr&#226;ce &#224; cela, on a reconstitu&#233; notre tas maximum, car le 4 est de nouveau a une place qui respecte le tas max.</p>
<h2 id="pseudo-code">Pseudo-code</h2>
<p>Le pseudo-code des deux op&#233;rations du tas max :</p>
<pre class="nohighlight"><code>insertion (n&#339;ud) :
   
   Ins&#233;rer le n&#339;ud &#224; la premi&#232;re place disponible dans le tas

   Tant que son p&#232;re est plus petit que lui
      Echanger les n&#339;uds

extraction :

   Retirer la racine du tas

   Reboucher avec le dernier &#233;l&#233;ment du tas
   Tant que le n&#339;ud n&#39;est pas plus grand que ses deux fils
      Echanger avec le maximum de ses fils

   Retourner l&#39;ancienne racine</code></pre>
<p>Et la variante pour le tas min :</p>
<pre class="nohighlight"><code>insertion (n&#339;ud) :
   
   Ins&#233;rer le n&#339;ud &#224; la premi&#232;re place disponible dans le tas

   Tant que son p&#232;re est plus grand que lui
      Echanger les n&#339;uds

extraction :

   Retirer la racine du tas

   Reboucher avec le dernier &#233;l&#233;ment du tas
   Tant que le n&#339;ud n&#39;est pas plus petit que ses deux fils
      Echanger avec le minimum de ses fils

   Retourner l&#39;ancienne racine</code></pre>
<h2 id="complexit&#233;">Complexit&#233;</h2>
<p>Notre tas binaire est bas&#233; sur un arbre binaire, il a donc une hauteur maximale de <span class="math inline">\(O(\log _2 N)\)</span> avec <span class="math inline">\(N\)</span> le nombre d'&#233;l&#233;ments du tas. Pour l'insertion d'un &#233;l&#233;ment, on fait dans le pire des cas remonter le n&#339;ud jusqu'&#224; la racine et donc on effectue <span class="math inline">\(\log _2 N\)</span> op&#233;rations. Pareil pour l'extraction du min/max, on fait dans le pire des cas <span class="math inline">\(\log _2 N\)</span> &#233;changes, r&#233;sultant dans les deux cas en une complexit&#233; en <span class="math inline">\(O(\log _2 N)\)</span>.</p>
<h2 id="impl&#233;mentation">Impl&#233;mentation</h2>
<p>Une impl&#233;mentation en C d'un tas max :</p>
<a href="javascript:toggle_visibility('tas_max.c');">tas_max.c</a>
<div id="tas_max.c" style="display: none;">
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;stdio.h&gt;</span>

<span class="ot">#define NB_NOEUD_MAX 1000</span>

<span class="dt">int</span> tas[NB_NOEUD_MAX];
<span class="dt">int</span> nbElement;

<span class="dt">void</span> echanger(<span class="dt">int</span> a, <span class="dt">int</span> b)
{
   <span class="dt">int</span> c;

   c = tas[a];
   tas[a] = tas[b];
   tas[b] = c;
}

<span class="dt">int</span> max(<span class="dt">int</span> a, <span class="dt">int</span> b)
{
   <span class="kw">if</span>(tas[a] &gt; tas[b])
      <span class="kw">return</span> a;
   <span class="kw">else</span>
      <span class="kw">return</span> b;
}

<span class="dt">void</span> inserer(<span class="dt">int</span> valeur)
{
   <span class="dt">int</span> noeud, pere;

   ++nbElement;
   noeud = nbElement;
   tas[nbElement] = valeur;

   pere = noeud / <span class="dv">2</span>;
   <span class="kw">while</span>(pere != <span class="dv">0</span> &amp;&amp; 
         tas[noeud] &gt; tas[pere]) {
      echanger(noeud, pere);

      noeud = pere;
      pere = noeud / <span class="dv">2</span>;
   }
}

<span class="dt">int</span> extraire(<span class="dt">void</span>)
{
   <span class="dt">int</span> racine;
   <span class="dt">int</span> noeud, gauche, droit, fils;

   racine = tas[<span class="dv">1</span>];

   tas[<span class="dv">1</span>] = tas[nbElement];
   --nbElement;

   noeud = <span class="dv">1</span>;
   gauche = <span class="dv">2</span>;
   droit = <span class="dv">3</span>;

   <span class="kw">while</span>(gauche &lt;= nbElement &amp;&amp;
         (tas[noeud] &lt; tas[gauche] || tas[noeud] &lt; tas[droit])) {
      fils = max(gauche, droit);
      echanger(noeud, fils);

      noeud = fils;
      gauche = <span class="dv">2</span> * noeud;
      droit = <span class="dv">2</span> * noeud + <span class="dv">1</span>;
   }

   <span class="kw">return</span> racine;
}

<span class="dt">int</span> estPuissanceDeux(<span class="dt">int</span> x)
{
   <span class="kw">return</span> (x &amp; (x - <span class="dv">1</span>)) == <span class="dv">0</span>;
}

<span class="dt">void</span> afficher(<span class="dt">void</span>)
{
   <span class="dt">int</span> iEle;
   <span class="kw">for</span>(iEle = <span class="dv">1</span>; iEle &lt;= nbElement; ++iEle) {
      printf(<span class="st">&quot;%d &quot;</span>, tas[iEle]);
      <span class="kw">if</span>(estPuissanceDeux(iEle + <span class="dv">1</span>))
         printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
   }
   
   printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
}

<span class="dt">int</span> main(<span class="dt">void</span>)
{
   inserer(<span class="dv">12</span>);
   inserer(<span class="dv">9</span>);
   inserer(<span class="dv">1</span>);
   inserer(<span class="dv">42</span>);
   inserer(<span class="dv">10</span>);
   inserer(<span class="dv">27</span>);
   inserer(<span class="dv">3</span>);
   inserer(<span class="dv">5</span>);
   inserer(<span class="dv">4</span>);
   inserer(<span class="dv">6</span>);
   inserer(<span class="dv">3</span>);
   inserer(<span class="dv">8</span>);
   afficher();
   printf(<span class="st">&quot;%d</span><span class="ch">\n</span><span class="st">&quot;</span>, extraire());
   afficher();

   <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</div>
<p>J'impl&#233;mente un tas maximal, mais la version minimale du tas est quasiment la m&#234;me, il suffit de changer <code>tas[noeud] &gt; tas[pere]</code>, <code>tas[noeud] &lt; tas[gauche] || tas[noeud] &lt; tas[droit]</code> ainsi que la fonction <code>max</code>. Le code est plut&#244;t simple, mais j'utilise une petite astuce pour afficher le tas (la fonction <code>afficher</code> est juste l&#224; pour d&#233;bugger en g&#233;n&#233;ral, et voir si le tas est bien celui attendu). Pour afficher mon tas, il faut que j'effectue un retour &#224; la ligne lorsque le n&#339;ud est le 1er, le 3&#232;me, le 7&#232;me, 15&#232;me, etc. et tous ces nombres sont des puissances de 2 si l'on rajoute 1. De ce fait, on peut utiliser des <a href="https://en.wikipedia.org/wiki/Bitwise_operation">op&#233;rations bit &#224; bit</a> afin de v&#233;rifier si <code>noeud + 1</code> est une puissance de 2, et si c'est le cas, on a termin&#233; l'&#233;tage actuel du tas. C'est loin d'&#234;tre indispensable &#224; la compr&#233;hension du code, mais c'est toujours int&#233;ressant &#224; savoir.</p>
<p>En C++, la <a href="https://en.wikipedia.org/wiki/Standard_Template_Library">STL</a> (<em>Standard Template Library</em>) a une impl&#233;mentation d'une <a href="/algo/structure/file.html#file-&#224;-priorit&#233;">file &#224; priorit&#233;</a> utilisant un tas max : <a href="http://www.cplusplus.com/reference/queue/priority_queue/"><code>priority_queue</code></a>. Il est possible d'utiliser cette structure afin d'avoir un tas min, en red&#233;finissant l'op&#233;rateur <code>&lt;</code> nous permettant de changer l'ordre de priorit&#233; dans le tas :</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;queue&gt;</span>

<span class="kw">struct</span> Element
{
   <span class="dt">int</span> valeur;
   <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="dt">const</span> Element &amp;autre) <span class="dt">const</span>
   {
      <span class="kw">if</span>(valeur &lt; autre.valeur)
         <span class="kw">return</span> <span class="kw">false</span>;
      <span class="kw">else</span>
         <span class="kw">return</span> <span class="kw">true</span>;
   }
};

priority_queue &lt;Element&gt; tasMin;</code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>TODO : variantes + applications</p>
 
      <!-- ------------ -->

      <footer>
         <hr>
         <p>Une question ? Une suggestion ? N'h&#233;sitez pas &#224; me <a href="/a_propos.html">contacter</a> pour me communiquer vos remarques.
         <br>
      </footer>

   </body>
</html>
