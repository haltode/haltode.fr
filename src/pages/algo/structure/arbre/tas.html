<!DOCTYPE html>
<html>
   <head>
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato&#38;subset=latin,latin-ext" type="text/css" />
      <link rel="icon" type="image/x-icon" href="//static.napnac.ga/img/favicon.ico">
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/github-gist.min.css">

      <!-- Syntax highlighting -->
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script>

      <!-- Renders LaTeX expression -->
      <script type="text/x-mathjax-config">
         MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
      </script>
      <script type="text/javascript" async
         src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">
      </script>

      <!-- CSS -->
<style>
body {
   font-family: "Helvetica Neue", 'Lato', Helvetica, sans-serif;
   max-width: 1000px;
   margin: 0 auto;
   position: relative;
   width: 95%;
   line-height: 1.5;
}

/* ---- Titles ---- */

h1 {
   padding-top: 2%;
   padding-bottom: 2%;
   color: #DE4834;
}

h2, h3, h4, h5, h6 {
   padding-top: 1%;
   padding-bottom: 1%;
   color: #DE4834;
}

/* ---- Link ---- */

a {
   text-decoration: none;
   color: #2E64FE;
}

/* ---- List (+ main menu list) ---- */

ul {
   padding-left: 30px;
}

#main_menu {
   list-style: none;
   margin: 0;
   padding: 0;
   text-align: center;
}
#main_menu li {
   display: inline;
   margin-right: 1px;
}
#main_menu li a {
   line-height: 1em;
   padding: 4px 20px;
   text-align: center;
}
#main_menu li a:hover, #main_menu li a:active {
   text-decoration: underline;
}

/* ---- Tables (same look as from github markdown layout) ---- */

table {
   display: block;
   width: 100%;
   overflow: auto;
   word-break: normal;
   word-break: keep-all;
   border-collapse: collapse;
   border-spacing: 0;
   margin-top: 0;
   margin-bottom: 16px;
}

table th {
   font-weight: bold;
}

table th,
table td {
   padding: 6px 13px;
   border: 1px solid #ddd;
}

table tr {
   background-color: #fff;
   border-top: 1px solid #ccc;
}

table tr:nth-child(2n) {
   background-color: #f8f8f8;
}

/* ---- Image and caption ---- */

.figure {
   text-align: center;
}

.caption {
   font-style: italic;
   text-align: center;
}

/* ---- Summary ---- */

#summary {
   width: 70%;
   text-align: justify;
   line-height: 1.6;
}

/* ---- Code ---- */
pre {
   width: 90%;
   white-space: pre-wrap;
   word-break: break-all;
   word-wrap: break-word;
}

/* ---- Temporary css ---- */

.pret {
   background-color: #00CC00;
   display: inline;
}

.relire {
   background-color: #FF9900;
   display: inline;
}

.faire {
   background-color: #FF0000;
   display: inline;
}
</style>
      <!---- ---->

      <title>Tas - napnac</title>
   </head>

   <body>

      <!-- Javascript -->
<script type="text/javascript">
function toggle_visibility(id) {
   var element = document.getElementById(id);
   if(element.style.display == 'block')
      element.style.display = 'none';
   else
      element.style.display = 'block';
}
</script>
      <!---- ---->

      <header>
         <a href="/">
            <img src="//static.napnac.ga/img/logo.png" alt="Logo du site" height="100" width="300">
         </a>

      </header>

      <nav>
         <ul id="main_menu">
            <li><a href="/">Accueil</a></li>
            <li><a href="/articles.html">Articles</a></li>
            <li><a href="/projets.html">Projets</a></li>
            <li><a href="/a_propos.html">A propos</a></li>
         </ul>
      </nav>

      <!-- Page/Article -->

<a href=""><h1 id="tas">Tas</h1></a>
<p>Publi&#233; le : 11/01/2016<br />
<em>Modifi&#233; le : 22/01/2016</em></p>
<ul id="summary">
<li><a href="#introduction">Introduction</a></li>
<li><a href="#principe-du-tas">Principe du tas</a></li>
<li><a href="#op&#233;rations-sur-un-tas">Op&#233;rations sur un tas</a></li>
<li><a href="#pseudo-code">Pseudo-code</a></li>
<li><a href="#complexit&#233;">Complexit&#233;</a></li>
<li><a href="#impl&#233;mentation">Impl&#233;mentation</a></li>
<li><a href="#variantes">Variantes</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>Vous avez une liste d'&#233;l&#233;ments qui est vide au d&#233;part, et deux types d'op&#233;rations sont possibles dessus :</p>
<ul>
<li>Ins&#233;rer une valeur dans la liste.</li>
<li>Extraire le maximum (ou le minimum, le probl&#232;me reste le m&#234;me) de la liste.</li>
</ul>
<p>On a vu dans l'introduction de mon article sur les <a href="/algo/structure/arbre/arbre_binaire.html">arbres binaires</a>, comment trouver le maximum dans un tableau dynamique. On pourrait utiliser la m&#234;me m&#233;thode (que l'on change l&#233;g&#232;rement), et la m&#234;me structure, afin d'avoir une complexit&#233; en temps efficace de <span class="math inline">\(O(\log _2 N)\)</span>. Cependant, qu'en est-il de la complexit&#233; en m&#233;moire ? Que se passe-t-il si j'ai des milliards de milliards d'op&#233;rations ? En effet, on cr&#233;e de nombreuses fois des doublons afin d'avoir notre arbre binaire maximal final, mais peut-on faire autrement ? C'est l&#224; qu'on d&#233;couvre le <strong>tas</strong>, une structure permettant de faire des recherches rapides, des comparaisons efficaces, et qui prend peu de place. On peut comprendre qu'avec tous ces avantages, le tas est une structure de donn&#233;es &#233;norm&#233;ment utilis&#233;e, importante &#224; conna&#238;tre et qui peut s'av&#233;rer tr&#232;s utile quand on arrive aux limites des arbres binaires max/min (ce qui est notre cas dans cet exemple).</p>
<h2 id="principe-du-tas">Principe du tas</h2>
<p>Le tas (ou <em>heap</em> en anglais), sera la plupart du temps impl&#233;ment&#233; comme un <strong>tas binaire</strong>, c'est-&#224;-dire qu'il est construit sur la forme d'un arbre binaire. C'est sur cette structure que l'on va donc se concentrer dans cet article, mais sachez qu'il est possible de cr&#233;er des tas bas&#233;s sur des arbres autres que binaires.</p>
<p>Dans notre arbre binaire maximal, le p&#232;re d'un n&#339;ud est le maximum des deux n&#339;uds (autrement dit, c'est soit l'un soit l'autre), dans un tas binaire, le p&#232;re d'un n&#339;ud n'est pas un double de ses enfants, mais au contraire un autre n&#339;ud ind&#233;pendant qui respecte une propri&#233;t&#233; sp&#233;cifique au tas (<strong>tas minimal</strong> : alors le p&#232;re a une valeur inf&#233;rieure ou &#233;gale &#224; celles de ses fils, et <strong>tas maximal</strong> : le p&#232;re a une valeur sup&#233;rieure ou &#233;gale &#224; celles de ses fils).</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/structure/arbre/tas/exemple_tas_max.png" alt="Exemple de tas maximal" />
<p class="caption">Exemple de tas maximal</p>
</div>
<p>Ce tas max peut par exemple repr&#233;senter le tableau situ&#233; en dessous, et le fait qu'il soit maximal nous permet de dire avec certitude que sa racine est l'&#233;l&#233;ment maximum du tableau (de m&#234;me un tas min aura &#224; la racine l'&#233;l&#233;ment minimum du tableau).</p>
<h2 id="op&#233;rations-sur-un-tas">Op&#233;rations sur un tas</h2>
<p>Un tas ne peut pas avoir de &quot;trous&quot; dedans, seul le dernier &#233;tage de l'arbre peut ne pas &#234;tre rempli en entier. Lorsqu'on veut ins&#233;rer un nouvel &#233;l&#233;ment, on a donc pas d'autres choix que de le placer &#224; la premi&#232;re place libre que l'on trouve dans le tas. Cependant, ce nouvel &#233;l&#233;ment ne respecte pas les propri&#233;t&#233;s du tas, et il va falloir effectuer des modifications afin d'avoir une structure coh&#233;rente. Pour cela, on applique le m&#234;me principe que lors d'un changement d'une valeur dans un arbre binaire maximal, c'est-&#224;-dire que l'on va modifier tous les n&#339;uds parents tant que les propri&#233;t&#233;s du tas ne sont pas respect&#233;es.</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/structure/arbre/tas/exemple_insertion_tas_max.png" alt="Exemple d&#39;insertion d&#39;un nouvel &#233;l&#233;ment dans un tas maximal" />
<p class="caption">Exemple d'insertion d'un nouvel &#233;l&#233;ment dans un tas maximal</p>
</div>
<p>On souhaite ins&#233;rer la valeur 11 (en vert) dans notre tas maximal, on le place donc sur la premi&#232;re place libre, puis on l'&#233;change avec son p&#232;re tant que ce dernier est plus petit que 11 (car c'est un tas maximal). A la fin, 11 a &#233;t&#233; ins&#233;r&#233;, et notre tas respecte bien les propri&#233;t&#233;s d'un tas max.</p>
<p>La deuxi&#232;me op&#233;ration principale d'un tas est l'extraction de son minimum/maximum (en fonction du tas). On a vu que cette valeur se trouve forc&#233;ment &#224; la racine, mais comment reboucher le trou qu'on vient de faire ? Une solution consiste &#224; prendre le dernier &#233;l&#233;ment du tas, et de le d&#233;placer &#224; la racine. Vu que c'est une feuille, on peut tr&#232;s bien le bouger de place sans inconv&#233;nient, cependant on ne respecte plus les propri&#233;t&#233;s du tas. On va donc <strong>entasser</strong> cet &#233;l&#233;ment pour qu'il se retrouve &#224; sa bonne place :</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/structure/arbre/tas/exemple_extraction_tas_max.png" alt="Exemple d&#39;extraction du maximum dans un tas" />
<p class="caption">Exemple d'extraction du maximum dans un tas</p>
</div>
<p>On extrait 42 qui est le maximum de notre tas, et on ins&#232;re la derni&#232;re valeur &#224; la place de la racine pour boucher le trou (c'est le 4 en vert). Pour entasser notre &#233;l&#233;ment et respecter les caract&#233;ristiques d'un tas max, on &#233;change le n&#339;ud avec le maximum de ses deux fils tant qu'on peut (pour un tas min, on &#233;change avec le minimum de ses deux fils). Gr&#226;ce &#224; cela, on a reconstitu&#233; notre tas maximum, car le 4 est de nouveau a une place qui respecte les propri&#233;t&#233;s.</p>
<h2 id="pseudo-code">Pseudo-code</h2>
<p>Le pseudo-code des deux op&#233;rations du tas max :</p>
<pre class="nohighlight"><code>insertion (n&#339;ud) :
   
   Ins&#233;rer le n&#339;ud &#224; la premi&#232;re place disponible dans le tas

   Tant que son p&#232;re est plus petit que lui
      Echanger les n&#339;uds

extraction :

   Retirer la racine du tas

   Reboucher avec le dernier &#233;l&#233;ment du tas
   Tant que le n&#339;ud n&#39;est pas plus grand que ses deux fils
      Echanger avec le maximum de ses fils

   Retourner l&#39;ancienne racine</code></pre>
<p>Et la variante pour le tas min :</p>
<pre class="nohighlight"><code>insertion (n&#339;ud) :
   
   Ins&#233;rer le n&#339;ud &#224; la premi&#232;re place disponible dans le tas

   Tant que son p&#232;re est plus grand que lui
      Echanger les n&#339;uds

extraction :

   Retirer la racine du tas

   Reboucher avec le dernier &#233;l&#233;ment du tas
   Tant que le n&#339;ud n&#39;est pas plus petit que ses deux fils
      Echanger avec le minimum de ses fils

   Retourner l&#39;ancienne racine</code></pre>
<h2 id="complexit&#233;">Complexit&#233;</h2>
<p>Notre tas binaire est bas&#233; sur un arbre binaire, il a donc une hauteur maximale de <span class="math inline">\(\log _2 N\)</span> avec <span class="math inline">\(N\)</span> le nombre d'&#233;l&#233;ments du tas. Pour l'insertion d'un &#233;l&#233;ment, on fait dans le pire des cas remonter le n&#339;ud jusqu'&#224; la racine et donc on effectue <span class="math inline">\(\log _2 N\)</span> op&#233;rations. Pareil pour l'extraction du min/max, on fait dans le pire des cas <span class="math inline">\(\log _2 N\)</span> &#233;changes, r&#233;sultant dans les deux cas en une complexit&#233; en <span class="math inline">\(O(\log _2 N)\)</span>.</p>
<p>Pour ce qui est de la complexit&#233; en m&#233;moire, il n'y a aucuns doublons, on occupe donc uniquement l'espace n&#233;cessaire pour stocker <span class="math inline">\(N\)</span> &#233;l&#233;ments.</p>
<h2 id="impl&#233;mentation">Impl&#233;mentation</h2>
<p>Une impl&#233;mentation en C d'un tas max :</p>
<a href="javascript:toggle_visibility('tas_max.c');">tas_max.c</a>
<div id="tas_max.c" style="display: none;">
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;stdio.h&gt;</span>

<span class="ot">#define NB_NOEUD_MAX 1000</span>

<span class="dt">int</span> tas[NB_NOEUD_MAX];
<span class="dt">int</span> nbElement;

<span class="dt">void</span> echanger(<span class="dt">int</span> a, <span class="dt">int</span> b)
{
   <span class="dt">int</span> c;

   c = tas[a];
   tas[a] = tas[b];
   tas[b] = c;
}

<span class="dt">int</span> max(<span class="dt">int</span> a, <span class="dt">int</span> b)
{
   <span class="kw">if</span>(tas[a] &gt; tas[b])
      <span class="kw">return</span> a;
   <span class="kw">else</span>
      <span class="kw">return</span> b;
}

<span class="dt">void</span> inserer(<span class="dt">int</span> valeur)
{
   <span class="dt">int</span> noeud, pere;

   ++nbElement;
   noeud = nbElement;
   tas[nbElement] = valeur;

   pere = noeud / <span class="dv">2</span>;
   <span class="kw">while</span>(pere != <span class="dv">0</span> &amp;&amp; 
         tas[noeud] &gt; tas[pere]) {
      echanger(noeud, pere);

      noeud = pere;
      pere = noeud / <span class="dv">2</span>;
   }
}

<span class="dt">int</span> extraire(<span class="dt">void</span>)
{
   <span class="dt">int</span> racine;
   <span class="dt">int</span> noeud, gauche, droit, fils;

   racine = tas[<span class="dv">1</span>];

   tas[<span class="dv">1</span>] = tas[nbElement];
   --nbElement;

   noeud = <span class="dv">1</span>;
   gauche = <span class="dv">2</span>;
   droit = <span class="dv">3</span>;

   <span class="kw">while</span>(gauche &lt;= nbElement &amp;&amp;
         (tas[noeud] &lt; tas[gauche] || tas[noeud] &lt; tas[droit])) {
      fils = max(gauche, droit);
      echanger(noeud, fils);

      noeud = fils;
      gauche = <span class="dv">2</span> * noeud;
      droit = <span class="dv">2</span> * noeud + <span class="dv">1</span>;
   }

   <span class="kw">return</span> racine;
}

<span class="dt">int</span> estPuissanceDeux(<span class="dt">int</span> x)
{
   <span class="kw">return</span> (x &amp; (x - <span class="dv">1</span>)) == <span class="dv">0</span>;
}

<span class="dt">void</span> afficher(<span class="dt">void</span>)
{
   <span class="dt">int</span> iEle;
   <span class="kw">for</span>(iEle = <span class="dv">1</span>; iEle &lt;= nbElement; ++iEle) {
      printf(<span class="st">&quot;%d &quot;</span>, tas[iEle]);
      <span class="kw">if</span>(estPuissanceDeux(iEle + <span class="dv">1</span>))
         printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
   }

   printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
}</code></pre></div>
</div>
<p><em>Pour repr&#233;senter mon tas, j'utilise un simple tableau comme vu dans les impl&#233;mentations d'arbre binaire (<a href="/algo/structure/arbre/arbre_binaire.html#tableau">lien</a>).</em></p>
<p>J'impl&#233;mente un tas maximal, mais la version minimale du tas est quasiment la m&#234;me, il suffit de changer <code>tas[noeud] &gt; tas[pere]</code>, <code>tas[noeud] &lt; tas[gauche] || tas[noeud] &lt; tas[droit]</code> ainsi que la fonction <code>max</code>. Le code est plut&#244;t simple, mais j'utilise une petite astuce pour afficher le tas (la fonction <code>afficher</code> est juste l&#224; pour d&#233;bugger en g&#233;n&#233;ral, et voir si le tas est bien celui attendu). Pour afficher mon tas, je sais qu'il faut effectuer un retour &#224; la ligne lorsque le n&#339;ud est le 1er, le 3&#232;me, le 7&#232;me, 15&#232;me, etc. et tous ces nombres sont des puissances de 2 si l'on rajoute 1. De ce fait, on peut utiliser des <a href="https://en.wikipedia.org/wiki/Bitwise_operation">op&#233;rations bit &#224; bit</a> afin de v&#233;rifier si <code>noeud + 1</code> est une puissance de 2, et si c'est le cas, on a termin&#233; l'&#233;tage actuel du tas. C'est loin d'&#234;tre indispensable &#224; la compr&#233;hension du code, mais c'est toujours int&#233;ressant &#224; savoir.</p>
<p>En C++, la <a href="https://en.wikipedia.org/wiki/Standard_Template_Library">STL</a> (<em>Standard Template Library</em>) a une impl&#233;mentation d'une <a href="/algo/structure/file.html#file-&#224;-priorit&#233;">file &#224; priorit&#233;</a> utilisant un tas max : <a href="http://www.cplusplus.com/reference/queue/priority_queue/"><code>priority_queue</code></a>. Il est possible d'utiliser cette structure afin d'avoir un tas min, en red&#233;finissant l'op&#233;rateur <code>&lt;</code> nous permettant de changer l'ordre de priorit&#233; dans le tas :</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;queue&gt;</span>

<span class="kw">struct</span> Element
{
   <span class="dt">int</span> valeur;
   <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="dt">const</span> Element &amp;autre) <span class="dt">const</span>
   {
      <span class="kw">if</span>(valeur &lt; autre.valeur)
         <span class="kw">return</span> <span class="kw">false</span>;
      <span class="kw">else</span>
         <span class="kw">return</span> <span class="kw">true</span>;
   }
};

priority_queue &lt;Element&gt; tasMin;</code></pre></div>
<h2 id="variantes">Variantes</h2>
<p>Le tas poss&#232;dent beaucoup de variantes, certaines sont plus utiles que d'autres, et en g&#233;n&#233;ral on choisit la plus appropri&#233;e en fonction des donn&#233;es que l'on re&#231;oit, mais aussi par rapport aux op&#233;rations que l'on souhaite effectuer dessus. On peut d&#233;j&#224; citer toutes les diff&#233;rentes versions du tas : <strong>binaire</strong>, <strong>ternaire</strong>, et m&#234;me de fa&#231;on plus globale <strong>n-aire</strong>. Il est aussi possible de d&#233;couper notre tas en plusieurs sous arbres de tailles sp&#233;cifiques, suivant un ordre pr&#233;cis, et permettant des am&#233;liorations th&#233;oriques de la complexit&#233; des op&#233;rations. Je dis bien th&#233;orique, car en pratique les impl&#233;mentations ne sont pas sp&#233;cialement plus rapides que des tas binaires classiques, ce sont donc des structures peu utilis&#233;es en pratique, mais qu'on peut retrouver dans certaines am&#233;liorations d'algorithmes. Les plus connus sont le <a href="https://en.wikipedia.org/wiki/Fibonacci_heap"><strong>tas de Fibonacci</strong></a>, le <a href="https://en.wikipedia.org/wiki/Binomial_heap"><strong>tas binomial</strong></a>, ou encore <a href="https://en.wikipedia.org/wiki/Pairing_heap">le tas jumel&#233;</a> mais on peut voir ce principe dans l'am&#233;lioration du tri par tas : le <a href="/algo/tri/tri_tas.html#smoothsort">smoothsort</a>. Enfin, il y a diff&#233;rentes variantes qui s'appuient sur l'id&#233;e d'un tas, mais la modifie afin de proposer des avantages pr&#233;cis pour des algorithmes ou bien des op&#233;rations, comme le <a href="https://en.wikipedia.org/wiki/Weak_heap"><strong>tas faible</strong></a> qui se concentre sur le tri principalement.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Le tas est donc une structure de donn&#233;es adapt&#233;e aux op&#233;rations de recherche de minimum/maximum, et de tri. On le retrouve &#224; la base du <a href="/algo/tri/tri_tas.html">tri par tas</a>, mais aussi dans la cr&#233;ation d'une <a href="/algo/structure/file.html#file-&#224;-priorit&#233;">file &#224; priorit&#233;</a> qui elle sert dans l'<a href="/algo/structure/graphe/plus_court_chemin.html#dijkstra">algorithme de plus court chemin de Dijkstra</a> par exemple. Des variantes de tas permettent aussi des am&#233;liorations dans plusieurs cat&#233;gories d'algorithmes, et cette structure de donn&#233;es peut tr&#232;s vite cr&#233;er d'autres structures complexes et puissantes avec des complexit&#233;s en temps et en m&#233;moire faibles.</p>
 
      <!-- ------------ -->

      <footer>
         <hr>
         <p>Une question ? Une suggestion ? N'h&#233;sitez pas &#224; me <a href="/a_propos.html">contacter</a> pour me communiquer vos remarques.
         <br>
      </footer>

   </body>
</html>
