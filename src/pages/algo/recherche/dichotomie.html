<!DOCTYPE html>
<html>
   <head>
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato&#38;subset=latin,latin-ext" type="text/css" />
      <link rel="icon" type="image/x-icon" href="//static.napnac.ga/img/favicon.ico">
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/github-gist.min.css">

      <!-- Syntax highlighting -->
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script>

      <!-- Renders LaTeX expression -->
      <script type="text/x-mathjax-config">
         MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
      </script>
      <script type="text/javascript" async
         src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">
      </script>

      <!-- CSS -->
<style>
body {
   font-family: "Helvetica Neue", 'Lato', Helvetica, sans-serif;
   max-width: 1000px;
   margin: 0 auto;
   position: relative;
   width: 95%;
   line-height: 1.5;
}

/* ---- Titles ---- */

h1 {
   padding-top: 2%;
   padding-bottom: 2%;
   color: #DE4834;
}

h2, h3, h4, h5, h6 {
   padding-top: 1%;
   padding-bottom: 1%;
   color: #DE4834;
}

/* ---- Link ---- */

a {
   text-decoration: none;
   color: #2E64FE;
}

/* ---- List (+ main menu list) ---- */

ul {
   padding-left: 30px;
}

#main_menu {
   list-style: none;
   margin: 0;
   padding: 0;
   text-align: center;
}
#main_menu li {
   display: inline;
   margin-right: 1px;
}
#main_menu li a {
   line-height: 1em;
   padding: 4px 20px;
   text-align: center;
}
#main_menu li a:hover, #main_menu li a:active {
   text-decoration: underline;
}

/* ---- Tables (same look as from github markdown layout) ---- */

table {
   display: block;
   width: 100%;
   overflow: auto;
   word-break: normal;
   word-break: keep-all;
   border-collapse: collapse;
   border-spacing: 0;
   margin-top: 0;
   margin-bottom: 16px;
}

table th {
   font-weight: bold;
}

table th,
table td {
   padding: 6px 13px;
   border: 1px solid #ddd;
}

table tr {
   background-color: #fff;
   border-top: 1px solid #ccc;
}

table tr:nth-child(2n) {
   background-color: #f8f8f8;
}

/* ---- Image and caption ---- */

.figure {
   text-align: center;
}

.caption {
   font-style: italic;
   text-align: center;
}

/* ---- Summary ---- */

#summary {
   width: 70%;
   text-align: justify;
   line-height: 1.6;
}

/* ---- Code ---- */
pre {
   width: 90%;
   white-space: pre-wrap;
   word-break: break-all;
   word-wrap: break-word;
}

/* ---- Temporary css ---- */

.pret {
   background-color: #00CC00;
   display: inline;
}

.relire {
   background-color: #FF9900;
   display: inline;
}

.faire {
   background-color: #FF0000;
   display: inline;
}
</style>
      <!---- ---->

      <title>Dichotomie - napnac</title>
   </head>

   <body>

      <!-- Javascript -->
<script type="text/javascript">
function toggle_visibility(id) {
   var element = document.getElementById(id);
   if(element.style.display == 'block')
      element.style.display = 'none';
   else
      element.style.display = 'block';
}
</script>
      <!---- ---->

      <header>
         <a href="/">
            <img src="//static.napnac.ga/img/logo.png" alt="Logo du site" height="100" width="300">
         </a>

      </header>

      <nav>
         <ul id="main_menu">
            <li><a href="/">Accueil</a></li>
            <li><a href="/articles.html">Articles</a></li>
            <li><a href="/projets.html">Projets</a></li>
            <li><a href="/a_propos.html">A propos</a></li>
         </ul>
      </nav>

      <!-- Page/Article -->

<a href=""><h1 id="dichotomie">Dichotomie</h1></a>
<p>Publi&#233; le : 28/06/2014<br />
<em>Modifi&#233; le : 14/01/2016</em></p>
<ul id="summary">
<li><a href="#introduction">Introduction</a></li>
<li><a href="#principe-de-la-dichotomie">Principe de la dichotomie</a></li>
<li><a href="#exemple">Exemple</a></li>
<li><a href="#pseudo-code">Pseudo-code</a></li>
<li><a href="#complexit&#233;">Complexit&#233;</a></li>
<li><a href="#impl&#233;mentation">Impl&#233;mentation</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>Si je vous donne un annuaire t&#233;l&#233;phonique contenant plusieurs milliers de coordonn&#233;es, et que je vous demande de trouver une personne, normalement en quelques secondes vous y arrivez. M&#234;me si je rajoute plusieurs millions de personnes dans l'annuaire, vous devriez toujours &#234;tre capable de rep&#233;rer n'importe qui en moins d'une minute. Mais comment faire pour qu'un ordinateur nous remplace pour effectuer cette t&#226;che ? Comment concr&#233;tiser l'algorithme que vous utilisez (sans le savoir) pour qu'un ordinateur le comprenne ? Votre cerveau est un outil incroyable qui n'aime pas faire des actions r&#233;p&#233;titives, et il essaiera naturellement de trouver une fa&#231;on plus rapide de r&#233;soudre un probl&#232;me. Vous n'auriez pas id&#233;e de commencer par regarder toutes les personnes avec un pr&#233;nom en &quot;A&quot; si vous savez que la personne que vous cherchez est &quot;Jean&quot;. Ce que vous faites plut&#244;t, c'est que vous divisez l'intervalle de recherche &#224; partir d'un r&#233;sultat, vous ouvrez par exemple une page au hasard qui devrait correspondre &#224; peu pr&#232;s &#224; la lettre que vous cherchez, et vous affinez au fur et &#224; mesure en fonction du mot de la page. Votre m&#233;thode se base sur une caract&#233;ristique tr&#232;s importante de votre annuaire : il est <strong>tri&#233;</strong> par ordre alphab&#233;tique.</p>
<p>Jouons &#224; un petit jeu appel&#233; <em>le plus ou moins</em>. Je choisis un nombre entre 1 et 100 et vous devez le deviner en moins de coup possible. A chaque fois que vous me dites un nombre, je vous dis si ce dernier est sup&#233;rieur ou inf&#233;rieur &#224; celui que j'ai choisi (ou &#233;gal si vous avez trouv&#233;).</p>
<p>Vu comme &#231;a, on pourrait se dire qu'on a 1 chance sur 100 de tomber sur le bon nombre, mais en r&#233;fl&#233;chissant bien on peut am&#233;liorer nos chances en s'aidant de la r&#233;ponse que je donne &#224; chaque fois (si c'est plus ou moins). Je choisis donc mon nombre, et au premier tour vous dites 50, si je vous dis &#171; plus &#187; vous savez que mon nombre sera forc&#233;ment dans l'intervalle de 51 &#224; 100, si je vous dis &#171; moins &#187; il sera dans l'intervalle 1 &#224; 49, et si je vous dis &#233;gal vous avez trouv&#233; le nombre. On peut continuer d'utiliser ce principe pour diviser par deux &#224; chaque fois notre intervalle de recherche jusqu'&#224; avoir un seul &#233;l&#233;ment dans notre intervalle, qui est forc&#233;ment celui que j'ai choisi au d&#233;but du jeu. Cette m&#233;thode s'appelle la dichotomie, et vous utilisez un algorithme tr&#232;s similaire lorsque vous recherchez une personne dans un annuaire, mais elle ne s'applique pas qu'&#224; cela, et on la retrouve dans bien d'autres domaines.</p>
<h2 id="principe-de-la-dichotomie">Principe de la dichotomie</h2>
<p>La dichotomie (<em>binary search</em> en anglais), est un algorithme de recherche efficace pour trouver un nombre dans un ensemble <strong>tri&#233;</strong> (ce point est tr&#232;s important puisque l'algorithme repose dessus). La dichotomie utilise le principe du <a href="https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms">diviser pour r&#233;gner</a> afin de d&#233;couper notre probl&#232;me initiale en un sous probl&#232;me plus petit.</p>
<p>On commence toujours la dichotomie dans un intervalle de recherche, puis &#224; chaque &#233;tape on compare notre &#233;l&#233;ment qu'on cherche &#224; l'&#233;l&#233;ment central de l'intervalle :</p>
<ul>
<li>Si l'&#233;l&#233;ment qu'on cherche est sup&#233;rieur, on peut continuer de chercher dans la moiti&#233; sup&#233;rieure de l'intervalle.</li>
<li>Si l'&#233;l&#233;ment est inf&#233;rieur, on continue de chercher dans la moiti&#233; inf&#233;rieure.</li>
<li>Sinon l'&#233;l&#233;ment est &#233;gal, on l'a donc trouv&#233; et on peut arr&#234;ter de chercher.</li>
</ul>
<p>A chaque tour, on actualise notre intervalle de recherche et on recommence les op&#233;rations tant qu'on n'a pas trouv&#233; notre &#233;l&#233;ment.</p>
<h2 id="exemple">Exemple</h2>
<p>Prenons un tableau tri&#233; : 1, 8, 15, 42, 99, 160, 380, 512, 678, 952, 1304. Nous cherchons dans ce tableau l'emplacement de l'&#233;l&#233;ment 512 et nous allons utiliser le principe de la dichotomie pour le trouver :</p>
<p>1, 8, 15, 42, 99, <strong>160</strong>, 380, 512, 678, 952, 1304 : on compare l'&#233;l&#233;ment du milieu de l'intervalle (c'est le premier tour, on commence donc par un intervalle contenant tout le tableau) avec l'&#233;l&#233;ment qu'on cherche. 512 &gt; 160, donc on peut oublier les &#233;l&#233;ments avant 160 (compris), pour se concentrer sur la partie sup&#233;rieure de l'intervalle.</p>
<p>380, 512, <strong>678</strong>, 952, 1304 : notre intervalle est donc divis&#233; en deux, et on continue nos op&#233;rations. 512 &lt; 678 donc on continue notre recherche dans la partie inf&#233;rieure de l'intervalle.</p>
<p><strong>380</strong>, 512 : 512 &gt; 380, on continue dans la partie sup&#233;rieure de l'intervalle.</p>
<p>512 : notre intervalle ne contient plus qu'un seul &#233;l&#233;ment, c'est donc forc&#233;ment celui qu'on recherche.</p>
<p>Pour r&#233;sum&#233; le principe :</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/recherche/dichotomie/exemple_dichotomie.png" alt="Exemple de dichotomie" />
<p class="caption">Exemple de dichotomie</p>
</div>
<p>L'&#233;l&#233;ment en bleu est celui du milieu que l'on compare, et ensuite on choisit la bonne portion du tableau (en vert) en fonction de cette comparaison pour couper notre intervalle en deux &#224; chaque tour.</p>
<h2 id="pseudo-code">Pseudo-code</h2>
<p>On peut faire le pseudo-code suivant d'un algorithme de la dichotomie :</p>
<pre class="nohighlight"><code>dichotomie :

   Tant qu&#39;on n&#39;a pas trouv&#233; l&#39;&#233;l&#233;ment
      Si l&#39;&#233;l&#233;ment est sup&#233;rieur au milieu
         R&#233;duire l&#39;intervalle &#224; la partie sup&#233;rieure
      Si l&#39;&#233;l&#233;ment est inf&#233;rieur au milieu
         R&#233;duire l&#39;intervalle &#224; la partie inf&#233;rieure
      Sinon
         Arreter la recherche</code></pre>
<p>Et il est tout &#224; fait possible d'&#233;crire cet algorithme sous forme <a href="https://en.wikipedia.org/wiki/Recursion_%28computer_science%29">r&#233;cursive</a> :</p>
<pre class="nohighlight"><code>dichotomie (d&#233;but, fin) :

   Si la recherche est sup&#233;rieure au milieu
      Retourner dichotomie(milieu + 1, fin)
   Si la recherche est inf&#233;rieure au milieu
      Retourner dichotomie(debut, milieu - 1)
   Sinon
      Retourner l&#39;&#233;l&#233;ment au milieu</code></pre>
<h2 id="complexit&#233;">Complexit&#233;</h2>
<p>Pour calculer la complexit&#233; en temps de la recherche dichotomique, on peut visualiser la d&#233;composition des intervalles gr&#226;ce &#224; un <a href="/algo/structure/arbre.html">arbre</a> :</p>
<div class="figure">
<img src="//static.napnac.ga/img/algo/recherche/dichotomie/calcul_complexite.png" alt="Calcul de la complexit&#233;" />
<p class="caption">Calcul de la complexit&#233;</p>
</div>
<p>Chaque op&#233;ration possible est repr&#233;sent&#233;e dans notre arbre, c'est-&#224;-dire qu'&#224; chaque tour on coupe notre tableau (qu'on note <span class="math inline">\(n\)</span>) en deux. On voit qu'on arrive &#224; une profondeur maximale de l'arbre en <span class="math inline">\(\log _2 N\)</span> avec <span class="math inline">\(N\)</span> la taille de notre tableau (pour en savoir plus sur le logarithme : <a href="https://en.wikipedia.org/wiki/Logarithm">lien de la page Wikip&#233;dia</a>), la complexit&#233; de la recherche dichotomique est donc dans le pire des cas en <span class="math inline">\(O(\log _2 N)\)</span>.</p>
<p>Pour vous faire comprendre &#224; quel point cette recherche est efficace, imaginons que vous poss&#233;dez une biblioth&#232;que num&#233;rique de <span class="math inline">\(N\)</span> livres tous tri&#233;s en fonction du titre par ordre alphab&#233;tique. Votre machine sur laquelle vous faites vos recherches de livres est tr&#232;s lente, et peut effectuer uniquement 2000 op&#233;rations &#224; la seconde (aujourd'hui les ordinateurs classiques peuvent en effectuer plusieurs milliards...). Si vous impl&#233;mentez une recherche dichotomique, il vous faudra environ plus de livres qu'il n'y a de particules dans un billion d'univers visible pour que votre machine prenne plus de temps qu'un clignement d'&#339;il.</p>
<h2 id="impl&#233;mentation">Impl&#233;mentation</h2>
<p>Dans ces impl&#233;mentations, je suppose que l'&#233;l&#233;ment appartient bien au tableau afin de simplifier le code et de se concentrer sur la recherche dichotomique.</p>
<h3 id="r&#233;cursif">R&#233;cursif</h3>
<p>L'impl&#233;mentation r&#233;cursive en C de la recherche :</p>
<a href="javascript:toggle_visibility('dichotomie_recursif.c');">dichotomie_recursif.c</a>
<div id="dichotomie_recursif.c" style="display: none;">
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;stdio.h&gt;</span>

<span class="ot">#define TAILLE_MAX 1000</span>

<span class="dt">int</span> tableau[TAILLE_MAX];
<span class="dt">int</span> taille;
<span class="dt">int</span> recherche;

<span class="dt">int</span> dichotomie(<span class="dt">int</span> debut, <span class="dt">int</span> fin)
{
   <span class="dt">int</span> milieu;
   milieu = (debut + fin) / <span class="dv">2</span>;

   <span class="kw">if</span>(recherche &gt; tableau[milieu])
      <span class="kw">return</span> dichotomie(milieu + <span class="dv">1</span>, fin);
   <span class="kw">else</span> <span class="kw">if</span>(recherche &lt; tableau[milieu])
      <span class="kw">return</span> dichotomie(debut, milieu - <span class="dv">1</span>);
   <span class="kw">else</span>
      <span class="kw">return</span> milieu;
}

<span class="dt">int</span> main(<span class="dt">void</span>)
{
   <span class="dt">int</span> iTab;

   scanf(<span class="st">&quot;%d</span><span class="ch">\n</span><span class="st">&quot;</span>, &amp;taille);

   <span class="kw">for</span>(iTab = <span class="dv">0</span>; iTab &lt; taille; ++iTab)
      scanf(<span class="st">&quot;%d &quot;</span>, &amp;tableau[iTab]);
   scanf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);

   scanf(<span class="st">&quot;%d</span><span class="ch">\n</span><span class="st">&quot;</span>, &amp;recherche);

   printf(<span class="st">&quot;%d</span><span class="ch">\n</span><span class="st">&quot;</span>, dichotomie(<span class="dv">0</span>, taille - <span class="dv">1</span>) + <span class="dv">1</span>);

   <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</div>
<p>Si on donne notre tableau en entr&#233;e, ainsi que l'&#233;l&#233;ment qu'on recherche :</p>
<pre class="nohighlight"><code>11
1 8 15 42 99 160 380 512 678 952 1304
512</code></pre>
<p>On obtient bien en sortie :</p>
<pre class="nohighlight"><code>8</code></pre>
<h3 id="it&#233;ratif">It&#233;ratif</h3>
<p>La version it&#233;rative en C :</p>
<a href="javascript:toggle_visibility('dichotomie_iteratif.c');">dichotomie_iteratif.c</a>
<div id="dichotomie_iteratif.c" style="display: none;">
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;stdio.h&gt;</span>

<span class="ot">#define TAILLE_MAX 1000</span>

<span class="dt">int</span> tableau[TAILLE_MAX];
<span class="dt">int</span> taille;
<span class="dt">int</span> recherche;

<span class="dt">int</span> dichotomie(<span class="dt">void</span>)
{
   <span class="dt">int</span> debut, milieu, fin;

   debut = <span class="dv">0</span>;
   fin = taille - <span class="dv">1</span>;

   <span class="kw">do</span>
   {
      milieu = (debut + fin) / <span class="dv">2</span>;

      <span class="kw">if</span>(recherche &gt; tableau[milieu])
         debut = milieu + <span class="dv">1</span>;
      <span class="kw">else</span> <span class="kw">if</span>(recherche &lt; tableau[milieu])
         fin = milieu - <span class="dv">1</span>;
      <span class="kw">else</span>
         <span class="kw">return</span> milieu;

   } <span class="kw">while</span>(tableau[milieu] != recherche);

   <span class="kw">return</span> -<span class="dv">1</span>;
}

<span class="dt">int</span> main(<span class="dt">void</span>)
{
   <span class="dt">int</span> iTab;

   scanf(<span class="st">&quot;%d</span><span class="ch">\n</span><span class="st">&quot;</span>, &amp;taille);

   <span class="kw">for</span>(iTab = <span class="dv">0</span>; iTab &lt; taille; ++iTab)
      scanf(<span class="st">&quot;%d &quot;</span>, &amp;tableau[iTab]);
   scanf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);

   scanf(<span class="st">&quot;%d</span><span class="ch">\n</span><span class="st">&quot;</span>, &amp;recherche);

   printf(<span class="st">&quot;%d</span><span class="ch">\n</span><span class="st">&quot;</span>, dichotomie() + <span class="dv">1</span>);

   <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</div>
<p>Le tableau et l'&#233;l&#233;ment recherch&#233; :</p>
<pre class="nohighlight"><code>11
1 8 15 42 99 160 380 512 678 952 1304
512</code></pre>
<p>Et la sortie obtenue :</p>
<pre class="nohighlight"><code>8</code></pre>
<h3 id="cc">C/C++</h3>
<p>En C, il existe une fonction <a href="http://www.cplusplus.com/reference/cstdlib/bsearch/"><code>bsearch</code></a> permettant de r&#233;aliser une dichotomie.</p>
<p>De m&#234;me, en C++, la <a href="https://en.wikipedia.org/wiki/Standard_Template_Library">STL</a> (<em>Standard Template Library</em>) impl&#233;mente des fonctions de recherche dichotomique :</p>
<ul>
<li><a href="http://www.cplusplus.com/reference/algorithm/lower_bound/"><code>lower_bound</code></a></li>
<li><a href="http://www.cplusplus.com/reference/algorithm/upper_bound/"><code>upper_bound</code></a></li>
<li><a href="http://www.cplusplus.com/reference/algorithm/equal_range/"><code>equal_range</code></a></li>
<li><a href="http://www.cplusplus.com/reference/algorithm/binary_search/"><code>binary_search</code></a></li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>Nous avons donc vu que notre dichotomie permet de chercher, de mani&#232;re g&#233;n&#233;rale, un &#233;l&#233;ment dans un ensemble d'&#233;l&#233;ment tri&#233; extr&#234;mement rapidement en <span class="math inline">\(O(\log _2 N)\)</span>. Cet algorithme s'applique tr&#232;s bien &#224; des tableaux pouvant contenir diff&#233;rents types de donn&#233;es (entiers, flottants, cha&#238;nes de caract&#232;res, etc.), mais on le retrouve aussi dans plusieurs autres applications :</p>
<ul>
<li>L'optimisation : on utilise la dichotomie dans plusieurs optimisations d'algorithmes, comme avec le <a href="/algo/tri/tri_insertion.html">tri par insertion</a> o&#249; la recherche dichotomique am&#233;liore grandement la complexit&#233; en temps.</li>
<li>L'&#233;tude de fonction monotone : si on connait une fonction math&#233;matique respectant <span class="math inline">\(f(x) \leq f(y)\)</span> avec <span class="math inline">\(x &lt; y\)</span>, on peut appliquer une recherche dichotomique (pour l'intervalle <span class="math inline">\([x, y]\)</span>) sur les &#233;l&#233;ments de cette fonction puisqu'elle respecte le principe de l'algorithme.</li>
<li>Trouver un bug dans son programme : &#231;a peut paraitre surprenant, mais il m'arrive d'utiliser l'id&#233;e de la recherche dichotomique pour situer un bug dans mon programme. Notre intervalle de recherche au d&#233;but est le code entier (on peut commencer par un plus petit intervalle si notre code est tr&#232;s long), et on va chercher &#224; le r&#233;duire petit &#224; petit en &#233;liminant des parties que l'on consid&#232;re justes. Finalement, on se retrouve avec un intervalle assez restreint pour trouver l'origine du bug et pouvoir ainsi le fixer.</li>
</ul>
 
      <!-- ------------ -->

      <footer>
         <hr>
         <p>Une question ? Une suggestion ? N'h&#233;sitez pas &#224; me <a href="/a_propos.html">contacter</a> pour me communiquer vos remarques.
         <br>
      </footer>

   </body>
</html>
